diff -crB /home/rxtx/Desktop/linux-4.3.3/arch/powerpc/configs/gamecube_defconfig ./arch/powerpc/configs/gamecube_defconfig
*** /home/rxtx/Desktop/linux-4.3.3/arch/powerpc/configs/gamecube_defconfig	2015-12-15 16:41:43.000000000 +1100
--- ./arch/powerpc/configs/gamecube_defconfig	2015-12-19 19:17:07.454126117 +1100
***************
*** 1,101 ****
--- 1,1561 ----
+ #
+ # Automatically generated file; DO NOT EDIT.
+ # Linux/powerpc 3.12.3 Kernel Configuration
+ #
+ # CONFIG_PPC64 is not set
+ 
+ #
+ # Processor support
+ #
+ CONFIG_PPC_BOOK3S_32=y
+ # CONFIG_PPC_85xx is not set
+ # CONFIG_PPC_8xx is not set
+ # CONFIG_40x is not set
+ # CONFIG_44x is not set
+ # CONFIG_E200 is not set
+ CONFIG_PPC_BOOK3S=y
+ CONFIG_6xx=y
+ CONFIG_PPC_FPU=y
+ # CONFIG_ALTIVEC is not set
+ CONFIG_PPC_STD_MMU=y
+ CONFIG_PPC_STD_MMU_32=y
+ # CONFIG_PPC_MM_SLICES is not set
+ CONFIG_PPC_HAVE_PMU_SUPPORT=y
+ CONFIG_PPC_PERF_CTRS=y
+ # CONFIG_SMP is not set
+ CONFIG_NOT_COHERENT_CACHE=y
+ # CONFIG_PPC_DOORBELL is not set
+ CONFIG_PPC32=y
+ CONFIG_32BIT=y
+ CONFIG_WORD_SIZE=32
+ # CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+ # CONFIG_ARCH_DMA_ADDR_T_64BIT is not set
+ CONFIG_MMU=y
+ # CONFIG_HAVE_SETUP_PER_CPU_AREA is not set
+ # CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK is not set
+ CONFIG_NR_IRQS=512
+ CONFIG_STACKTRACE_SUPPORT=y
+ CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+ CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+ CONFIG_LOCKDEP_SUPPORT=y
+ CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+ CONFIG_ARCH_HAS_ILOG2_U32=y
+ CONFIG_GENERIC_HWEIGHT=y
+ CONFIG_PPC=y
+ CONFIG_EARLY_PRINTK=y
+ CONFIG_GENERIC_NVRAM=y
+ CONFIG_SCHED_OMIT_FRAME_POINTER=y
+ CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+ CONFIG_PPC_OF=y
+ # CONFIG_PPC_UDBG_16550 is not set
+ # CONFIG_GENERIC_TBSYNC is not set
+ CONFIG_AUDIT_ARCH=y
+ CONFIG_GENERIC_BUG=y
+ # CONFIG_EPAPR_BOOT is not set
+ # CONFIG_DEFAULT_UIMAGE is not set
+ CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+ # CONFIG_PPC_DCR_NATIVE is not set
+ # CONFIG_PPC_DCR_MMIO is not set
+ CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+ CONFIG_ARCH_SUPPORTS_UPROBES=y
+ CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+ CONFIG_IRQ_WORK=y
+ 
+ #
+ # General setup
+ #
+ CONFIG_BROKEN_ON_SMP=y
+ CONFIG_INIT_ENV_ARG_LIMIT=32
+ CONFIG_CROSS_COMPILE=""
+ # CONFIG_COMPILE_TEST is not set
  CONFIG_LOCALVERSION="-gcn"
+ CONFIG_LOCALVERSION_AUTO=y
+ CONFIG_DEFAULT_HOSTNAME="(none)"
+ CONFIG_SWAP=y
  CONFIG_SYSVIPC=y
+ CONFIG_SYSVIPC_SYSCTL=y
+ # CONFIG_POSIX_MQUEUE is not set
+ # CONFIG_FHANDLE is not set
+ # CONFIG_AUDIT is not set
+ 
+ #
+ # IRQ subsystem
+ #
+ CONFIG_GENERIC_IRQ_SHOW=y
+ CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+ CONFIG_IRQ_DOMAIN=y
+ # CONFIG_IRQ_DOMAIN_DEBUG is not set
+ CONFIG_IRQ_FORCED_THREADING=y
+ CONFIG_SPARSE_IRQ=y
+ CONFIG_GENERIC_TIME_VSYSCALL_OLD=y
+ CONFIG_GENERIC_CLOCKEVENTS=y
+ CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+ CONFIG_GENERIC_CMOS_UPDATE=y
+ 
+ #
+ # Timers subsystem
+ #
+ CONFIG_HZ_PERIODIC=y
+ # CONFIG_NO_HZ_IDLE is not set
+ # CONFIG_NO_HZ is not set
+ # CONFIG_HIGH_RES_TIMERS is not set
+ 
+ #
+ # CPU/Task time and stats accounting
+ #
+ CONFIG_TICK_CPU_ACCOUNTING=y
+ # CONFIG_BSD_PROCESS_ACCT is not set
+ # CONFIG_TASKSTATS is not set
+ 
+ #
+ # RCU Subsystem
+ #
+ CONFIG_TREE_PREEMPT_RCU=y
+ CONFIG_PREEMPT_RCU=y
+ CONFIG_RCU_STALL_COMMON=y
+ CONFIG_RCU_FANOUT=32
+ CONFIG_RCU_FANOUT_LEAF=16
+ # CONFIG_RCU_FANOUT_EXACT is not set
+ # CONFIG_TREE_RCU_TRACE is not set
+ # CONFIG_RCU_BOOST is not set
+ # CONFIG_RCU_NOCB_CPU is not set
  CONFIG_IKCONFIG=y
  CONFIG_IKCONFIG_PROC=y
  CONFIG_LOG_BUF_SHIFT=14
+ # CONFIG_CGROUPS is not set
+ # CONFIG_CHECKPOINT_RESTORE is not set
+ # CONFIG_NAMESPACES is not set
+ # CONFIG_UIDGID_STRICT_TYPE_CHECKS is not set
+ # CONFIG_SCHED_AUTOGROUP is not set
+ # CONFIG_SYSFS_DEPRECATED is not set
+ # CONFIG_RELAY is not set
  CONFIG_BLK_DEV_INITRD=y
+ CONFIG_INITRAMFS_SOURCE=""
+ CONFIG_RD_GZIP=y
+ # CONFIG_RD_BZIP2 is not set
+ # CONFIG_RD_LZMA is not set
+ # CONFIG_RD_XZ is not set
+ # CONFIG_RD_LZO is not set
+ # CONFIG_RD_LZ4 is not set
+ # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+ CONFIG_SYSCTL=y
+ CONFIG_ANON_INODES=y
+ CONFIG_SYSCTL_EXCEPTION_TRACE=y
  CONFIG_EXPERT=y
+ # CONFIG_SYSCTL_SYSCALL is not set
+ CONFIG_KALLSYMS=y
+ CONFIG_KALLSYMS_ALL=y
+ CONFIG_PRINTK=y
+ CONFIG_BUG=y
  # CONFIG_ELF_CORE is not set
+ CONFIG_BASE_FULL=y
+ CONFIG_FUTEX=y
+ CONFIG_EPOLL=y
+ CONFIG_SIGNALFD=y
+ CONFIG_TIMERFD=y
+ CONFIG_EVENTFD=y
+ CONFIG_SHMEM=y
+ CONFIG_AIO=y
+ # CONFIG_EMBEDDED is not set
+ CONFIG_HAVE_PERF_EVENTS=y
+ 
+ #
+ # Kernel Performance Events And Counters
+ #
  CONFIG_PERF_EVENTS=y
+ # CONFIG_DEBUG_PERF_USE_VMALLOC is not set
  # CONFIG_VM_EVENT_COUNTERS is not set
+ CONFIG_COMPAT_BRK=y
  CONFIG_SLAB=y
+ # CONFIG_SLUB is not set
+ # CONFIG_SLOB is not set
+ # CONFIG_PROFILING is not set
+ CONFIG_TRACEPOINTS=y
+ CONFIG_HAVE_OPROFILE=y
+ # CONFIG_KPROBES is not set
+ # CONFIG_JUMP_LABEL is not set
+ # CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+ CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+ CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+ CONFIG_HAVE_IOREMAP_PROT=y
+ CONFIG_HAVE_KPROBES=y
+ CONFIG_HAVE_KRETPROBES=y
+ CONFIG_HAVE_ARCH_TRACEHOOK=y
+ CONFIG_HAVE_DMA_ATTRS=y
+ CONFIG_GENERIC_SMP_IDLE_THREAD=y
+ CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+ CONFIG_HAVE_DMA_API_DEBUG=y
+ CONFIG_HAVE_ARCH_JUMP_LABEL=y
+ CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG=y
+ CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+ CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+ CONFIG_MODULES_USE_ELF_RELA=y
+ CONFIG_CLONE_BACKWARDS=y
+ CONFIG_OLD_SIGSUSPEND=y
+ CONFIG_OLD_SIGACTION=y
+ 
+ #
+ # GCOV-based kernel profiling
+ #
+ # CONFIG_GCOV_KERNEL is not set
+ # CONFIG_HAVE_GENERIC_DMA_COHERENT is not set
+ CONFIG_SLABINFO=y
+ CONFIG_RT_MUTEXES=y
+ CONFIG_BASE_SMALL=0
  CONFIG_MODULES=y
+ # CONFIG_MODULE_FORCE_LOAD is not set
  CONFIG_MODULE_UNLOAD=y
+ # CONFIG_MODULE_FORCE_UNLOAD is not set
+ # CONFIG_MODVERSIONS is not set
+ # CONFIG_MODULE_SRCVERSION_ALL is not set
+ # CONFIG_MODULE_SIG is not set
+ CONFIG_BLOCK=y
+ CONFIG_LBDAF=y
  # CONFIG_BLK_DEV_BSG is not set
+ # CONFIG_BLK_DEV_BSGLIB is not set
+ # CONFIG_BLK_DEV_INTEGRITY is not set
+ # CONFIG_BLK_CMDLINE_PARSER is not set
+ 
+ #
+ # Partition Types
+ #
+ # CONFIG_PARTITION_ADVANCED is not set
+ CONFIG_MSDOS_PARTITION=y
+ CONFIG_EFI_PARTITION=y
+ 
+ #
+ # IO Schedulers
+ #
+ CONFIG_IOSCHED_NOOP=y
+ CONFIG_IOSCHED_DEADLINE=y
+ CONFIG_IOSCHED_CFQ=y
+ # CONFIG_DEFAULT_DEADLINE is not set
+ CONFIG_DEFAULT_CFQ=y
+ # CONFIG_DEFAULT_NOOP is not set
+ CONFIG_DEFAULT_IOSCHED="cfq"
+ CONFIG_UNINLINE_SPIN_UNLOCK=y
+ # CONFIG_FREEZER is not set
+ # CONFIG_PPC_XICS is not set
+ # CONFIG_PPC_ICP_NATIVE is not set
+ # CONFIG_PPC_ICP_HV is not set
+ # CONFIG_PPC_ICS_RTAS is not set
+ # CONFIG_GE_FPGA is not set
+ 
+ #
+ # Platform support
+ #
  # CONFIG_PPC_CHRP is not set
+ # CONFIG_PPC_MPC512x is not set
+ # CONFIG_PPC_MPC52xx is not set
  # CONFIG_PPC_PMAC is not set
+ # CONFIG_PPC_CELL is not set
+ # CONFIG_PPC_CELL_NATIVE is not set
+ # CONFIG_PPC_82xx is not set
+ # CONFIG_PQ2ADS is not set
+ # CONFIG_PPC_83xx is not set
+ # CONFIG_PPC_86xx is not set
  CONFIG_EMBEDDED6xx=y
+ # CONFIG_LINKSTATION is not set
+ # CONFIG_STORCENTER is not set
+ # CONFIG_MPC7448HPC2 is not set
+ # CONFIG_PPC_HOLLY is not set
+ # CONFIG_PPC_PRPMC2800 is not set
+ # CONFIG_PPC_C2K is not set
+ CONFIG_GAMECUBE_COMMON=y
+ # CONFIG_GAMECUBE_UDBG is not set
+ CONFIG_GAMECUBE_RSW=y
  CONFIG_GAMECUBE=y
+ # CONFIG_AMIGAONE is not set
+ # CONFIG_PPC_WSP is not set
+ # CONFIG_KVM_GUEST is not set
+ # CONFIG_EPAPR_PARAVIRT is not set
  # CONFIG_PPC_OF_BOOT_TRAMPOLINE is not set
+ # CONFIG_IPIC is not set
+ # CONFIG_MPIC is not set
+ # CONFIG_PPC_EPAPR_HV_PIC is not set
+ # CONFIG_MPIC_WEIRD is not set
+ # CONFIG_PPC_I8259 is not set
+ # CONFIG_PPC_RTAS is not set
+ # CONFIG_MMIO_NVRAM is not set
+ # CONFIG_MPIC_U3_HT_IRQS is not set
+ # CONFIG_PPC_MPC106 is not set
+ # CONFIG_PPC_970_NAP is not set
+ # CONFIG_PPC_P7_NAP is not set
+ 
+ #
+ # CPU Frequency scaling
+ #
+ # CONFIG_CPU_FREQ is not set
+ 
+ #
+ # CPUIdle driver
+ #
+ 
+ #
+ # CPU Idle
+ #
+ # CONFIG_CPU_IDLE is not set
+ # CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+ # CONFIG_TAU is not set
+ # CONFIG_FSL_ULI1575 is not set
+ # CONFIG_SIMPLE_GPIO is not set
+ 
+ #
+ # Kernel options
+ #
+ # CONFIG_HIGHMEM is not set
+ # CONFIG_HZ_100 is not set
+ CONFIG_HZ_250=y
+ # CONFIG_HZ_300 is not set
+ # CONFIG_HZ_1000 is not set
+ CONFIG_HZ=250
+ # CONFIG_SCHED_HRTICK is not set
+ # CONFIG_PREEMPT_NONE is not set
+ # CONFIG_PREEMPT_VOLUNTARY is not set
  CONFIG_PREEMPT=y
+ CONFIG_PREEMPT_COUNT=y
+ CONFIG_BINFMT_ELF=y
+ CONFIG_BINFMT_SCRIPT=y
+ # CONFIG_HAVE_AOUT is not set
  CONFIG_BINFMT_MISC=m
+ CONFIG_COREDUMP=y
+ # CONFIG_IOMMU_HELPER is not set
+ CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+ CONFIG_ARCH_HAS_WALK_MEMORY=y
+ CONFIG_ARCH_ENABLE_MEMORY_HOTREMOVE=y
  CONFIG_KEXEC=y
+ # CONFIG_CRASH_DUMP is not set
+ CONFIG_ARCH_FLATMEM_ENABLE=y
+ CONFIG_FLATMEM=y
+ CONFIG_FLAT_NODE_MEM_MAP=y
+ CONFIG_HAVE_MEMBLOCK=y
+ CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+ # CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+ CONFIG_PAGEFLAGS_EXTENDED=y
+ CONFIG_SPLIT_PTLOCK_CPUS=999999
+ CONFIG_COMPACTION=y
+ CONFIG_MIGRATION=y
+ # CONFIG_PHYS_ADDR_T_64BIT is not set
+ CONFIG_ZONE_DMA_FLAG=1
+ CONFIG_BOUNCE=y
+ CONFIG_VIRT_TO_BUS=y
+ # CONFIG_KSM is not set
+ CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+ CONFIG_CROSS_MEMORY_ATTACH=y
+ CONFIG_NEED_PER_CPU_KM=y
+ # CONFIG_CLEANCACHE is not set
+ # CONFIG_FRONTSWAP is not set
+ # CONFIG_CMA is not set
+ # CONFIG_ZBUD is not set
+ CONFIG_PPC_4K_PAGES=y
+ CONFIG_FORCE_MAX_ZONEORDER=11
+ # CONFIG_CMDLINE_BOOL is not set
+ CONFIG_EXTRA_TARGETS=""
+ # CONFIG_HIBERNATION is not set
+ # CONFIG_PM_RUNTIME is not set
  # CONFIG_SECCOMP is not set
+ # CONFIG_ISA_DMA_API is not set
+ 
+ #
+ # Bus options
+ #
+ CONFIG_ZONE_DMA=y
+ CONFIG_NEED_DMA_MAP_STATE=y
+ CONFIG_NEED_SG_DMA_LENGTH=y
+ # CONFIG_PCI_DOMAINS is not set
+ # CONFIG_PCI_SYSCALL is not set
+ # CONFIG_PCCARD is not set
+ # CONFIG_HAS_RAPIDIO is not set
+ # CONFIG_NONSTATIC_KERNEL is not set
+ 
+ #
+ # Advanced setup
+ #
  CONFIG_ADVANCED_OPTIONS=y
+ # CONFIG_LOWMEM_SIZE_BOOL is not set
+ CONFIG_LOWMEM_SIZE=0x30000000
+ # CONFIG_PAGE_OFFSET_BOOL is not set
+ CONFIG_PAGE_OFFSET=0xc0000000
+ # CONFIG_KERNEL_START_BOOL is not set
+ CONFIG_KERNEL_START=0xc0000000
+ CONFIG_PHYSICAL_START=0x00000000
+ # CONFIG_TASK_SIZE_BOOL is not set
+ CONFIG_TASK_SIZE=0xc0000000
+ # CONFIG_CONSISTENT_SIZE_BOOL is not set
+ CONFIG_CONSISTENT_SIZE=0x00200000
  CONFIG_NET=y
+ 
+ #
+ # Networking options
+ #
  CONFIG_PACKET=y
+ # CONFIG_PACKET_DIAG is not set
  CONFIG_UNIX=y
+ # CONFIG_UNIX_DIAG is not set
+ # CONFIG_XFRM_USER is not set
+ # CONFIG_NET_KEY is not set
  CONFIG_INET=y
+ # CONFIG_IP_MULTICAST is not set
+ # CONFIG_IP_ADVANCED_ROUTER is not set
  CONFIG_IP_PNP=y
  CONFIG_IP_PNP_DHCP=y
+ # CONFIG_IP_PNP_BOOTP is not set
  CONFIG_IP_PNP_RARP=y
+ # CONFIG_NET_IPIP is not set
+ # CONFIG_NET_IPGRE_DEMUX is not set
+ # CONFIG_NET_IP_TUNNEL is not set
+ # CONFIG_SYN_COOKIES is not set
+ # CONFIG_INET_AH is not set
+ # CONFIG_INET_ESP is not set
+ # CONFIG_INET_IPCOMP is not set
+ # CONFIG_INET_XFRM_TUNNEL is not set
+ # CONFIG_INET_TUNNEL is not set
  # CONFIG_INET_XFRM_MODE_TRANSPORT is not set
  # CONFIG_INET_XFRM_MODE_TUNNEL is not set
  # CONFIG_INET_XFRM_MODE_BEET is not set
  # CONFIG_INET_LRO is not set
  # CONFIG_INET_DIAG is not set
+ # CONFIG_TCP_CONG_ADVANCED is not set
+ CONFIG_TCP_CONG_CUBIC=y
+ CONFIG_DEFAULT_TCP_CONG="cubic"
+ # CONFIG_TCP_MD5SIG is not set
  # CONFIG_IPV6 is not set
+ # CONFIG_NETWORK_SECMARK is not set
+ # CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+ # CONFIG_NETFILTER is not set
+ # CONFIG_IP_DCCP is not set
+ # CONFIG_IP_SCTP is not set
+ # CONFIG_RDS is not set
+ # CONFIG_TIPC is not set
+ # CONFIG_ATM is not set
+ # CONFIG_L2TP is not set
+ # CONFIG_BRIDGE is not set
+ CONFIG_HAVE_NET_DSA=y
+ # CONFIG_VLAN_8021Q is not set
+ # CONFIG_DECNET is not set
+ # CONFIG_LLC2 is not set
+ # CONFIG_IPX is not set
+ # CONFIG_ATALK is not set
+ # CONFIG_X25 is not set
+ # CONFIG_LAPB is not set
+ # CONFIG_PHONET is not set
+ # CONFIG_IEEE802154 is not set
+ # CONFIG_NET_SCHED is not set
+ # CONFIG_DCB is not set
+ # CONFIG_BATMAN_ADV is not set
+ # CONFIG_OPENVSWITCH is not set
+ # CONFIG_VSOCKETS is not set
+ # CONFIG_NETLINK_MMAP is not set
+ # CONFIG_NETLINK_DIAG is not set
+ # CONFIG_NET_MPLS_GSO is not set
+ CONFIG_NET_RX_BUSY_POLL=y
+ CONFIG_BQL=y
+ 
+ #
+ # Network testing
+ #
+ # CONFIG_NET_PKTGEN is not set
+ # CONFIG_NET_DROP_MONITOR is not set
+ # CONFIG_HAMRADIO is not set
+ # CONFIG_CAN is not set
+ # CONFIG_IRDA is not set
+ # CONFIG_BT is not set
+ # CONFIG_AF_RXRPC is not set
  # CONFIG_WIRELESS is not set
+ # CONFIG_WIMAX is not set
+ # CONFIG_RFKILL is not set
+ # CONFIG_NET_9P is not set
+ # CONFIG_CAIF is not set
+ # CONFIG_CEPH_LIB is not set
+ # CONFIG_NFC is not set
+ 
+ #
+ # Device Drivers
+ #
+ 
+ #
+ # Generic Driver Options
+ #
  CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+ # CONFIG_DEVTMPFS is not set
  # CONFIG_STANDALONE is not set
+ CONFIG_PREVENT_FIRMWARE_BUILD=y
  # CONFIG_FW_LOADER is not set
+ # CONFIG_DEBUG_DRIVER is not set
+ # CONFIG_DEBUG_DEVRES is not set
+ # CONFIG_SYS_HYPERVISOR is not set
+ # CONFIG_GENERIC_CPU_DEVICES is not set
+ # CONFIG_DMA_SHARED_BUFFER is not set
+ 
+ #
+ # Bus devices
+ #
+ # CONFIG_CONNECTOR is not set
+ # CONFIG_MTD is not set
+ CONFIG_DTC=y
+ CONFIG_OF=y
+ 
+ #
+ # Device Tree and Open Firmware support
+ #
+ CONFIG_PROC_DEVICETREE=y
+ # CONFIG_OF_SELFTEST is not set
+ CONFIG_OF_FLATTREE=y
+ CONFIG_OF_EARLY_FLATTREE=y
+ CONFIG_OF_ADDRESS=y
+ CONFIG_OF_IRQ=y
+ CONFIG_OF_NET=y
+ # CONFIG_PARPORT is not set
+ CONFIG_BLK_DEV=y
+ # CONFIG_BLK_DEV_FD is not set
+ CONFIG_GAMECUBE_SD=y
+ CONFIG_GAMECUBE_ARAM=y
+ CONFIG_GAMECUBE_DI=y
+ # CONFIG_BLK_DEV_COW_COMMON is not set
  CONFIG_BLK_DEV_LOOP=y
+ CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+ # CONFIG_BLK_DEV_CRYPTOLOOP is not set
+ # CONFIG_BLK_DEV_DRBD is not set
  CONFIG_BLK_DEV_NBD=m
  CONFIG_BLK_DEV_RAM=y
  CONFIG_BLK_DEV_RAM_COUNT=2
+ CONFIG_BLK_DEV_RAM_SIZE=4096
+ # CONFIG_BLK_DEV_XIP is not set
+ # CONFIG_CDROM_PKTCDVD is not set
+ # CONFIG_ATA_OVER_ETH is not set
+ # CONFIG_BLK_DEV_HD is not set
+ # CONFIG_BLK_DEV_RBD is not set
+ 
+ #
+ # Misc devices
+ #
+ # CONFIG_SENSORS_LIS3LV02D is not set
+ # CONFIG_DUMMY_IRQ is not set
+ CONFIG_GAMECUBE_GQR=y
+ CONFIG_GAMECUBE_MI=y
+ # CONFIG_ATMEL_SSC is not set
+ # CONFIG_ENCLOSURE_SERVICES is not set
+ # CONFIG_SRAM is not set
+ # CONFIG_C2PORT is not set
+ 
+ #
+ # EEPROM support
+ #
+ # CONFIG_EEPROM_93CX6 is not set
+ 
+ #
+ # Texas Instruments shared transport line discipline
+ #
+ 
+ #
+ # Altera FPGA firmware download module
+ #
+ CONFIG_HAVE_IDE=y
+ # CONFIG_IDE is not set
+ 
+ #
+ # SCSI device support
+ #
+ CONFIG_SCSI_MOD=y
+ # CONFIG_RAID_ATTRS is not set
+ # CONFIG_SCSI is not set
+ # CONFIG_SCSI_DMA is not set
+ # CONFIG_SCSI_NETLINK is not set
+ # CONFIG_ATA is not set
+ # CONFIG_MD is not set
+ # CONFIG_MACINTOSH_DRIVERS is not set
  CONFIG_NETDEVICES=y
+ CONFIG_NET_CORE=y
+ # CONFIG_BONDING is not set
+ # CONFIG_DUMMY is not set
+ # CONFIG_EQUALIZER is not set
+ CONFIG_GAMECUBE_BBA=y
+ # CONFIG_NET_TEAM is not set
+ # CONFIG_MACVLAN is not set
+ # CONFIG_VXLAN is not set
+ # CONFIG_NETCONSOLE is not set
+ # CONFIG_NETPOLL is not set
+ # CONFIG_NET_POLL_CONTROLLER is not set
+ # CONFIG_TUN is not set
+ # CONFIG_VETH is not set
+ # CONFIG_NLMON is not set
+ 
+ #
+ # CAIF transport drivers
+ #
+ 
+ #
+ # Distributed Switch Architecture drivers
+ #
+ # CONFIG_NET_DSA_MV88E6XXX is not set
+ # CONFIG_NET_DSA_MV88E6060 is not set
+ # CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+ # CONFIG_NET_DSA_MV88E6131 is not set
+ # CONFIG_NET_DSA_MV88E6123_61_65 is not set
+ CONFIG_ETHERNET=y
+ CONFIG_NET_VENDOR_ARC=y
+ # CONFIG_ARC_EMAC is not set
+ CONFIG_NET_CADENCE=y
+ # CONFIG_ARM_AT91_ETHER is not set
+ # CONFIG_MACB is not set
+ CONFIG_NET_VENDOR_BROADCOM=y
+ # CONFIG_B44 is not set
+ # CONFIG_NET_CALXEDA_XGMAC is not set
+ # CONFIG_DNET is not set
+ CONFIG_NET_VENDOR_INTEL=y
+ CONFIG_NET_VENDOR_I825XX=y
+ CONFIG_NET_VENDOR_MARVELL=y
+ # CONFIG_MV643XX_ETH is not set
+ # CONFIG_MVMDIO is not set
+ CONFIG_NET_VENDOR_MICREL=y
+ # CONFIG_KS8851_MLL is not set
+ CONFIG_NET_VENDOR_NATSEMI=y
+ CONFIG_NET_VENDOR_8390=y
+ # CONFIG_ETHOC is not set
+ # CONFIG_SH_ETH is not set
+ CONFIG_NET_VENDOR_SEEQ=y
+ CONFIG_NET_VENDOR_STMICRO=y
+ # CONFIG_STMMAC_ETH is not set
+ CONFIG_NET_VENDOR_VIA=y
+ CONFIG_NET_VENDOR_WIZNET=y
+ # CONFIG_WIZNET_W5100 is not set
+ # CONFIG_WIZNET_W5300 is not set
+ CONFIG_NET_VENDOR_XILINX=y
+ # CONFIG_XILINX_EMACLITE is not set
+ # CONFIG_XILINX_LL_TEMAC is not set
+ # CONFIG_PHYLIB is not set
+ # CONFIG_PPP is not set
+ # CONFIG_SLIP is not set
  # CONFIG_WLAN is not set
+ 
+ #
+ # Enable WiMAX (Networking options) to see the WiMAX drivers
+ #
+ # CONFIG_WAN is not set
+ # CONFIG_ISDN is not set
+ 
+ #
+ # Input device support
+ #
+ CONFIG_INPUT=y
  CONFIG_INPUT_FF_MEMLESS=m
+ # CONFIG_INPUT_POLLDEV is not set
+ # CONFIG_INPUT_SPARSEKMAP is not set
+ # CONFIG_INPUT_MATRIXKMAP is not set
+ 
+ #
+ # Userland interfaces
+ #
  # CONFIG_INPUT_MOUSEDEV is not set
  CONFIG_INPUT_JOYDEV=y
  CONFIG_INPUT_EVDEV=y
+ # CONFIG_INPUT_EVBUG is not set
+ 
+ #
+ # Input Device Drivers
+ #
+ CONFIG_INPUT_KEYBOARD=y
  # CONFIG_KEYBOARD_ATKBD is not set
+ # CONFIG_KEYBOARD_LKKBD is not set
+ # CONFIG_KEYBOARD_NEWTON is not set
+ # CONFIG_KEYBOARD_OPENCORES is not set
+ # CONFIG_KEYBOARD_STOWAWAY is not set
+ # CONFIG_KEYBOARD_SUNKBD is not set
+ # CONFIG_KEYBOARD_XTKBD is not set
  # CONFIG_INPUT_MOUSE is not set
  CONFIG_INPUT_JOYSTICK=y
+ # CONFIG_JOYSTICK_ANALOG is not set
+ # CONFIG_JOYSTICK_A3D is not set
+ # CONFIG_JOYSTICK_ADI is not set
+ # CONFIG_JOYSTICK_COBRA is not set
+ # CONFIG_JOYSTICK_GF2K is not set
+ # CONFIG_JOYSTICK_GRIP is not set
+ # CONFIG_JOYSTICK_GRIP_MP is not set
+ # CONFIG_JOYSTICK_GUILLEMOT is not set
+ # CONFIG_JOYSTICK_INTERACT is not set
+ # CONFIG_JOYSTICK_SIDEWINDER is not set
+ # CONFIG_JOYSTICK_TMDC is not set
+ # CONFIG_JOYSTICK_IFORCE is not set
+ # CONFIG_JOYSTICK_WARRIOR is not set
+ # CONFIG_JOYSTICK_MAGELLAN is not set
+ # CONFIG_JOYSTICK_SPACEORB is not set
+ # CONFIG_JOYSTICK_SPACEBALL is not set
+ # CONFIG_JOYSTICK_STINGER is not set
+ # CONFIG_JOYSTICK_TWIDJOY is not set
+ # CONFIG_JOYSTICK_ZHENHUA is not set
+ # CONFIG_JOYSTICK_JOYDUMP is not set
+ # CONFIG_INPUT_TABLET is not set
+ # CONFIG_INPUT_TOUCHSCREEN is not set
+ # CONFIG_INPUT_MISC is not set
+ 
+ #
+ # Hardware I/O ports
+ #
+ CONFIG_SERIO=y
  # CONFIG_SERIO_I8042 is not set
  # CONFIG_SERIO_SERPORT is not set
+ # CONFIG_SERIO_LIBPS2 is not set
+ # CONFIG_SERIO_RAW is not set
+ # CONFIG_SERIO_XILINX_XPS_PS2 is not set
+ # CONFIG_SERIO_ALTERA_PS2 is not set
+ # CONFIG_SERIO_PS2MULT is not set
+ # CONFIG_SERIO_ARC_PS2 is not set
+ # CONFIG_SERIO_APBPS2 is not set
+ # CONFIG_SERIO_OLPC_APSP is not set
+ # CONFIG_GAMEPORT is not set
+ # CONFIG_GAMECUBE_SI is not set
+ 
+ #
+ # Character devices
+ #
+ CONFIG_TTY=y
+ CONFIG_VT=y
+ CONFIG_CONSOLE_TRANSLATIONS=y
+ CONFIG_VT_CONSOLE=y
+ CONFIG_HW_CONSOLE=y
+ CONFIG_VT_HW_CONSOLE_BINDING=y
+ CONFIG_UNIX98_PTYS=y
+ # CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
+ CONFIG_LEGACY_PTYS=y
  CONFIG_LEGACY_PTY_COUNT=64
+ # CONFIG_SERIAL_NONSTANDARD is not set
+ # CONFIG_N_GSM is not set
+ # CONFIG_TRACE_SINK is not set
+ # CONFIG_PPC_EPAPR_HV_BYTECHAN is not set
  # CONFIG_DEVKMEM is not set
+ 
+ #
+ # Serial drivers
+ #
+ # CONFIG_SERIAL_8250 is not set
+ 
+ #
+ # Non-8250 serial port support
+ #
+ # CONFIG_SERIAL_UARTLITE is not set
+ # CONFIG_SERIAL_SCCNXP is not set
+ # CONFIG_SERIAL_TIMBERDALE is not set
+ # CONFIG_SERIAL_ALTERA_JTAGUART is not set
+ # CONFIG_SERIAL_ALTERA_UART is not set
+ # CONFIG_SERIAL_XILINX_PS_UART is not set
+ # CONFIG_SERIAL_ARC is not set
+ # CONFIG_SERIAL_FSL_LPUART is not set
+ # CONFIG_SERIAL_ST_ASC is not set
+ # CONFIG_TTY_PRINTK is not set
+ # CONFIG_HVC_UDBG is not set
+ # CONFIG_IPMI_HANDLER is not set
  # CONFIG_HW_RANDOM is not set
+ # CONFIG_NVRAM is not set
+ # CONFIG_R3964 is not set
+ # CONFIG_RAW_DRIVER is not set
+ # CONFIG_TCG_TPM is not set
+ # CONFIG_I2C is not set
+ 
+ #
+ # EXI support
+ #
+ CONFIG_GAMECUBE_EXI=y
+ # CONFIG_SPI is not set
+ # CONFIG_HSI is not set
+ 
+ #
+ # PPS support
+ #
+ # CONFIG_PPS is not set
+ 
+ #
+ # PPS generators support
+ #
+ 
+ #
+ # PTP clock support
+ #
+ # CONFIG_PTP_1588_CLOCK is not set
+ 
+ #
+ # Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+ #
+ CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+ CONFIG_GPIO_DEVRES=y
+ # CONFIG_GPIOLIB is not set
+ # CONFIG_W1 is not set
+ # CONFIG_POWER_SUPPLY is not set
+ # CONFIG_POWER_AVS is not set
  # CONFIG_HWMON is not set
+ # CONFIG_THERMAL is not set
+ # CONFIG_WATCHDOG is not set
+ CONFIG_SSB_POSSIBLE=y
+ 
+ #
+ # Sonics Silicon Backplane
+ #
+ # CONFIG_SSB is not set
+ CONFIG_BCMA_POSSIBLE=y
+ 
+ #
+ # Broadcom specific AMBA
+ #
+ # CONFIG_BCMA is not set
+ 
+ #
+ # Multifunction device drivers
+ #
+ # CONFIG_MFD_CORE is not set
+ # CONFIG_MFD_CROS_EC is not set
+ # CONFIG_HTC_PASIC3 is not set
+ # CONFIG_MFD_KEMPLD is not set
+ # CONFIG_MFD_SM501 is not set
+ # CONFIG_ABX500_CORE is not set
+ # CONFIG_MFD_SYSCON is not set
+ # CONFIG_MFD_TI_AM335X_TSCADC is not set
+ # CONFIG_MFD_TMIO is not set
+ # CONFIG_REGULATOR is not set
+ # CONFIG_MEDIA_SUPPORT is not set
+ 
+ #
+ # Graphics support
+ #
+ # CONFIG_DRM is not set
+ # CONFIG_VGASTATE is not set
+ # CONFIG_VIDEO_OUTPUT_CONTROL is not set
  CONFIG_FB=y
+ # CONFIG_FIRMWARE_EDID is not set
+ # CONFIG_FB_DDC is not set
+ # CONFIG_FB_BOOT_VESA_SUPPORT is not set
+ CONFIG_FB_CFB_FILLRECT=y
+ CONFIG_FB_CFB_COPYAREA=y
+ CONFIG_FB_CFB_IMAGEBLIT=y
+ # CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+ # CONFIG_FB_SYS_FILLRECT is not set
+ # CONFIG_FB_SYS_COPYAREA is not set
+ # CONFIG_FB_SYS_IMAGEBLIT is not set
+ # CONFIG_FB_FOREIGN_ENDIAN is not set
+ # CONFIG_FB_SYS_FOPS is not set
+ # CONFIG_FB_SVGALIB is not set
+ # CONFIG_FB_MACMODES is not set
+ # CONFIG_FB_BACKLIGHT is not set
+ # CONFIG_FB_MODE_HELPERS is not set
+ # CONFIG_FB_TILEBLITTING is not set
+ 
+ #
+ # Frame buffer hardware drivers
+ #
+ # CONFIG_FB_OF is not set
+ # CONFIG_FB_VGA16 is not set
+ # CONFIG_FB_S1D13XXX is not set
+ CONFIG_FB_GAMECUBE=y
+ # CONFIG_FB_IBM_GXT4500 is not set
+ # CONFIG_FB_GOLDFISH is not set
+ # CONFIG_FB_VIRTUAL is not set
+ # CONFIG_FB_METRONOME is not set
+ # CONFIG_FB_MB862XX is not set
+ # CONFIG_FB_BROADSHEET is not set
+ # CONFIG_FB_AUO_K190X is not set
+ # CONFIG_FB_SIMPLE is not set
+ # CONFIG_EXYNOS_VIDEO is not set
+ # CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+ 
+ #
+ # Console display driver support
+ #
  # CONFIG_VGA_CONSOLE is not set
+ CONFIG_DUMMY_CONSOLE=y
  CONFIG_FRAMEBUFFER_CONSOLE=y
+ # CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+ # CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
  CONFIG_LOGO=y
  # CONFIG_LOGO_LINUX_MONO is not set
  # CONFIG_LOGO_LINUX_VGA16 is not set
  # CONFIG_LOGO_LINUX_CLUT224 is not set
+ CONFIG_LOGO_GAMECUBE_CLUT224=y
  CONFIG_SOUND=y
+ CONFIG_SOUND_OSS_CORE=y
+ CONFIG_SOUND_OSS_CORE_PRECLAIM=y
  CONFIG_SND=y
+ CONFIG_SND_TIMER=y
+ CONFIG_SND_PCM=y
  CONFIG_SND_SEQUENCER=y
+ # CONFIG_SND_SEQ_DUMMY is not set
+ CONFIG_SND_OSSEMUL=y
  CONFIG_SND_MIXER_OSS=y
  CONFIG_SND_PCM_OSS=y
+ CONFIG_SND_PCM_OSS_PLUGINS=y
  CONFIG_SND_SEQUENCER_OSS=y
+ # CONFIG_SND_DYNAMIC_MINORS is not set
+ CONFIG_SND_SUPPORT_OLD_API=y
  # CONFIG_SND_VERBOSE_PROCFS is not set
+ # CONFIG_SND_VERBOSE_PRINTK is not set
+ # CONFIG_SND_DEBUG is not set
+ # CONFIG_SND_RAWMIDI_SEQ is not set
+ # CONFIG_SND_OPL3_LIB_SEQ is not set
+ # CONFIG_SND_OPL4_LIB_SEQ is not set
+ # CONFIG_SND_SBAWE_SEQ is not set
+ # CONFIG_SND_EMU10K1_SEQ is not set
+ CONFIG_SND_DRIVERS=y
+ # CONFIG_SND_DUMMY is not set
+ # CONFIG_SND_ALOOP is not set
+ # CONFIG_SND_VIRMIDI is not set
+ # CONFIG_SND_MTPAV is not set
+ # CONFIG_SND_SERIAL_U16550 is not set
+ # CONFIG_SND_MPU401 is not set
+ CONFIG_SND_PPC=y
+ CONFIG_SND_GAMECUBE=y
+ CONFIG_SND_GAMECUBE_MIC=y
+ # CONFIG_SND_SOC is not set
+ # CONFIG_SOUND_PRIME is not set
+ 
+ #
+ # HID support
+ #
+ CONFIG_HID=y
+ # CONFIG_HIDRAW is not set
+ # CONFIG_UHID is not set
+ CONFIG_HID_GENERIC=y
+ 
+ #
+ # Special HID drivers
+ #
+ # CONFIG_HID_A4TECH is not set
+ # CONFIG_HID_ACRUX is not set
+ # CONFIG_HID_APPLE is not set
+ # CONFIG_HID_AUREAL is not set
+ # CONFIG_HID_BELKIN is not set
+ # CONFIG_HID_CHERRY is not set
+ # CONFIG_HID_CHICONY is not set
+ # CONFIG_HID_PRODIKEYS is not set
+ # CONFIG_HID_CYPRESS is not set
+ # CONFIG_HID_DRAGONRISE is not set
+ # CONFIG_HID_EMS_FF is not set
+ # CONFIG_HID_ELECOM is not set
+ # CONFIG_HID_EZKEY is not set
+ # CONFIG_HID_KEYTOUCH is not set
+ # CONFIG_HID_KYE is not set
+ # CONFIG_HID_UCLOGIC is not set
+ # CONFIG_HID_WALTOP is not set
+ # CONFIG_HID_GYRATION is not set
+ # CONFIG_HID_ICADE is not set
+ # CONFIG_HID_TWINHAN is not set
+ # CONFIG_HID_KENSINGTON is not set
+ # CONFIG_HID_LCPOWER is not set
+ # CONFIG_HID_LOGITECH is not set
+ # CONFIG_HID_MAGICMOUSE is not set
+ # CONFIG_HID_MICROSOFT is not set
+ # CONFIG_HID_MONTEREY is not set
+ # CONFIG_HID_MULTITOUCH is not set
+ # CONFIG_HID_ORTEK is not set
+ # CONFIG_HID_PANTHERLORD is not set
+ # CONFIG_HID_PETALYNX is not set
+ # CONFIG_HID_PICOLCD is not set
+ # CONFIG_HID_PRIMAX is not set
+ # CONFIG_HID_SAITEK is not set
+ # CONFIG_HID_SAMSUNG is not set
+ # CONFIG_HID_SPEEDLINK is not set
+ # CONFIG_HID_STEELSERIES is not set
+ # CONFIG_HID_SUNPLUS is not set
+ # CONFIG_HID_GREENASIA is not set
+ # CONFIG_HID_SMARTJOYPLUS is not set
+ # CONFIG_HID_TIVO is not set
+ # CONFIG_HID_TOPSEED is not set
+ # CONFIG_HID_THRUSTMASTER is not set
+ # CONFIG_HID_XINMO is not set
+ # CONFIG_HID_ZEROPLUS is not set
+ # CONFIG_HID_ZYDACRON is not set
+ # CONFIG_HID_SENSOR_HUB is not set
+ CONFIG_USB_OHCI_LITTLE_ENDIAN=y
  # CONFIG_USB_SUPPORT is not set
+ CONFIG_MMC=y
+ # CONFIG_MMC_DEBUG is not set
+ # CONFIG_MMC_UNSAFE_RESUME is not set
+ # CONFIG_MMC_CLKGATE is not set
+ 
+ #
+ # MMC/SD/SDIO Card Drivers
+ #
+ CONFIG_MMC_BLOCK=y
+ CONFIG_MMC_BLOCK_MINORS=8
+ CONFIG_MMC_BLOCK_BOUNCE=y
+ # CONFIG_SDIO_UART is not set
+ # CONFIG_MMC_TEST is not set
+ 
+ #
+ # MMC/SD/SDIO Host Controller Drivers
+ #
+ # CONFIG_MMC_SDHCI is not set
+ # CONFIG_MEMSTICK is not set
+ # CONFIG_NEW_LEDS is not set
+ # CONFIG_ACCESSIBILITY is not set
+ # CONFIG_EDAC is not set
+ CONFIG_RTC_LIB=y
  CONFIG_RTC_CLASS=y
+ CONFIG_RTC_HCTOSYS=y
+ CONFIG_RTC_SYSTOHC=y
+ CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+ # CONFIG_RTC_DEBUG is not set
+ 
+ #
+ # RTC interfaces
+ #
+ CONFIG_RTC_INTF_SYSFS=y
+ CONFIG_RTC_INTF_PROC=y
+ CONFIG_RTC_INTF_DEV=y
+ # CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+ # CONFIG_RTC_DRV_TEST is not set
+ 
+ #
+ # SPI RTC drivers
+ #
+ 
+ #
+ # Platform RTC drivers
+ #
+ # CONFIG_RTC_DRV_CMOS is not set
+ # CONFIG_RTC_DRV_DS1286 is not set
+ # CONFIG_RTC_DRV_DS1511 is not set
+ # CONFIG_RTC_DRV_DS1553 is not set
+ # CONFIG_RTC_DRV_DS1742 is not set
+ # CONFIG_RTC_DRV_STK17TA8 is not set
+ # CONFIG_RTC_DRV_M48T86 is not set
+ # CONFIG_RTC_DRV_M48T35 is not set
+ # CONFIG_RTC_DRV_M48T59 is not set
+ # CONFIG_RTC_DRV_MSM6242 is not set
+ # CONFIG_RTC_DRV_BQ4802 is not set
+ # CONFIG_RTC_DRV_RP5C01 is not set
+ # CONFIG_RTC_DRV_V3020 is not set
+ # CONFIG_RTC_DRV_DS2404 is not set
+ CONFIG_RTC_DRV_GCN=y
+ 
+ #
+ # on-CPU RTC drivers
+ #
  CONFIG_RTC_DRV_GENERIC=y
+ # CONFIG_RTC_DRV_SNVS is not set
+ # CONFIG_RTC_DRV_MOXART is not set
+ 
+ #
+ # HID Sensor RTC drivers
+ #
+ # CONFIG_DMADEVICES is not set
+ # CONFIG_AUXDISPLAY is not set
+ # CONFIG_UIO is not set
+ # CONFIG_VIRT_DRIVERS is not set
+ 
+ #
+ # Virtio drivers
+ #
+ # CONFIG_VIRTIO_MMIO is not set
+ 
+ #
+ # Microsoft Hyper-V guest support
+ #
+ # CONFIG_STAGING is not set
+ 
+ #
+ # Hardware Spinlock drivers
+ #
+ # CONFIG_MAILBOX is not set
+ CONFIG_IOMMU_SUPPORT=y
+ CONFIG_OF_IOMMU=y
+ 
+ #
+ # Remoteproc drivers
+ #
+ # CONFIG_STE_MODEM_RPROC is not set
+ 
+ #
+ # Rpmsg drivers
+ #
+ # CONFIG_PM_DEVFREQ is not set
+ # CONFIG_EXTCON is not set
+ # CONFIG_MEMORY is not set
+ # CONFIG_IIO is not set
+ # CONFIG_PWM is not set
+ CONFIG_IRQCHIP=y
+ # CONFIG_IPACK_BUS is not set
+ # CONFIG_RESET_CONTROLLER is not set
+ # CONFIG_FMC is not set
+ 
+ #
+ # File systems
+ #
  CONFIG_EXT2_FS=y
+ # CONFIG_EXT2_FS_XATTR is not set
+ # CONFIG_EXT2_FS_XIP is not set
  CONFIG_EXT3_FS=y
  # CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
  # CONFIG_EXT3_FS_XATTR is not set
+ CONFIG_EXT4_FS=y
+ CONFIG_EXT4_FS_POSIX_ACL=y
+ CONFIG_EXT4_FS_SECURITY=y
+ # CONFIG_EXT4_DEBUG is not set
+ CONFIG_JBD=y
+ # CONFIG_JBD_DEBUG is not set
+ CONFIG_JBD2=y
+ # CONFIG_JBD2_DEBUG is not set
+ CONFIG_FS_MBCACHE=y
+ # CONFIG_REISERFS_FS is not set
+ # CONFIG_JFS_FS is not set
+ # CONFIG_XFS_FS is not set
+ # CONFIG_GFS2_FS is not set
+ # CONFIG_BTRFS_FS is not set
+ # CONFIG_NILFS2_FS is not set
+ CONFIG_FS_POSIX_ACL=y
+ CONFIG_FILE_LOCKING=y
+ CONFIG_FSNOTIFY=y
+ CONFIG_DNOTIFY=y
+ CONFIG_INOTIFY_USER=y
+ # CONFIG_FANOTIFY is not set
+ # CONFIG_QUOTA is not set
+ # CONFIG_QUOTACTL is not set
+ # CONFIG_AUTOFS4_FS is not set
+ # CONFIG_FUSE_FS is not set
+ 
+ #
+ # Caches
+ #
+ # CONFIG_FSCACHE is not set
+ 
+ #
+ # CD-ROM/DVD Filesystems
+ #
  CONFIG_ISO9660_FS=y
  CONFIG_JOLIET=y
+ # CONFIG_ZISOFS is not set
+ # CONFIG_UDF_FS is not set
+ 
+ #
+ # DOS/FAT/NT Filesystems
+ #
+ CONFIG_FAT_FS=y
  CONFIG_MSDOS_FS=y
  CONFIG_VFAT_FS=y
+ CONFIG_FAT_DEFAULT_CODEPAGE=437
+ CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+ # CONFIG_NTFS_FS is not set
+ 
+ #
+ # Pseudo filesystems
+ #
+ CONFIG_PROC_FS=y
  CONFIG_PROC_KCORE=y
+ CONFIG_PROC_SYSCTL=y
  # CONFIG_PROC_PAGE_MONITOR is not set
+ CONFIG_SYSFS=y
  CONFIG_TMPFS=y
+ # CONFIG_TMPFS_POSIX_ACL is not set
+ # CONFIG_TMPFS_XATTR is not set
+ # CONFIG_HUGETLB_PAGE is not set
+ # CONFIG_CONFIGFS_FS is not set
+ CONFIG_MISC_FILESYSTEMS=y
+ # CONFIG_ADFS_FS is not set
+ # CONFIG_AFFS_FS is not set
+ # CONFIG_HFS_FS is not set
+ # CONFIG_HFSPLUS_FS is not set
+ # CONFIG_BEFS_FS is not set
+ # CONFIG_BFS_FS is not set
+ # CONFIG_EFS_FS is not set
+ # CONFIG_LOGFS is not set
+ # CONFIG_CRAMFS is not set
+ # CONFIG_SQUASHFS is not set
+ # CONFIG_VXFS_FS is not set
+ # CONFIG_MINIX_FS is not set
+ # CONFIG_OMFS_FS is not set
+ # CONFIG_HPFS_FS is not set
+ # CONFIG_QNX4FS_FS is not set
+ # CONFIG_QNX6FS_FS is not set
+ # CONFIG_ROMFS_FS is not set
+ # CONFIG_PSTORE is not set
+ # CONFIG_SYSV_FS is not set
+ # CONFIG_UFS_FS is not set
+ # CONFIG_F2FS_FS is not set
+ CONFIG_NETWORK_FILESYSTEMS=y
  CONFIG_NFS_FS=y
+ CONFIG_NFS_V2=y
+ CONFIG_NFS_V3=y
+ # CONFIG_NFS_V3_ACL is not set
+ # CONFIG_NFS_V4 is not set
+ # CONFIG_NFS_SWAP is not set
  CONFIG_ROOT_NFS=y
+ # CONFIG_NFSD is not set
+ CONFIG_LOCKD=y
+ CONFIG_LOCKD_V4=y
+ CONFIG_NFS_COMMON=y
+ CONFIG_SUNRPC=y
+ # CONFIG_SUNRPC_DEBUG is not set
+ # CONFIG_CEPH_FS is not set
  CONFIG_CIFS=y
+ # CONFIG_CIFS_STATS is not set
+ # CONFIG_CIFS_WEAK_PW_HASH is not set
+ # CONFIG_CIFS_XATTR is not set
+ CONFIG_CIFS_DEBUG=y
+ # CONFIG_CIFS_DEBUG2 is not set
+ # CONFIG_CIFS_SMB2 is not set
+ # CONFIG_NCP_FS is not set
+ # CONFIG_CODA_FS is not set
+ # CONFIG_AFS_FS is not set
+ CONFIG_NLS=y
+ CONFIG_NLS_DEFAULT="iso8859-1"
  CONFIG_NLS_CODEPAGE_437=y
+ # CONFIG_NLS_CODEPAGE_737 is not set
+ # CONFIG_NLS_CODEPAGE_775 is not set
+ # CONFIG_NLS_CODEPAGE_850 is not set
+ # CONFIG_NLS_CODEPAGE_852 is not set
+ # CONFIG_NLS_CODEPAGE_855 is not set
+ # CONFIG_NLS_CODEPAGE_857 is not set
+ # CONFIG_NLS_CODEPAGE_860 is not set
+ # CONFIG_NLS_CODEPAGE_861 is not set
+ # CONFIG_NLS_CODEPAGE_862 is not set
+ # CONFIG_NLS_CODEPAGE_863 is not set
+ # CONFIG_NLS_CODEPAGE_864 is not set
+ # CONFIG_NLS_CODEPAGE_865 is not set
+ # CONFIG_NLS_CODEPAGE_866 is not set
+ # CONFIG_NLS_CODEPAGE_869 is not set
+ # CONFIG_NLS_CODEPAGE_936 is not set
+ # CONFIG_NLS_CODEPAGE_950 is not set
+ # CONFIG_NLS_CODEPAGE_932 is not set
+ # CONFIG_NLS_CODEPAGE_949 is not set
+ # CONFIG_NLS_CODEPAGE_874 is not set
+ # CONFIG_NLS_ISO8859_8 is not set
+ # CONFIG_NLS_CODEPAGE_1250 is not set
+ # CONFIG_NLS_CODEPAGE_1251 is not set
+ # CONFIG_NLS_ASCII is not set
  CONFIG_NLS_ISO8859_1=y
+ # CONFIG_NLS_ISO8859_2 is not set
+ # CONFIG_NLS_ISO8859_3 is not set
+ # CONFIG_NLS_ISO8859_4 is not set
+ # CONFIG_NLS_ISO8859_5 is not set
+ # CONFIG_NLS_ISO8859_6 is not set
+ # CONFIG_NLS_ISO8859_7 is not set
+ # CONFIG_NLS_ISO8859_9 is not set
+ # CONFIG_NLS_ISO8859_13 is not set
+ # CONFIG_NLS_ISO8859_14 is not set
+ # CONFIG_NLS_ISO8859_15 is not set
+ # CONFIG_NLS_KOI8_R is not set
+ # CONFIG_NLS_KOI8_U is not set
+ # CONFIG_NLS_MAC_ROMAN is not set
+ # CONFIG_NLS_MAC_CELTIC is not set
+ # CONFIG_NLS_MAC_CENTEURO is not set
+ # CONFIG_NLS_MAC_CROATIAN is not set
+ # CONFIG_NLS_MAC_CYRILLIC is not set
+ # CONFIG_NLS_MAC_GAELIC is not set
+ # CONFIG_NLS_MAC_GREEK is not set
+ # CONFIG_NLS_MAC_ICELAND is not set
+ # CONFIG_NLS_MAC_INUIT is not set
+ # CONFIG_NLS_MAC_ROMANIAN is not set
+ # CONFIG_NLS_MAC_TURKISH is not set
+ # CONFIG_NLS_UTF8 is not set
+ CONFIG_BINARY_PRINTF=y
+ 
+ #
+ # Library routines
+ #
+ CONFIG_BITREVERSE=y
+ CONFIG_GENERIC_STRNCPY_FROM_USER=y
+ CONFIG_GENERIC_STRNLEN_USER=y
+ CONFIG_GENERIC_NET_UTILS=y
+ CONFIG_GENERIC_IO=y
  CONFIG_CRC_CCITT=y
+ CONFIG_CRC16=y
+ # CONFIG_CRC_T10DIF is not set
+ # CONFIG_CRC_ITU_T is not set
+ CONFIG_CRC32=y
+ # CONFIG_CRC32_SELFTEST is not set
+ CONFIG_CRC32_SLICEBY8=y
+ # CONFIG_CRC32_SLICEBY4 is not set
+ # CONFIG_CRC32_SARWATE is not set
+ # CONFIG_CRC32_BIT is not set
+ # CONFIG_CRC7 is not set
+ # CONFIG_LIBCRC32C is not set
+ # CONFIG_CRC8 is not set
+ CONFIG_ZLIB_INFLATE=y
+ # CONFIG_XZ_DEC is not set
+ # CONFIG_XZ_DEC_BCJ is not set
+ CONFIG_DECOMPRESS_GZIP=y
+ CONFIG_HAS_IOMEM=y
+ CONFIG_HAS_IOPORT=y
+ CONFIG_HAS_DMA=y
+ CONFIG_DQL=y
+ CONFIG_NLATTR=y
+ CONFIG_GENERIC_ATOMIC64=y
+ CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+ # CONFIG_AVERAGE is not set
+ # CONFIG_CORDIC is not set
+ # CONFIG_DDR is not set
+ CONFIG_FONT_SUPPORT=y
+ # CONFIG_FONTS is not set
+ CONFIG_FONT_8x8=y
+ CONFIG_FONT_8x16=y
+ 
+ #
+ # Kernel hacking
+ #
+ 
+ #
+ # printk and dmesg options
+ #
  CONFIG_PRINTK_TIME=y
+ CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+ # CONFIG_DYNAMIC_DEBUG is not set
+ 
+ #
+ # Compile-time checks and compiler options
+ #
+ # CONFIG_DEBUG_INFO is not set
+ CONFIG_ENABLE_WARN_DEPRECATED=y
+ CONFIG_ENABLE_MUST_CHECK=y
+ CONFIG_FRAME_WARN=1024
+ # CONFIG_STRIP_ASM_SYMS is not set
+ # CONFIG_READABLE_ASM is not set
+ # CONFIG_UNUSED_SYMBOLS is not set
+ CONFIG_DEBUG_FS=y
+ # CONFIG_HEADERS_CHECK is not set
+ # CONFIG_DEBUG_SECTION_MISMATCH is not set
+ # CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
+ # CONFIG_MAGIC_SYSRQ is not set
+ CONFIG_DEBUG_KERNEL=y
+ 
+ #
+ # Memory Debugging
+ #
+ # CONFIG_DEBUG_PAGEALLOC is not set
+ # CONFIG_DEBUG_OBJECTS is not set
+ # CONFIG_DEBUG_SLAB is not set
+ CONFIG_HAVE_DEBUG_KMEMLEAK=y
+ # CONFIG_DEBUG_KMEMLEAK is not set
+ # CONFIG_DEBUG_STACK_USAGE is not set
+ # CONFIG_DEBUG_VM is not set
+ # CONFIG_DEBUG_MEMORY_INIT is not set
+ CONFIG_HAVE_DEBUG_STACKOVERFLOW=y
+ # CONFIG_DEBUG_STACKOVERFLOW is not set
+ # CONFIG_DEBUG_SHIRQ is not set
+ 
+ #
+ # Debug Lockups and Hangs
+ #
+ # CONFIG_LOCKUP_DETECTOR is not set
+ # CONFIG_DETECT_HUNG_TASK is not set
+ # CONFIG_PANIC_ON_OOPS is not set
+ CONFIG_PANIC_ON_OOPS_VALUE=0
+ CONFIG_SCHED_DEBUG=y
+ CONFIG_SCHEDSTATS=y
+ # CONFIG_TIMER_STATS is not set
+ CONFIG_DEBUG_PREEMPT=y
+ 
+ #
+ # Lock Debugging (spinlocks, mutexes, etc...)
+ #
+ # CONFIG_DEBUG_RT_MUTEXES is not set
+ # CONFIG_RT_MUTEX_TESTER is not set
  CONFIG_DEBUG_SPINLOCK=y
  CONFIG_DEBUG_MUTEXES=y
+ # CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+ # CONFIG_DEBUG_LOCK_ALLOC is not set
+ # CONFIG_PROVE_LOCKING is not set
+ # CONFIG_LOCK_STAT is not set
+ # CONFIG_DEBUG_ATOMIC_SLEEP is not set
+ # CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+ CONFIG_STACKTRACE=y
+ # CONFIG_DEBUG_KOBJECT is not set
+ CONFIG_DEBUG_BUGVERBOSE=y
+ # CONFIG_DEBUG_WRITECOUNT is not set
+ # CONFIG_DEBUG_LIST is not set
+ # CONFIG_DEBUG_SG is not set
+ # CONFIG_DEBUG_NOTIFIERS is not set
+ # CONFIG_DEBUG_CREDENTIALS is not set
+ 
+ #
+ # RCU Debugging
+ #
+ # CONFIG_PROVE_RCU_DELAY is not set
+ # CONFIG_SPARSE_RCU_POINTER is not set
+ # CONFIG_RCU_TORTURE_TEST is not set
+ CONFIG_RCU_CPU_STALL_TIMEOUT=21
+ CONFIG_RCU_CPU_STALL_VERBOSE=y
+ # CONFIG_RCU_CPU_STALL_INFO is not set
+ # CONFIG_RCU_TRACE is not set
+ # CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+ # CONFIG_NOTIFIER_ERROR_INJECTION is not set
+ # CONFIG_FAULT_INJECTION is not set
  CONFIG_LATENCYTOP=y
+ CONFIG_NOP_TRACER=y
+ CONFIG_HAVE_FUNCTION_TRACER=y
+ CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+ CONFIG_HAVE_DYNAMIC_FTRACE=y
+ CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+ CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+ CONFIG_TRACER_MAX_TRACE=y
+ CONFIG_TRACE_CLOCK=y
+ CONFIG_RING_BUFFER=y
+ CONFIG_EVENT_TRACING=y
+ CONFIG_CONTEXT_SWITCH_TRACER=y
+ CONFIG_TRACING=y
+ CONFIG_GENERIC_TRACER=y
+ CONFIG_TRACING_SUPPORT=y
+ CONFIG_FTRACE=y
+ # CONFIG_FUNCTION_TRACER is not set
+ # CONFIG_IRQSOFF_TRACER is not set
+ # CONFIG_PREEMPT_TRACER is not set
  CONFIG_SCHED_TRACER=y
+ # CONFIG_FTRACE_SYSCALLS is not set
+ CONFIG_TRACER_SNAPSHOT=y
+ # CONFIG_TRACER_SNAPSHOT_PER_CPU_SWAP is not set
+ CONFIG_BRANCH_PROFILE_NONE=y
+ # CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+ # CONFIG_PROFILE_ALL_BRANCHES is not set
+ # CONFIG_STACK_TRACER is not set
+ # CONFIG_BLK_DEV_IO_TRACE is not set
+ # CONFIG_UPROBE_EVENT is not set
+ # CONFIG_PROBE_EVENTS is not set
+ # CONFIG_FTRACE_STARTUP_TEST is not set
+ # CONFIG_RING_BUFFER_BENCHMARK is not set
+ # CONFIG_RING_BUFFER_STARTUP_TEST is not set
+ 
+ #
+ # Runtime Testing
+ #
+ # CONFIG_LKDTM is not set
+ # CONFIG_TEST_LIST_SORT is not set
+ # CONFIG_BACKTRACE_SELF_TEST is not set
+ # CONFIG_RBTREE_TEST is not set
+ # CONFIG_INTERVAL_TREE_TEST is not set
+ # CONFIG_ATOMIC64_SELFTEST is not set
+ # CONFIG_TEST_STRING_HELPERS is not set
+ # CONFIG_TEST_KSTRTOX is not set
  CONFIG_DMA_API_DEBUG=y
+ # CONFIG_SAMPLES is not set
+ CONFIG_HAVE_ARCH_KGDB=y
+ # CONFIG_KGDB is not set
+ # CONFIG_PPC_DISABLE_WERROR is not set
+ CONFIG_PPC_WERROR=y
+ CONFIG_PRINT_STACK_DEPTH=64
+ # CONFIG_PPC_EMULATED_STATS is not set
+ # CONFIG_CODE_PATCHING_SELFTEST is not set
+ # CONFIG_FTR_FIXUP_SELFTEST is not set
+ # CONFIG_MSI_BITMAP_SELFTEST is not set
+ # CONFIG_XMON is not set
+ # CONFIG_BDI_SWITCH is not set
+ # CONFIG_BOOTX_TEXT is not set
  CONFIG_PPC_EARLY_DEBUG=y
+ CONFIG_PPC_EARLY_DEBUG_MEMCONS=y
+ CONFIG_PPC_MEMCONS_OUTPUT_SIZE=4096
+ CONFIG_PPC_MEMCONS_INPUT_SIZE=128
+ CONFIG_STRICT_DEVMEM=y
+ 
+ #
+ # Security options
+ #
+ # CONFIG_KEYS is not set
+ # CONFIG_SECURITY_DMESG_RESTRICT is not set
+ # CONFIG_SECURITY is not set
+ # CONFIG_SECURITYFS is not set
+ CONFIG_DEFAULT_SECURITY_DAC=y
+ CONFIG_DEFAULT_SECURITY=""
+ CONFIG_CRYPTO=y
+ 
+ #
+ # Crypto core or helper
+ #
+ CONFIG_CRYPTO_ALGAPI=y
+ CONFIG_CRYPTO_ALGAPI2=y
+ CONFIG_CRYPTO_AEAD2=y
+ CONFIG_CRYPTO_BLKCIPHER=y
+ CONFIG_CRYPTO_BLKCIPHER2=y
+ CONFIG_CRYPTO_HASH=y
+ CONFIG_CRYPTO_HASH2=y
+ CONFIG_CRYPTO_RNG=m
+ CONFIG_CRYPTO_RNG2=y
+ CONFIG_CRYPTO_PCOMP2=y
+ CONFIG_CRYPTO_MANAGER=y
+ CONFIG_CRYPTO_MANAGER2=y
+ # CONFIG_CRYPTO_USER is not set
+ CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+ # CONFIG_CRYPTO_GF128MUL is not set
+ # CONFIG_CRYPTO_NULL is not set
+ CONFIG_CRYPTO_WORKQUEUE=y
+ # CONFIG_CRYPTO_CRYPTD is not set
+ # CONFIG_CRYPTO_AUTHENC is not set
+ # CONFIG_CRYPTO_TEST is not set
+ 
+ #
+ # Authenticated Encryption with Associated Data
+ #
+ # CONFIG_CRYPTO_CCM is not set
+ # CONFIG_CRYPTO_GCM is not set
+ # CONFIG_CRYPTO_SEQIV is not set
+ 
+ #
+ # Block modes
+ #
+ # CONFIG_CRYPTO_CBC is not set
+ # CONFIG_CRYPTO_CTR is not set
+ # CONFIG_CRYPTO_CTS is not set
+ CONFIG_CRYPTO_ECB=y
+ # CONFIG_CRYPTO_LRW is not set
+ # CONFIG_CRYPTO_PCBC is not set
+ # CONFIG_CRYPTO_XTS is not set
+ 
+ #
+ # Hash modes
+ #
+ CONFIG_CRYPTO_CMAC=y
+ CONFIG_CRYPTO_HMAC=y
+ # CONFIG_CRYPTO_XCBC is not set
+ # CONFIG_CRYPTO_VMAC is not set
+ 
+ #
+ # Digest
+ #
+ CONFIG_CRYPTO_CRC32C=y
+ # CONFIG_CRYPTO_CRC32 is not set
+ # CONFIG_CRYPTO_CRCT10DIF is not set
+ # CONFIG_CRYPTO_GHASH is not set
+ CONFIG_CRYPTO_MD4=y
+ CONFIG_CRYPTO_MD5=y
+ # CONFIG_CRYPTO_MICHAEL_MIC is not set
+ # CONFIG_CRYPTO_RMD128 is not set
+ # CONFIG_CRYPTO_RMD160 is not set
+ # CONFIG_CRYPTO_RMD256 is not set
+ # CONFIG_CRYPTO_RMD320 is not set
+ # CONFIG_CRYPTO_SHA1 is not set
+ # CONFIG_CRYPTO_SHA1_PPC is not set
+ CONFIG_CRYPTO_SHA256=y
+ # CONFIG_CRYPTO_SHA512 is not set
+ # CONFIG_CRYPTO_TGR192 is not set
+ # CONFIG_CRYPTO_WP512 is not set
+ 
+ #
+ # Ciphers
+ #
+ CONFIG_CRYPTO_AES=y
+ # CONFIG_CRYPTO_ANUBIS is not set
+ CONFIG_CRYPTO_ARC4=y
+ # CONFIG_CRYPTO_BLOWFISH is not set
+ # CONFIG_CRYPTO_CAMELLIA is not set
+ # CONFIG_CRYPTO_CAST5 is not set
+ # CONFIG_CRYPTO_CAST6 is not set
+ CONFIG_CRYPTO_DES=y
+ # CONFIG_CRYPTO_FCRYPT is not set
+ # CONFIG_CRYPTO_KHAZAD is not set
+ # CONFIG_CRYPTO_SALSA20 is not set
+ # CONFIG_CRYPTO_SEED is not set
+ # CONFIG_CRYPTO_SERPENT is not set
+ # CONFIG_CRYPTO_TEA is not set
+ # CONFIG_CRYPTO_TWOFISH is not set
+ 
+ #
+ # Compression
+ #
+ # CONFIG_CRYPTO_DEFLATE is not set
+ # CONFIG_CRYPTO_ZLIB is not set
+ # CONFIG_CRYPTO_LZO is not set
+ # CONFIG_CRYPTO_LZ4 is not set
+ # CONFIG_CRYPTO_LZ4HC is not set
+ 
+ #
+ # Random Number Generation
+ #
+ CONFIG_CRYPTO_ANSI_CPRNG=m
+ # CONFIG_CRYPTO_USER_API_HASH is not set
+ # CONFIG_CRYPTO_USER_API_SKCIPHER is not set
+ CONFIG_CRYPTO_HW=y
+ # CONFIG_PPC_CLOCK is not set
+ # CONFIG_VIRTUALIZATION is not set
diff -crB /home/rxtx/Desktop/linux-4.3.3/arch/powerpc/configs/wii_defconfig ./arch/powerpc/configs/wii_defconfig
*** /home/rxtx/Desktop/linux-4.3.3/arch/powerpc/configs/wii_defconfig	2015-12-15 16:41:43.000000000 +1100
--- ./arch/powerpc/configs/wii_defconfig	2015-12-19 19:19:49.537003873 +1100
***************
*** 1,126 ****
  CONFIG_LOCALVERSION="-wii"
  # CONFIG_LOCALVERSION_AUTO is not set
  CONFIG_SYSVIPC=y
  CONFIG_IKCONFIG=y
  CONFIG_IKCONFIG_PROC=y
  CONFIG_LOG_BUF_SHIFT=14
  CONFIG_BLK_DEV_INITRD=y
  CONFIG_EXPERT=y
  # CONFIG_ELF_CORE is not set
  CONFIG_PERF_EVENTS=y
  # CONFIG_VM_EVENT_COUNTERS is not set
  CONFIG_SLAB=y
  CONFIG_MODULES=y
  CONFIG_MODULE_UNLOAD=y
  # CONFIG_PPC_CHRP is not set
  # CONFIG_PPC_PMAC is not set
  CONFIG_EMBEDDED6xx=y
  CONFIG_WII=y
  # CONFIG_PPC_OF_BOOT_TRAMPOLINE is not set
  CONFIG_PREEMPT=y
  CONFIG_BINFMT_MISC=m
  CONFIG_KEXEC=y
  # CONFIG_SECCOMP is not set
  CONFIG_ADVANCED_OPTIONS=y
  CONFIG_NET=y
  CONFIG_PACKET=y
  CONFIG_UNIX=y
  CONFIG_INET=y
  CONFIG_IP_PNP=y
  CONFIG_IP_PNP_DHCP=y
  CONFIG_IP_PNP_RARP=y
  # CONFIG_INET_XFRM_MODE_TRANSPORT is not set
  # CONFIG_INET_XFRM_MODE_TUNNEL is not set
  # CONFIG_INET_XFRM_MODE_BEET is not set
  # CONFIG_INET_LRO is not set
  # CONFIG_INET_DIAG is not set
  # CONFIG_IPV6 is not set
  CONFIG_BT=y
  CONFIG_BT_RFCOMM=y
  CONFIG_BT_BNEP=y
  CONFIG_BT_BNEP_MC_FILTER=y
  CONFIG_BT_HIDP=y
  CONFIG_CFG80211=y
  CONFIG_MAC80211=y
  CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
  # CONFIG_STANDALONE is not set
  # CONFIG_FIRMWARE_IN_KERNEL is not set
  CONFIG_BLK_DEV_LOOP=y
  CONFIG_BLK_DEV_RAM=y
  CONFIG_BLK_DEV_RAM_COUNT=2
  CONFIG_SCSI=y
  CONFIG_BLK_DEV_SD=y
  CONFIG_NETDEVICES=y
  CONFIG_B43=y
  CONFIG_B43_SDIO=y
  # CONFIG_B43_PHY_LP is not set
  CONFIG_B43_DEBUG=y
  CONFIG_INPUT_FF_MEMLESS=m
  # CONFIG_INPUT_MOUSEDEV_PSAUX is not set
  CONFIG_INPUT_MOUSEDEV_SCREEN_X=640
  CONFIG_INPUT_MOUSEDEV_SCREEN_Y=480
  CONFIG_INPUT_JOYDEV=y
  CONFIG_INPUT_EVDEV=y
  # CONFIG_KEYBOARD_ATKBD is not set
  # CONFIG_MOUSE_PS2 is not set
  CONFIG_INPUT_JOYSTICK=y
  CONFIG_INPUT_MISC=y
  CONFIG_INPUT_UINPUT=y
! # CONFIG_SERIO_I8042 is not set
! # CONFIG_SERIO_SERPORT is not set
  CONFIG_LEGACY_PTY_COUNT=64
  # CONFIG_DEVKMEM is not set
  # CONFIG_HW_RANDOM is not set
  CONFIG_NVRAM=y
  CONFIG_I2C=y
  CONFIG_I2C_CHARDEV=y
  CONFIG_I2C_GPIO=y
  CONFIG_GPIOLIB=y
  CONFIG_GPIO_SYSFS=y
  # CONFIG_HWMON is not set
  CONFIG_SSB_DEBUG=y
  CONFIG_FB=y
  # CONFIG_VGA_CONSOLE is not set
  CONFIG_FRAMEBUFFER_CONSOLE=y
  CONFIG_SOUND=y
  CONFIG_SND=y
  CONFIG_SND_SEQUENCER=y
  CONFIG_SND_MIXER_OSS=y
  CONFIG_SND_PCM_OSS=y
  CONFIG_SND_SEQUENCER_OSS=y
  # CONFIG_SND_VERBOSE_PROCFS is not set
  CONFIG_HID_APPLE=m
! CONFIG_HID_WACOM=m
  CONFIG_MMC=y
  CONFIG_MMC_SDHCI=y
  CONFIG_RTC_CLASS=y
  CONFIG_RTC_DRV_GENERIC=y
  CONFIG_EXT2_FS=y
! CONFIG_EXT3_FS=y
! # CONFIG_EXT3_DEFAULTS_TO_ORDERED is not set
! # CONFIG_EXT3_FS_XATTR is not set
  CONFIG_FUSE_FS=m
  CONFIG_ISO9660_FS=y
  CONFIG_JOLIET=y
  CONFIG_MSDOS_FS=y
  CONFIG_VFAT_FS=y
  CONFIG_PROC_KCORE=y
  # CONFIG_PROC_PAGE_MONITOR is not set
  CONFIG_TMPFS=y
  CONFIG_NFS_FS=y
  CONFIG_ROOT_NFS=y
  CONFIG_CIFS=m
  CONFIG_NLS_CODEPAGE_437=y
  CONFIG_NLS_ISO8859_1=y
  CONFIG_CRC_CCITT=y
  CONFIG_PRINTK_TIME=y
  CONFIG_MAGIC_SYSRQ=y
  CONFIG_DEBUG_SPINLOCK=y
  CONFIG_DEBUG_MUTEXES=y
  CONFIG_LATENCYTOP=y
  CONFIG_SCHED_TRACER=y
  CONFIG_BLK_DEV_IO_TRACE=y
  CONFIG_DMA_API_DEBUG=y
  CONFIG_PPC_EARLY_DEBUG=y
  # CONFIG_CRYPTO_ANSI_CPRNG is not set
  # CONFIG_CRYPTO_HW is not set
--- 1,2062 ----
+ #
+ # Automatically generated file; DO NOT EDIT.
+ # Linux/powerpc 3.12.3 Kernel Configuration
+ #
+ # CONFIG_PPC64 is not set
+ 
+ #
+ # Processor support
+ #
+ CONFIG_PPC_BOOK3S_32=y
+ # CONFIG_PPC_85xx is not set
+ # CONFIG_PPC_8xx is not set
+ # CONFIG_40x is not set
+ # CONFIG_44x is not set
+ # CONFIG_E200 is not set
+ CONFIG_PPC_BOOK3S=y
+ CONFIG_6xx=y
+ CONFIG_PPC_FPU=y
+ # CONFIG_ALTIVEC is not set
+ CONFIG_PPC_STD_MMU=y
+ CONFIG_PPC_STD_MMU_32=y
+ # CONFIG_PPC_MM_SLICES is not set
+ CONFIG_PPC_HAVE_PMU_SUPPORT=y
+ CONFIG_PPC_PERF_CTRS=y
+ # CONFIG_SMP is not set
+ CONFIG_NOT_COHERENT_CACHE=y
+ # CONFIG_PPC_DOORBELL is not set
+ CONFIG_PPC32=y
+ CONFIG_32BIT=y
+ CONFIG_WORD_SIZE=32
+ # CONFIG_ARCH_PHYS_ADDR_T_64BIT is not set
+ # CONFIG_ARCH_DMA_ADDR_T_64BIT is not set
+ CONFIG_MMU=y
+ # CONFIG_HAVE_SETUP_PER_CPU_AREA is not set
+ # CONFIG_NEED_PER_CPU_EMBED_FIRST_CHUNK is not set
+ CONFIG_NR_IRQS=512
+ CONFIG_STACKTRACE_SUPPORT=y
+ CONFIG_HAVE_LATENCYTOP_SUPPORT=y
+ CONFIG_TRACE_IRQFLAGS_SUPPORT=y
+ CONFIG_LOCKDEP_SUPPORT=y
+ CONFIG_RWSEM_XCHGADD_ALGORITHM=y
+ CONFIG_ARCH_HAS_ILOG2_U32=y
+ CONFIG_GENERIC_HWEIGHT=y
+ CONFIG_PPC=y
+ CONFIG_EARLY_PRINTK=y
+ CONFIG_GENERIC_NVRAM=y
+ CONFIG_SCHED_OMIT_FRAME_POINTER=y
+ CONFIG_ARCH_MAY_HAVE_PC_FDC=y
+ CONFIG_PPC_OF=y
+ # CONFIG_PPC_UDBG_16550 is not set
+ # CONFIG_GENERIC_TBSYNC is not set
+ CONFIG_AUDIT_ARCH=y
+ CONFIG_GENERIC_BUG=y
+ # CONFIG_EPAPR_BOOT is not set
+ # CONFIG_DEFAULT_UIMAGE is not set
+ CONFIG_ARCH_HIBERNATION_POSSIBLE=y
+ # CONFIG_PPC_DCR_NATIVE is not set
+ # CONFIG_PPC_DCR_MMIO is not set
+ CONFIG_ARCH_SUPPORTS_DEBUG_PAGEALLOC=y
+ CONFIG_ARCH_SUPPORTS_UPROBES=y
+ CONFIG_DEFCONFIG_LIST="/lib/modules/$UNAME_RELEASE/.config"
+ CONFIG_IRQ_WORK=y
+ 
+ #
+ # General setup
+ #
+ CONFIG_BROKEN_ON_SMP=y
+ CONFIG_INIT_ENV_ARG_LIMIT=32
+ CONFIG_CROSS_COMPILE=""
+ # CONFIG_COMPILE_TEST is not set
  CONFIG_LOCALVERSION="-wii"
  # CONFIG_LOCALVERSION_AUTO is not set
+ CONFIG_DEFAULT_HOSTNAME="(none)"
+ CONFIG_SWAP=y
  CONFIG_SYSVIPC=y
+ CONFIG_SYSVIPC_SYSCTL=y
+ # CONFIG_POSIX_MQUEUE is not set
+ # CONFIG_FHANDLE is not set
+ # CONFIG_AUDIT is not set
+ 
+ #
+ # IRQ subsystem
+ #
+ CONFIG_GENERIC_IRQ_SHOW=y
+ CONFIG_GENERIC_IRQ_SHOW_LEVEL=y
+ CONFIG_IRQ_DOMAIN=y
+ # CONFIG_IRQ_DOMAIN_DEBUG is not set
+ CONFIG_IRQ_FORCED_THREADING=y
+ CONFIG_SPARSE_IRQ=y
+ CONFIG_GENERIC_TIME_VSYSCALL_OLD=y
+ CONFIG_GENERIC_CLOCKEVENTS=y
+ CONFIG_GENERIC_CLOCKEVENTS_BUILD=y
+ CONFIG_GENERIC_CMOS_UPDATE=y
+ 
+ #
+ # Timers subsystem
+ #
+ CONFIG_HZ_PERIODIC=y
+ # CONFIG_NO_HZ_IDLE is not set
+ # CONFIG_NO_HZ is not set
+ # CONFIG_HIGH_RES_TIMERS is not set
+ 
+ #
+ # CPU/Task time and stats accounting
+ #
+ CONFIG_TICK_CPU_ACCOUNTING=y
+ # CONFIG_BSD_PROCESS_ACCT is not set
+ # CONFIG_TASKSTATS is not set
+ 
+ #
+ # RCU Subsystem
+ #
+ CONFIG_TREE_PREEMPT_RCU=y
+ CONFIG_PREEMPT_RCU=y
+ CONFIG_RCU_STALL_COMMON=y
+ CONFIG_RCU_FANOUT=32
+ CONFIG_RCU_FANOUT_LEAF=16
+ # CONFIG_RCU_FANOUT_EXACT is not set
+ # CONFIG_TREE_RCU_TRACE is not set
+ # CONFIG_RCU_BOOST is not set
+ # CONFIG_RCU_NOCB_CPU is not set
  CONFIG_IKCONFIG=y
  CONFIG_IKCONFIG_PROC=y
  CONFIG_LOG_BUF_SHIFT=14
+ # CONFIG_CGROUPS is not set
+ # CONFIG_CHECKPOINT_RESTORE is not set
+ # CONFIG_NAMESPACES is not set
+ # CONFIG_UIDGID_STRICT_TYPE_CHECKS is not set
+ # CONFIG_SCHED_AUTOGROUP is not set
+ # CONFIG_SYSFS_DEPRECATED is not set
+ CONFIG_RELAY=y
  CONFIG_BLK_DEV_INITRD=y
+ CONFIG_INITRAMFS_SOURCE=""
+ CONFIG_RD_GZIP=y
+ # CONFIG_RD_BZIP2 is not set
+ # CONFIG_RD_LZMA is not set
+ # CONFIG_RD_XZ is not set
+ # CONFIG_RD_LZO is not set
+ # CONFIG_RD_LZ4 is not set
+ # CONFIG_CC_OPTIMIZE_FOR_SIZE is not set
+ CONFIG_SYSCTL=y
+ CONFIG_ANON_INODES=y
+ CONFIG_SYSCTL_EXCEPTION_TRACE=y
  CONFIG_EXPERT=y
+ # CONFIG_SYSCTL_SYSCALL is not set
+ CONFIG_KALLSYMS=y
+ CONFIG_KALLSYMS_ALL=y
+ CONFIG_PRINTK=y
+ CONFIG_BUG=y
  # CONFIG_ELF_CORE is not set
+ CONFIG_BASE_FULL=y
+ CONFIG_FUTEX=y
+ CONFIG_EPOLL=y
+ CONFIG_SIGNALFD=y
+ CONFIG_TIMERFD=y
+ CONFIG_EVENTFD=y
+ CONFIG_SHMEM=y
+ CONFIG_AIO=y
+ # CONFIG_EMBEDDED is not set
+ CONFIG_HAVE_PERF_EVENTS=y
+ 
+ #
+ # Kernel Performance Events And Counters
+ #
  CONFIG_PERF_EVENTS=y
+ # CONFIG_DEBUG_PERF_USE_VMALLOC is not set
  # CONFIG_VM_EVENT_COUNTERS is not set
+ CONFIG_COMPAT_BRK=y
  CONFIG_SLAB=y
+ # CONFIG_SLUB is not set
+ # CONFIG_SLOB is not set
+ # CONFIG_PROFILING is not set
+ CONFIG_TRACEPOINTS=y
+ CONFIG_HAVE_OPROFILE=y
+ # CONFIG_KPROBES is not set
+ # CONFIG_JUMP_LABEL is not set
+ # CONFIG_HAVE_64BIT_ALIGNED_ACCESS is not set
+ CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS=y
+ CONFIG_ARCH_USE_BUILTIN_BSWAP=y
+ CONFIG_HAVE_IOREMAP_PROT=y
+ CONFIG_HAVE_KPROBES=y
+ CONFIG_HAVE_KRETPROBES=y
+ CONFIG_HAVE_ARCH_TRACEHOOK=y
+ CONFIG_HAVE_DMA_ATTRS=y
+ CONFIG_GENERIC_SMP_IDLE_THREAD=y
+ CONFIG_HAVE_REGS_AND_STACK_ACCESS_API=y
+ CONFIG_HAVE_DMA_API_DEBUG=y
+ CONFIG_HAVE_ARCH_JUMP_LABEL=y
+ CONFIG_ARCH_HAVE_NMI_SAFE_CMPXCHG=y
+ CONFIG_ARCH_WANT_IPC_PARSE_VERSION=y
+ CONFIG_HAVE_MOD_ARCH_SPECIFIC=y
+ CONFIG_MODULES_USE_ELF_RELA=y
+ CONFIG_CLONE_BACKWARDS=y
+ CONFIG_OLD_SIGSUSPEND=y
+ CONFIG_OLD_SIGACTION=y
+ 
+ #
+ # GCOV-based kernel profiling
+ #
+ # CONFIG_GCOV_KERNEL is not set
+ CONFIG_HAVE_GENERIC_DMA_COHERENT=y
+ CONFIG_SLABINFO=y
+ CONFIG_RT_MUTEXES=y
+ CONFIG_BASE_SMALL=0
  CONFIG_MODULES=y
+ # CONFIG_MODULE_FORCE_LOAD is not set
  CONFIG_MODULE_UNLOAD=y
+ # CONFIG_MODULE_FORCE_UNLOAD is not set
+ # CONFIG_MODVERSIONS is not set
+ # CONFIG_MODULE_SRCVERSION_ALL is not set
+ # CONFIG_MODULE_SIG is not set
+ CONFIG_BLOCK=y
+ CONFIG_LBDAF=y
+ CONFIG_BLK_DEV_BSG=y
+ # CONFIG_BLK_DEV_BSGLIB is not set
+ # CONFIG_BLK_DEV_INTEGRITY is not set
+ # CONFIG_BLK_CMDLINE_PARSER is not set
+ 
+ #
+ # Partition Types
+ #
+ # CONFIG_PARTITION_ADVANCED is not set
+ CONFIG_MSDOS_PARTITION=y
+ CONFIG_EFI_PARTITION=y
+ 
+ #
+ # IO Schedulers
+ #
+ CONFIG_IOSCHED_NOOP=y
+ CONFIG_IOSCHED_DEADLINE=y
+ CONFIG_IOSCHED_CFQ=y
+ # CONFIG_DEFAULT_DEADLINE is not set
+ CONFIG_DEFAULT_CFQ=y
+ # CONFIG_DEFAULT_NOOP is not set
+ CONFIG_DEFAULT_IOSCHED="cfq"
+ CONFIG_UNINLINE_SPIN_UNLOCK=y
+ # CONFIG_FREEZER is not set
+ # CONFIG_PPC_XICS is not set
+ # CONFIG_PPC_ICP_NATIVE is not set
+ # CONFIG_PPC_ICP_HV is not set
+ # CONFIG_PPC_ICS_RTAS is not set
+ # CONFIG_GE_FPGA is not set
+ 
+ #
+ # Platform support
+ #
  # CONFIG_PPC_CHRP is not set
+ # CONFIG_PPC_MPC512x is not set
+ # CONFIG_PPC_MPC52xx is not set
  # CONFIG_PPC_PMAC is not set
+ # CONFIG_PPC_CELL is not set
+ # CONFIG_PPC_CELL_NATIVE is not set
+ # CONFIG_PPC_82xx is not set
+ # CONFIG_PQ2ADS is not set
+ # CONFIG_PPC_83xx is not set
+ # CONFIG_PPC_86xx is not set
  CONFIG_EMBEDDED6xx=y
+ # CONFIG_LINKSTATION is not set
+ # CONFIG_STORCENTER is not set
+ # CONFIG_MPC7448HPC2 is not set
+ # CONFIG_PPC_HOLLY is not set
+ # CONFIG_PPC_PRPMC2800 is not set
+ # CONFIG_PPC_C2K is not set
+ CONFIG_GAMECUBE_COMMON=y
+ CONFIG_GAMECUBE_UDBG=y
+ # CONFIG_USBGECKO_UDBG is not set
+ CONFIG_GAMECUBE_VIDEO_UDBG=y
+ CONFIG_GAMECUBE_RSW=y
+ CONFIG_HLWD_GPIO=y
+ # CONFIG_GAMECUBE is not set
  CONFIG_WII=y
+ # CONFIG_STARLET_IOS is not set
+ CONFIG_STARLET_MINI=y
+ CONFIG_HLWD_PIC=y
+ # CONFIG_AMIGAONE is not set
+ # CONFIG_PPC_WSP is not set
+ # CONFIG_KVM_GUEST is not set
+ # CONFIG_EPAPR_PARAVIRT is not set
  # CONFIG_PPC_OF_BOOT_TRAMPOLINE is not set
+ # CONFIG_IPIC is not set
+ # CONFIG_MPIC is not set
+ # CONFIG_PPC_EPAPR_HV_PIC is not set
+ # CONFIG_MPIC_WEIRD is not set
+ # CONFIG_PPC_I8259 is not set
+ # CONFIG_PPC_RTAS is not set
+ # CONFIG_MMIO_NVRAM is not set
+ # CONFIG_MPIC_U3_HT_IRQS is not set
+ # CONFIG_PPC_MPC106 is not set
+ # CONFIG_PPC_970_NAP is not set
+ # CONFIG_PPC_P7_NAP is not set
+ 
+ #
+ # CPU Frequency scaling
+ #
+ # CONFIG_CPU_FREQ is not set
+ 
+ #
+ # CPUIdle driver
+ #
+ 
+ #
+ # CPU Idle
+ #
+ # CONFIG_CPU_IDLE is not set
+ # CONFIG_ARCH_NEEDS_CPU_IDLE_COUPLED is not set
+ # CONFIG_TAU is not set
+ # CONFIG_FSL_ULI1575 is not set
+ # CONFIG_SIMPLE_GPIO is not set
+ 
+ #
+ # Kernel options
+ #
+ # CONFIG_HIGHMEM is not set
+ # CONFIG_HZ_100 is not set
+ CONFIG_HZ_250=y
+ # CONFIG_HZ_300 is not set
+ # CONFIG_HZ_1000 is not set
+ CONFIG_HZ=250
+ # CONFIG_SCHED_HRTICK is not set
+ # CONFIG_PREEMPT_NONE is not set
+ # CONFIG_PREEMPT_VOLUNTARY is not set
  CONFIG_PREEMPT=y
+ CONFIG_PREEMPT_COUNT=y
+ CONFIG_BINFMT_ELF=y
+ CONFIG_BINFMT_SCRIPT=y
+ # CONFIG_HAVE_AOUT is not set
  CONFIG_BINFMT_MISC=m
+ CONFIG_COREDUMP=y
+ # CONFIG_IOMMU_HELPER is not set
+ CONFIG_ARCH_ENABLE_MEMORY_HOTPLUG=y
+ CONFIG_ARCH_HAS_WALK_MEMORY=y
+ CONFIG_ARCH_ENABLE_MEMORY_HOTREMOVE=y
  CONFIG_KEXEC=y
+ # CONFIG_CRASH_DUMP is not set
+ CONFIG_ARCH_FLATMEM_ENABLE=y
+ CONFIG_FLATMEM=y
+ CONFIG_FLAT_NODE_MEM_MAP=y
+ CONFIG_HAVE_MEMBLOCK=y
+ CONFIG_HAVE_MEMBLOCK_NODE_MAP=y
+ # CONFIG_HAVE_BOOTMEM_INFO_NODE is not set
+ CONFIG_PAGEFLAGS_EXTENDED=y
+ CONFIG_SPLIT_PTLOCK_CPUS=999999
+ CONFIG_COMPACTION=y
+ CONFIG_MIGRATION=y
+ # CONFIG_PHYS_ADDR_T_64BIT is not set
+ CONFIG_ZONE_DMA_FLAG=1
+ CONFIG_BOUNCE=y
+ CONFIG_VIRT_TO_BUS=y
+ # CONFIG_KSM is not set
+ CONFIG_DEFAULT_MMAP_MIN_ADDR=4096
+ CONFIG_CROSS_MEMORY_ATTACH=y
+ CONFIG_NEED_PER_CPU_KM=y
+ # CONFIG_CLEANCACHE is not set
+ # CONFIG_FRONTSWAP is not set
+ # CONFIG_CMA is not set
+ # CONFIG_ZBUD is not set
+ CONFIG_PPC_4K_PAGES=y
+ CONFIG_FORCE_MAX_ZONEORDER=11
+ # CONFIG_CMDLINE_BOOL is not set
+ CONFIG_EXTRA_TARGETS=""
+ # CONFIG_HIBERNATION is not set
+ # CONFIG_PM_RUNTIME is not set
  # CONFIG_SECCOMP is not set
+ # CONFIG_ISA_DMA_API is not set
+ 
+ #
+ # Bus options
+ #
+ CONFIG_ZONE_DMA=y
+ CONFIG_NEED_DMA_MAP_STATE=y
+ CONFIG_NEED_SG_DMA_LENGTH=y
+ # CONFIG_PCI_DOMAINS is not set
+ # CONFIG_PCI_SYSCALL is not set
+ # CONFIG_PCCARD is not set
+ # CONFIG_HAS_RAPIDIO is not set
+ # CONFIG_NONSTATIC_KERNEL is not set
+ 
+ #
+ # Advanced setup
+ #
  CONFIG_ADVANCED_OPTIONS=y
+ # CONFIG_LOWMEM_SIZE_BOOL is not set
+ CONFIG_LOWMEM_SIZE=0x30000000
+ # CONFIG_PAGE_OFFSET_BOOL is not set
+ CONFIG_PAGE_OFFSET=0xc0000000
+ # CONFIG_KERNEL_START_BOOL is not set
+ CONFIG_KERNEL_START=0xc0000000
+ CONFIG_PHYSICAL_START=0x00000000
+ # CONFIG_TASK_SIZE_BOOL is not set
+ CONFIG_TASK_SIZE=0xc0000000
+ # CONFIG_CONSISTENT_SIZE_BOOL is not set
+ CONFIG_CONSISTENT_SIZE=0x00200000
  CONFIG_NET=y
+ 
+ #
+ # Networking options
+ #
  CONFIG_PACKET=y
+ # CONFIG_PACKET_DIAG is not set
  CONFIG_UNIX=y
+ # CONFIG_UNIX_DIAG is not set
+ # CONFIG_XFRM_USER is not set
+ # CONFIG_NET_KEY is not set
  CONFIG_INET=y
+ # CONFIG_IP_MULTICAST is not set
+ # CONFIG_IP_ADVANCED_ROUTER is not set
  CONFIG_IP_PNP=y
  CONFIG_IP_PNP_DHCP=y
+ # CONFIG_IP_PNP_BOOTP is not set
  CONFIG_IP_PNP_RARP=y
+ # CONFIG_NET_IPIP is not set
+ # CONFIG_NET_IPGRE_DEMUX is not set
+ # CONFIG_NET_IP_TUNNEL is not set
+ # CONFIG_SYN_COOKIES is not set
+ # CONFIG_INET_AH is not set
+ # CONFIG_INET_ESP is not set
+ # CONFIG_INET_IPCOMP is not set
+ # CONFIG_INET_XFRM_TUNNEL is not set
+ # CONFIG_INET_TUNNEL is not set
  # CONFIG_INET_XFRM_MODE_TRANSPORT is not set
  # CONFIG_INET_XFRM_MODE_TUNNEL is not set
  # CONFIG_INET_XFRM_MODE_BEET is not set
  # CONFIG_INET_LRO is not set
  # CONFIG_INET_DIAG is not set
+ # CONFIG_TCP_CONG_ADVANCED is not set
+ CONFIG_TCP_CONG_CUBIC=y
+ CONFIG_DEFAULT_TCP_CONG="cubic"
+ # CONFIG_TCP_MD5SIG is not set
  # CONFIG_IPV6 is not set
+ # CONFIG_NETWORK_SECMARK is not set
+ # CONFIG_NETWORK_PHY_TIMESTAMPING is not set
+ # CONFIG_NETFILTER is not set
+ # CONFIG_IP_DCCP is not set
+ # CONFIG_IP_SCTP is not set
+ # CONFIG_RDS is not set
+ # CONFIG_TIPC is not set
+ # CONFIG_ATM is not set
+ # CONFIG_L2TP is not set
+ # CONFIG_BRIDGE is not set
+ CONFIG_HAVE_NET_DSA=y
+ # CONFIG_VLAN_8021Q is not set
+ # CONFIG_DECNET is not set
+ # CONFIG_LLC2 is not set
+ # CONFIG_IPX is not set
+ # CONFIG_ATALK is not set
+ # CONFIG_X25 is not set
+ # CONFIG_LAPB is not set
+ # CONFIG_PHONET is not set
+ # CONFIG_IEEE802154 is not set
+ # CONFIG_NET_SCHED is not set
+ # CONFIG_DCB is not set
+ # CONFIG_BATMAN_ADV is not set
+ # CONFIG_OPENVSWITCH is not set
+ # CONFIG_VSOCKETS is not set
+ # CONFIG_NETLINK_MMAP is not set
+ # CONFIG_NETLINK_DIAG is not set
+ # CONFIG_NET_MPLS_GSO is not set
+ CONFIG_NET_RX_BUSY_POLL=y
+ CONFIG_BQL=y
+ 
+ #
+ # Network testing
+ #
+ # CONFIG_NET_PKTGEN is not set
+ # CONFIG_NET_DROP_MONITOR is not set
+ # CONFIG_HAMRADIO is not set
+ # CONFIG_CAN is not set
+ # CONFIG_IRDA is not set
  CONFIG_BT=y
  CONFIG_BT_RFCOMM=y
+ # CONFIG_BT_RFCOMM_TTY is not set
  CONFIG_BT_BNEP=y
  CONFIG_BT_BNEP_MC_FILTER=y
+ # CONFIG_BT_BNEP_PROTO_FILTER is not set
  CONFIG_BT_HIDP=y
+ 
+ #
+ # Bluetooth device drivers
+ #
+ # CONFIG_BT_HCIBTUSB is not set
+ # CONFIG_BT_HCIBTSDIO is not set
+ # CONFIG_BT_HCIUART is not set
+ # CONFIG_BT_HCIBCM203X is not set
+ # CONFIG_BT_HCIBPA10X is not set
+ # CONFIG_BT_HCIBFUSB is not set
+ # CONFIG_BT_HCIVHCI is not set
+ # CONFIG_BT_MRVL is not set
+ # CONFIG_AF_RXRPC is not set
+ CONFIG_WIRELESS=y
  CONFIG_CFG80211=y
+ # CONFIG_NL80211_TESTMODE is not set
+ # CONFIG_CFG80211_DEVELOPER_WARNINGS is not set
+ # CONFIG_CFG80211_REG_DEBUG is not set
+ # CONFIG_CFG80211_CERTIFICATION_ONUS is not set
+ CONFIG_CFG80211_DEFAULT_PS=y
+ # CONFIG_CFG80211_DEBUGFS is not set
+ # CONFIG_CFG80211_INTERNAL_REGDB is not set
+ # CONFIG_CFG80211_WEXT is not set
+ # CONFIG_LIB80211 is not set
  CONFIG_MAC80211=y
+ CONFIG_MAC80211_HAS_RC=y
+ # CONFIG_MAC80211_RC_PID is not set
+ CONFIG_MAC80211_RC_MINSTREL=y
+ CONFIG_MAC80211_RC_MINSTREL_HT=y
+ CONFIG_MAC80211_RC_DEFAULT_MINSTREL=y
+ CONFIG_MAC80211_RC_DEFAULT="minstrel_ht"
+ # CONFIG_MAC80211_MESH is not set
+ # CONFIG_MAC80211_DEBUGFS is not set
+ # CONFIG_MAC80211_MESSAGE_TRACING is not set
+ # CONFIG_MAC80211_DEBUG_MENU is not set
+ # CONFIG_WIMAX is not set
+ # CONFIG_RFKILL is not set
+ # CONFIG_NET_9P is not set
+ # CONFIG_CAIF is not set
+ # CONFIG_CEPH_LIB is not set
+ # CONFIG_NFC is not set
+ 
+ #
+ # Device Drivers
+ #
+ 
+ #
+ # Generic Driver Options
+ #
  CONFIG_UEVENT_HELPER_PATH="/sbin/hotplug"
+ # CONFIG_DEVTMPFS is not set
  # CONFIG_STANDALONE is not set
+ CONFIG_PREVENT_FIRMWARE_BUILD=y
+ CONFIG_FW_LOADER=y
  # CONFIG_FIRMWARE_IN_KERNEL is not set
+ CONFIG_EXTRA_FIRMWARE=""
+ CONFIG_FW_LOADER_USER_HELPER=y
+ # CONFIG_DEBUG_DRIVER is not set
+ # CONFIG_DEBUG_DEVRES is not set
+ # CONFIG_SYS_HYPERVISOR is not set
+ # CONFIG_GENERIC_CPU_DEVICES is not set
+ # CONFIG_DMA_SHARED_BUFFER is not set
+ 
+ #
+ # Bus devices
+ #
+ # CONFIG_CONNECTOR is not set
+ # CONFIG_MTD is not set
+ CONFIG_DTC=y
+ CONFIG_OF=y
+ 
+ #
+ # Device Tree and Open Firmware support
+ #
+ CONFIG_PROC_DEVICETREE=y
+ # CONFIG_OF_SELFTEST is not set
+ CONFIG_OF_FLATTREE=y
+ CONFIG_OF_EARLY_FLATTREE=y
+ CONFIG_OF_ADDRESS=y
+ CONFIG_OF_IRQ=y
+ CONFIG_OF_NET=y
+ # CONFIG_PARPORT is not set
+ CONFIG_BLK_DEV=y
+ # CONFIG_BLK_DEV_FD is not set
+ CONFIG_GAMECUBE_SD=y
+ CONFIG_WII_MEM2=y
+ CONFIG_WII_DI=y
+ # CONFIG_BLK_DEV_COW_COMMON is not set
  CONFIG_BLK_DEV_LOOP=y
+ CONFIG_BLK_DEV_LOOP_MIN_COUNT=8
+ # CONFIG_BLK_DEV_CRYPTOLOOP is not set
+ # CONFIG_BLK_DEV_DRBD is not set
+ # CONFIG_BLK_DEV_NBD is not set
  CONFIG_BLK_DEV_RAM=y
  CONFIG_BLK_DEV_RAM_COUNT=2
+ CONFIG_BLK_DEV_RAM_SIZE=4096
+ # CONFIG_BLK_DEV_XIP is not set
+ # CONFIG_CDROM_PKTCDVD is not set
+ # CONFIG_ATA_OVER_ETH is not set
+ # CONFIG_BLK_DEV_HD is not set
+ # CONFIG_BLK_DEV_RBD is not set
+ 
+ #
+ # Misc devices
+ #
+ # CONFIG_SENSORS_LIS3LV02D is not set
+ # CONFIG_AD525X_DPOT is not set
+ # CONFIG_DUMMY_IRQ is not set
+ CONFIG_GAMECUBE_GQR=y
+ # CONFIG_ICS932S401 is not set
+ # CONFIG_ATMEL_SSC is not set
+ # CONFIG_ENCLOSURE_SERVICES is not set
+ # CONFIG_APDS9802ALS is not set
+ # CONFIG_ISL29003 is not set
+ # CONFIG_ISL29020 is not set
+ # CONFIG_SENSORS_TSL2550 is not set
+ # CONFIG_SENSORS_BH1780 is not set
+ # CONFIG_SENSORS_BH1770 is not set
+ # CONFIG_SENSORS_APDS990X is not set
+ # CONFIG_HMC6352 is not set
+ # CONFIG_DS1682 is not set
+ # CONFIG_BMP085_I2C is not set
+ # CONFIG_USB_SWITCH_FSA9480 is not set
+ # CONFIG_SRAM is not set
+ # CONFIG_C2PORT is not set
+ 
+ #
+ # EEPROM support
+ #
+ # CONFIG_EEPROM_AT24 is not set
+ # CONFIG_EEPROM_LEGACY is not set
+ # CONFIG_EEPROM_MAX6875 is not set
+ # CONFIG_EEPROM_93CX6 is not set
+ 
+ #
+ # Texas Instruments shared transport line discipline
+ #
+ # CONFIG_TI_ST is not set
+ # CONFIG_SENSORS_LIS3_I2C is not set
+ 
+ #
+ # Altera FPGA firmware download module
+ #
+ # CONFIG_ALTERA_STAPL is not set
+ CONFIG_HAVE_IDE=y
+ # CONFIG_IDE is not set
+ 
+ #
+ # SCSI device support
+ #
+ CONFIG_SCSI_MOD=y
+ # CONFIG_RAID_ATTRS is not set
  CONFIG_SCSI=y
+ CONFIG_SCSI_DMA=y
+ # CONFIG_SCSI_TGT is not set
+ # CONFIG_SCSI_NETLINK is not set
+ CONFIG_SCSI_PROC_FS=y
+ 
+ #
+ # SCSI support type (disk, tape, CD-ROM)
+ #
  CONFIG_BLK_DEV_SD=y
+ # CONFIG_CHR_DEV_ST is not set
+ # CONFIG_CHR_DEV_OSST is not set
+ # CONFIG_BLK_DEV_SR is not set
+ # CONFIG_CHR_DEV_SG is not set
+ # CONFIG_CHR_DEV_SCH is not set
+ CONFIG_SCSI_MULTI_LUN=y
+ # CONFIG_SCSI_CONSTANTS is not set
+ # CONFIG_SCSI_LOGGING is not set
+ # CONFIG_SCSI_SCAN_ASYNC is not set
+ 
+ #
+ # SCSI Transports
+ #
+ # CONFIG_SCSI_SPI_ATTRS is not set
+ # CONFIG_SCSI_FC_ATTRS is not set
+ # CONFIG_SCSI_ISCSI_ATTRS is not set
+ # CONFIG_SCSI_SAS_ATTRS is not set
+ # CONFIG_SCSI_SAS_LIBSAS is not set
+ # CONFIG_SCSI_SRP_ATTRS is not set
+ CONFIG_SCSI_LOWLEVEL=y
+ # CONFIG_ISCSI_TCP is not set
+ # CONFIG_ISCSI_BOOT_SYSFS is not set
+ # CONFIG_SCSI_UFSHCD is not set
+ # CONFIG_LIBFC is not set
+ # CONFIG_LIBFCOE is not set
+ # CONFIG_SCSI_DEBUG is not set
+ # CONFIG_SCSI_DH is not set
+ # CONFIG_SCSI_OSD_INITIATOR is not set
+ # CONFIG_ATA is not set
+ # CONFIG_MD is not set
+ # CONFIG_TARGET_CORE is not set
+ # CONFIG_MACINTOSH_DRIVERS is not set
  CONFIG_NETDEVICES=y
+ CONFIG_NET_CORE=y
+ # CONFIG_BONDING is not set
+ # CONFIG_DUMMY is not set
+ # CONFIG_EQUALIZER is not set
+ # CONFIG_NET_TEAM is not set
+ # CONFIG_MACVLAN is not set
+ # CONFIG_VXLAN is not set
+ # CONFIG_NETCONSOLE is not set
+ # CONFIG_NETPOLL is not set
+ # CONFIG_NET_POLL_CONTROLLER is not set
+ # CONFIG_TUN is not set
+ # CONFIG_VETH is not set
+ # CONFIG_NLMON is not set
+ 
+ #
+ # CAIF transport drivers
+ #
+ 
+ #
+ # Distributed Switch Architecture drivers
+ #
+ # CONFIG_NET_DSA_MV88E6XXX is not set
+ # CONFIG_NET_DSA_MV88E6060 is not set
+ # CONFIG_NET_DSA_MV88E6XXX_NEED_PPU is not set
+ # CONFIG_NET_DSA_MV88E6131 is not set
+ # CONFIG_NET_DSA_MV88E6123_61_65 is not set
+ CONFIG_ETHERNET=y
+ CONFIG_NET_VENDOR_ARC=y
+ # CONFIG_ARC_EMAC is not set
+ CONFIG_NET_CADENCE=y
+ # CONFIG_ARM_AT91_ETHER is not set
+ # CONFIG_MACB is not set
+ CONFIG_NET_VENDOR_BROADCOM=y
+ # CONFIG_B44 is not set
+ # CONFIG_NET_CALXEDA_XGMAC is not set
+ # CONFIG_DNET is not set
+ CONFIG_NET_VENDOR_INTEL=y
+ CONFIG_NET_VENDOR_I825XX=y
+ CONFIG_NET_VENDOR_MARVELL=y
+ # CONFIG_MV643XX_ETH is not set
+ # CONFIG_MVMDIO is not set
+ CONFIG_NET_VENDOR_MICREL=y
+ # CONFIG_KS8851_MLL is not set
+ CONFIG_NET_VENDOR_NATSEMI=y
+ CONFIG_NET_VENDOR_8390=y
+ # CONFIG_ETHOC is not set
+ # CONFIG_SH_ETH is not set
+ CONFIG_NET_VENDOR_SEEQ=y
+ CONFIG_NET_VENDOR_STMICRO=y
+ # CONFIG_STMMAC_ETH is not set
+ CONFIG_NET_VENDOR_VIA=y
+ CONFIG_NET_VENDOR_WIZNET=y
+ # CONFIG_WIZNET_W5100 is not set
+ # CONFIG_WIZNET_W5300 is not set
+ CONFIG_NET_VENDOR_XILINX=y
+ # CONFIG_XILINX_EMACLITE is not set
+ # CONFIG_XILINX_LL_TEMAC is not set
+ # CONFIG_PHYLIB is not set
+ # CONFIG_PPP is not set
+ # CONFIG_SLIP is not set
+ 
+ #
+ # USB Network Adapters
+ #
+ # CONFIG_USB_CATC is not set
+ # CONFIG_USB_KAWETH is not set
+ # CONFIG_USB_PEGASUS is not set
+ # CONFIG_USB_RTL8150 is not set
+ # CONFIG_USB_RTL8152 is not set
+ # CONFIG_USB_USBNET is not set
+ # CONFIG_USB_IPHETH is not set
+ CONFIG_WLAN=y
+ # CONFIG_LIBERTAS_THINFIRM is not set
+ # CONFIG_AT76C50X_USB is not set
+ # CONFIG_USB_ZD1201 is not set
+ # CONFIG_USB_NET_RNDIS_WLAN is not set
+ # CONFIG_RTL8187 is not set
+ # CONFIG_MAC80211_HWSIM is not set
+ # CONFIG_ATH_CARDS is not set
  CONFIG_B43=y
+ CONFIG_B43_SSB=y
  CONFIG_B43_SDIO=y
+ # CONFIG_B43_DEFAULT_QOS_OFF is not set
+ CONFIG_B43_PIO=y
+ # CONFIG_B43_PHY_N is not set
  # CONFIG_B43_PHY_LP is not set
  CONFIG_B43_DEBUG=y
+ # CONFIG_B43LEGACY is not set
+ # CONFIG_BRCMFMAC is not set
+ # CONFIG_HOSTAP is not set
+ # CONFIG_LIBERTAS is not set
+ # CONFIG_P54_COMMON is not set
+ # CONFIG_RT2X00 is not set
+ CONFIG_RTL_CARDS=y
+ # CONFIG_RTL8192CU is not set
+ # CONFIG_WL_TI is not set
+ # CONFIG_ZD1211RW is not set
+ # CONFIG_MWIFIEX is not set
+ # CONFIG_CW1200 is not set
+ 
+ #
+ # Enable WiMAX (Networking options) to see the WiMAX drivers
+ #
+ # CONFIG_WAN is not set
+ # CONFIG_ISDN is not set
+ 
+ #
+ # Input device support
+ #
+ CONFIG_INPUT=y
  CONFIG_INPUT_FF_MEMLESS=m
+ # CONFIG_INPUT_POLLDEV is not set
+ # CONFIG_INPUT_SPARSEKMAP is not set
+ # CONFIG_INPUT_MATRIXKMAP is not set
+ 
+ #
+ # Userland interfaces
+ #
+ CONFIG_INPUT_MOUSEDEV=y
  # CONFIG_INPUT_MOUSEDEV_PSAUX is not set
  CONFIG_INPUT_MOUSEDEV_SCREEN_X=640
  CONFIG_INPUT_MOUSEDEV_SCREEN_Y=480
  CONFIG_INPUT_JOYDEV=y
  CONFIG_INPUT_EVDEV=y
+ # CONFIG_INPUT_EVBUG is not set
+ 
+ #
+ # Input Device Drivers
+ #
+ CONFIG_INPUT_KEYBOARD=y
+ # CONFIG_KEYBOARD_ADP5588 is not set
+ # CONFIG_KEYBOARD_ADP5589 is not set
  # CONFIG_KEYBOARD_ATKBD is not set
+ # CONFIG_KEYBOARD_QT1070 is not set
+ # CONFIG_KEYBOARD_QT2160 is not set
+ # CONFIG_KEYBOARD_LKKBD is not set
+ # CONFIG_KEYBOARD_GPIO is not set
+ # CONFIG_KEYBOARD_GPIO_POLLED is not set
+ # CONFIG_KEYBOARD_TCA6416 is not set
+ # CONFIG_KEYBOARD_TCA8418 is not set
+ # CONFIG_KEYBOARD_MATRIX is not set
+ # CONFIG_KEYBOARD_LM8333 is not set
+ # CONFIG_KEYBOARD_MAX7359 is not set
+ # CONFIG_KEYBOARD_MCS is not set
+ # CONFIG_KEYBOARD_MPR121 is not set
+ # CONFIG_KEYBOARD_NEWTON is not set
+ # CONFIG_KEYBOARD_OPENCORES is not set
+ # CONFIG_KEYBOARD_STOWAWAY is not set
+ # CONFIG_KEYBOARD_SUNKBD is not set
+ # CONFIG_KEYBOARD_XTKBD is not set
+ CONFIG_INPUT_MOUSE=y
  # CONFIG_MOUSE_PS2 is not set
+ # CONFIG_MOUSE_SERIAL is not set
+ # CONFIG_MOUSE_APPLETOUCH is not set
+ # CONFIG_MOUSE_BCM5974 is not set
+ # CONFIG_MOUSE_CYAPA is not set
+ # CONFIG_MOUSE_VSXXXAA is not set
+ # CONFIG_MOUSE_GPIO is not set
+ # CONFIG_MOUSE_SYNAPTICS_I2C is not set
+ # CONFIG_MOUSE_SYNAPTICS_USB is not set
  CONFIG_INPUT_JOYSTICK=y
+ # CONFIG_JOYSTICK_ANALOG is not set
+ # CONFIG_JOYSTICK_A3D is not set
+ # CONFIG_JOYSTICK_ADI is not set
+ # CONFIG_JOYSTICK_COBRA is not set
+ # CONFIG_JOYSTICK_GF2K is not set
+ # CONFIG_JOYSTICK_GRIP is not set
+ # CONFIG_JOYSTICK_GRIP_MP is not set
+ # CONFIG_JOYSTICK_GUILLEMOT is not set
+ # CONFIG_JOYSTICK_INTERACT is not set
+ # CONFIG_JOYSTICK_SIDEWINDER is not set
+ # CONFIG_JOYSTICK_TMDC is not set
+ # CONFIG_JOYSTICK_IFORCE is not set
+ # CONFIG_JOYSTICK_WARRIOR is not set
+ # CONFIG_JOYSTICK_MAGELLAN is not set
+ # CONFIG_JOYSTICK_SPACEORB is not set
+ # CONFIG_JOYSTICK_SPACEBALL is not set
+ # CONFIG_JOYSTICK_STINGER is not set
+ # CONFIG_JOYSTICK_TWIDJOY is not set
+ # CONFIG_JOYSTICK_ZHENHUA is not set
+ # CONFIG_JOYSTICK_AS5011 is not set
+ # CONFIG_JOYSTICK_JOYDUMP is not set
+ # CONFIG_JOYSTICK_XPAD is not set
+ # CONFIG_INPUT_TABLET is not set
+ # CONFIG_INPUT_TOUCHSCREEN is not set
  CONFIG_INPUT_MISC=y
+ # CONFIG_INPUT_AD714X is not set
+ # CONFIG_INPUT_BMA150 is not set
+ # CONFIG_INPUT_MMA8450 is not set
+ # CONFIG_INPUT_MPU3050 is not set
+ # CONFIG_INPUT_GP2A is not set
+ # CONFIG_INPUT_GPIO_TILT_POLLED is not set
+ # CONFIG_INPUT_ATI_REMOTE2 is not set
+ # CONFIG_INPUT_KEYSPAN_REMOTE is not set
+ # CONFIG_INPUT_KXTJ9 is not set
+ # CONFIG_INPUT_POWERMATE is not set
+ # CONFIG_INPUT_YEALINK is not set
+ # CONFIG_INPUT_CM109 is not set
  CONFIG_INPUT_UINPUT=y
! # CONFIG_INPUT_PCF8574 is not set
! # CONFIG_INPUT_GPIO_ROTARY_ENCODER is not set
! # CONFIG_INPUT_ADXL34X is not set
! # CONFIG_INPUT_CMA3000 is not set
! 
! #
! # Hardware I/O ports
! #
! # CONFIG_SERIO is not set
! # CONFIG_GAMEPORT is not set
! # CONFIG_GAMECUBE_SI is not set
! 
! #
! # Character devices
! #
! CONFIG_TTY=y
! CONFIG_VT=y
! CONFIG_CONSOLE_TRANSLATIONS=y
! CONFIG_VT_CONSOLE=y
! CONFIG_HW_CONSOLE=y
! CONFIG_VT_HW_CONSOLE_BINDING=y
! CONFIG_UNIX98_PTYS=y
! # CONFIG_DEVPTS_MULTIPLE_INSTANCES is not set
! CONFIG_LEGACY_PTYS=y
  CONFIG_LEGACY_PTY_COUNT=64
+ # CONFIG_SERIAL_NONSTANDARD is not set
+ # CONFIG_N_GSM is not set
+ # CONFIG_TRACE_SINK is not set
+ # CONFIG_PPC_EPAPR_HV_BYTECHAN is not set
  # CONFIG_DEVKMEM is not set
+ 
+ #
+ # Serial drivers
+ #
+ # CONFIG_SERIAL_8250 is not set
+ 
+ #
+ # Non-8250 serial port support
+ #
+ # CONFIG_SERIAL_UARTLITE is not set
+ # CONFIG_SERIAL_SCCNXP is not set
+ # CONFIG_SERIAL_TIMBERDALE is not set
+ # CONFIG_SERIAL_ALTERA_JTAGUART is not set
+ # CONFIG_SERIAL_ALTERA_UART is not set
+ # CONFIG_SERIAL_XILINX_PS_UART is not set
+ # CONFIG_SERIAL_ARC is not set
+ # CONFIG_SERIAL_FSL_LPUART is not set
+ # CONFIG_SERIAL_ST_ASC is not set
+ # CONFIG_TTY_PRINTK is not set
+ # CONFIG_HVC_UDBG is not set
+ # CONFIG_IPMI_HANDLER is not set
  # CONFIG_HW_RANDOM is not set
  CONFIG_NVRAM=y
+ # CONFIG_R3964 is not set
+ # CONFIG_RAW_DRIVER is not set
+ # CONFIG_TCG_TPM is not set
  CONFIG_I2C=y
+ CONFIG_I2C_BOARDINFO=y
+ CONFIG_I2C_COMPAT=y
  CONFIG_I2C_CHARDEV=y
+ # CONFIG_I2C_MUX is not set
+ CONFIG_I2C_HELPER_AUTO=y
+ CONFIG_I2C_ALGOBIT=y
+ 
+ #
+ # I2C Hardware Bus support
+ #
+ 
+ #
+ # I2C system bus drivers (mostly embedded / system-on-chip)
+ #
+ # CONFIG_I2C_CBUS_GPIO is not set
+ CONFIG_I2C_GPIO_COMMON=y
  CONFIG_I2C_GPIO=y
+ # CONFIG_I2C_GPIO_OF is not set
+ # CONFIG_I2C_MPC is not set
+ # CONFIG_I2C_OCORES is not set
+ # CONFIG_I2C_PCA_PLATFORM is not set
+ # CONFIG_I2C_PXA_PCI is not set
+ # CONFIG_I2C_SIMTEC is not set
+ # CONFIG_I2C_XILINX is not set
+ 
+ #
+ # External I2C/SMBus adapter drivers
+ #
+ # CONFIG_I2C_DIOLAN_U2C is not set
+ # CONFIG_I2C_PARPORT_LIGHT is not set
+ # CONFIG_I2C_TAOS_EVM is not set
+ # CONFIG_I2C_TINY_USB is not set
+ 
+ #
+ # Other I2C/SMBus bus drivers
+ #
+ # CONFIG_I2C_STUB is not set
+ # CONFIG_I2C_DEBUG_CORE is not set
+ # CONFIG_I2C_DEBUG_ALGO is not set
+ # CONFIG_I2C_DEBUG_BUS is not set
+ 
+ #
+ # EXI support
+ #
+ CONFIG_GAMECUBE_EXI=y
+ # CONFIG_SPI is not set
+ # CONFIG_HSI is not set
+ 
+ #
+ # PPS support
+ #
+ # CONFIG_PPS is not set
+ 
+ #
+ # PPS generators support
+ #
+ 
+ #
+ # PTP clock support
+ #
+ # CONFIG_PTP_1588_CLOCK is not set
+ 
+ #
+ # Enable PHYLIB and NETWORK_PHY_TIMESTAMPING to see the additional clocks.
+ #
+ CONFIG_ARCH_WANT_OPTIONAL_GPIOLIB=y
+ CONFIG_GPIO_DEVRES=y
  CONFIG_GPIOLIB=y
+ CONFIG_OF_GPIO=y
+ # CONFIG_DEBUG_GPIO is not set
  CONFIG_GPIO_SYSFS=y
+ 
+ #
+ # Memory mapped GPIO drivers:
+ #
+ # CONFIG_GPIO_GENERIC_PLATFORM is not set
+ # CONFIG_GPIO_TS5500 is not set
+ # CONFIG_GPIO_XILINX is not set
+ # CONFIG_GPIO_GRGPIO is not set
+ 
+ #
+ # I2C GPIO expanders:
+ #
+ # CONFIG_GPIO_MAX7300 is not set
+ # CONFIG_GPIO_MAX732X is not set
+ # CONFIG_GPIO_PCA953X is not set
+ # CONFIG_GPIO_PCF857X is not set
+ # CONFIG_GPIO_SX150X is not set
+ # CONFIG_GPIO_ADP5588 is not set
+ # CONFIG_GPIO_ADNP is not set
+ 
+ #
+ # PCI GPIO expanders:
+ #
+ 
+ #
+ # SPI GPIO expanders:
+ #
+ # CONFIG_GPIO_MCP23S08 is not set
+ 
+ #
+ # AC97 GPIO expanders:
+ #
+ 
+ #
+ # LPC GPIO expanders:
+ #
+ 
+ #
+ # MODULbus GPIO expanders:
+ #
+ 
+ #
+ # USB GPIO expanders:
+ #
+ # CONFIG_W1 is not set
+ # CONFIG_POWER_SUPPLY is not set
+ # CONFIG_POWER_AVS is not set
  # CONFIG_HWMON is not set
+ # CONFIG_THERMAL is not set
+ # CONFIG_WATCHDOG is not set
+ CONFIG_SSB_POSSIBLE=y
+ 
+ #
+ # Sonics Silicon Backplane
+ #
+ CONFIG_SSB=y
+ CONFIG_SSB_BLOCKIO=y
+ CONFIG_SSB_SDIOHOST_POSSIBLE=y
+ CONFIG_SSB_SDIOHOST=y
+ # CONFIG_SSB_SILENT is not set
  CONFIG_SSB_DEBUG=y
+ # CONFIG_SSB_DRIVER_GPIO is not set
+ CONFIG_BCMA_POSSIBLE=y
+ 
+ #
+ # Broadcom specific AMBA
+ #
+ # CONFIG_BCMA is not set
+ 
+ #
+ # Multifunction device drivers
+ #
+ # CONFIG_MFD_CORE is not set
+ # CONFIG_MFD_AS3711 is not set
+ # CONFIG_PMIC_ADP5520 is not set
+ # CONFIG_MFD_AAT2870_CORE is not set
+ # CONFIG_MFD_CROS_EC is not set
+ # CONFIG_PMIC_DA903X is not set
+ # CONFIG_MFD_DA9052_I2C is not set
+ # CONFIG_MFD_DA9055 is not set
+ # CONFIG_MFD_DA9063 is not set
+ # CONFIG_MFD_MC13XXX_I2C is not set
+ # CONFIG_HTC_PASIC3 is not set
+ # CONFIG_HTC_I2CPLD is not set
+ # CONFIG_MFD_KEMPLD is not set
+ # CONFIG_MFD_88PM800 is not set
+ # CONFIG_MFD_88PM805 is not set
+ # CONFIG_MFD_88PM860X is not set
+ # CONFIG_MFD_MAX77686 is not set
+ # CONFIG_MFD_MAX77693 is not set
+ # CONFIG_MFD_MAX8907 is not set
+ # CONFIG_MFD_MAX8925 is not set
+ # CONFIG_MFD_MAX8997 is not set
+ # CONFIG_MFD_MAX8998 is not set
+ # CONFIG_MFD_VIPERBOARD is not set
+ # CONFIG_MFD_RETU is not set
+ # CONFIG_MFD_PCF50633 is not set
+ # CONFIG_MFD_RC5T583 is not set
+ # CONFIG_MFD_SEC_CORE is not set
+ # CONFIG_MFD_SI476X_CORE is not set
+ # CONFIG_MFD_SM501 is not set
+ # CONFIG_MFD_SMSC is not set
+ # CONFIG_ABX500_CORE is not set
+ # CONFIG_MFD_STMPE is not set
+ # CONFIG_MFD_SYSCON is not set
+ # CONFIG_MFD_TI_AM335X_TSCADC is not set
+ # CONFIG_MFD_LP8788 is not set
+ # CONFIG_MFD_PALMAS is not set
+ # CONFIG_TPS6105X is not set
+ # CONFIG_TPS65010 is not set
+ # CONFIG_TPS6507X is not set
+ # CONFIG_MFD_TPS65090 is not set
+ # CONFIG_MFD_TPS65217 is not set
+ # CONFIG_MFD_TPS6586X is not set
+ # CONFIG_MFD_TPS65910 is not set
+ # CONFIG_MFD_TPS65912 is not set
+ # CONFIG_MFD_TPS65912_I2C is not set
+ # CONFIG_MFD_TPS80031 is not set
+ # CONFIG_TWL4030_CORE is not set
+ # CONFIG_TWL6040_CORE is not set
+ # CONFIG_MFD_WL1273_CORE is not set
+ # CONFIG_MFD_LM3533 is not set
+ # CONFIG_MFD_TC3589X is not set
+ # CONFIG_MFD_TMIO is not set
+ # CONFIG_MFD_ARIZONA_I2C is not set
+ # CONFIG_MFD_WM8400 is not set
+ # CONFIG_MFD_WM831X_I2C is not set
+ # CONFIG_MFD_WM8350_I2C is not set
+ # CONFIG_MFD_WM8994 is not set
+ # CONFIG_REGULATOR is not set
+ # CONFIG_MEDIA_SUPPORT is not set
+ 
+ #
+ # Graphics support
+ #
+ # CONFIG_DRM is not set
+ # CONFIG_VGASTATE is not set
+ # CONFIG_VIDEO_OUTPUT_CONTROL is not set
  CONFIG_FB=y
+ # CONFIG_FIRMWARE_EDID is not set
+ # CONFIG_FB_DDC is not set
+ # CONFIG_FB_BOOT_VESA_SUPPORT is not set
+ CONFIG_FB_CFB_FILLRECT=y
+ CONFIG_FB_CFB_COPYAREA=y
+ CONFIG_FB_CFB_IMAGEBLIT=y
+ # CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+ # CONFIG_FB_SYS_FILLRECT is not set
+ # CONFIG_FB_SYS_COPYAREA is not set
+ # CONFIG_FB_SYS_IMAGEBLIT is not set
+ # CONFIG_FB_FOREIGN_ENDIAN is not set
+ # CONFIG_FB_SYS_FOPS is not set
+ # CONFIG_FB_SVGALIB is not set
+ # CONFIG_FB_MACMODES is not set
+ # CONFIG_FB_BACKLIGHT is not set
+ # CONFIG_FB_MODE_HELPERS is not set
+ # CONFIG_FB_TILEBLITTING is not set
+ 
+ #
+ # Frame buffer hardware drivers
+ #
+ # CONFIG_FB_OF is not set
+ # CONFIG_FB_VGA16 is not set
+ # CONFIG_FB_S1D13XXX is not set
+ CONFIG_FB_GAMECUBE=y
+ CONFIG_WII_AVE_RVL=y
+ # CONFIG_FB_SMSCUFX is not set
+ # CONFIG_FB_UDL is not set
+ # CONFIG_FB_IBM_GXT4500 is not set
+ # CONFIG_FB_GOLDFISH is not set
+ # CONFIG_FB_VIRTUAL is not set
+ # CONFIG_FB_METRONOME is not set
+ # CONFIG_FB_MB862XX is not set
+ # CONFIG_FB_BROADSHEET is not set
+ # CONFIG_FB_AUO_K190X is not set
+ # CONFIG_FB_SIMPLE is not set
+ # CONFIG_EXYNOS_VIDEO is not set
+ # CONFIG_BACKLIGHT_LCD_SUPPORT is not set
+ 
+ #
+ # Console display driver support
+ #
  # CONFIG_VGA_CONSOLE is not set
+ CONFIG_DUMMY_CONSOLE=y
  CONFIG_FRAMEBUFFER_CONSOLE=y
+ # CONFIG_FRAMEBUFFER_CONSOLE_DETECT_PRIMARY is not set
+ # CONFIG_FRAMEBUFFER_CONSOLE_ROTATION is not set
+ # CONFIG_LOGO is not set
+ # CONFIG_FB_SSD1307 is not set
  CONFIG_SOUND=y
+ CONFIG_SOUND_OSS_CORE=y
+ CONFIG_SOUND_OSS_CORE_PRECLAIM=y
  CONFIG_SND=y
+ CONFIG_SND_TIMER=y
+ CONFIG_SND_PCM=y
+ CONFIG_SND_HWDEP=m
+ CONFIG_SND_RAWMIDI=m
  CONFIG_SND_SEQUENCER=y
+ # CONFIG_SND_SEQ_DUMMY is not set
+ CONFIG_SND_OSSEMUL=y
  CONFIG_SND_MIXER_OSS=y
  CONFIG_SND_PCM_OSS=y
+ CONFIG_SND_PCM_OSS_PLUGINS=y
  CONFIG_SND_SEQUENCER_OSS=y
+ # CONFIG_SND_DYNAMIC_MINORS is not set
+ CONFIG_SND_SUPPORT_OLD_API=y
  # CONFIG_SND_VERBOSE_PROCFS is not set
+ # CONFIG_SND_VERBOSE_PRINTK is not set
+ # CONFIG_SND_DEBUG is not set
+ CONFIG_SND_RAWMIDI_SEQ=m
+ # CONFIG_SND_OPL3_LIB_SEQ is not set
+ # CONFIG_SND_OPL4_LIB_SEQ is not set
+ # CONFIG_SND_SBAWE_SEQ is not set
+ # CONFIG_SND_EMU10K1_SEQ is not set
+ CONFIG_SND_DRIVERS=y
+ # CONFIG_SND_DUMMY is not set
+ # CONFIG_SND_ALOOP is not set
+ # CONFIG_SND_VIRMIDI is not set
+ # CONFIG_SND_MTPAV is not set
+ # CONFIG_SND_SERIAL_U16550 is not set
+ # CONFIG_SND_MPU401 is not set
+ CONFIG_SND_PPC=y
+ CONFIG_SND_GAMECUBE=y
+ CONFIG_SND_GAMECUBE_MIC=y
+ CONFIG_SND_USB=y
+ CONFIG_SND_USB_AUDIO=m
+ # CONFIG_SND_USB_UA101 is not set
+ # CONFIG_SND_USB_USX2Y is not set
+ # CONFIG_SND_USB_CAIAQ is not set
+ # CONFIG_SND_USB_6FIRE is not set
+ # CONFIG_SND_USB_HIFACE is not set
+ # CONFIG_SND_SOC is not set
+ # CONFIG_SOUND_PRIME is not set
+ 
+ #
+ # HID support
+ #
+ CONFIG_HID=y
+ CONFIG_HIDRAW=y
+ CONFIG_UHID=m
+ CONFIG_HID_GENERIC=y
+ 
+ #
+ # Special HID drivers
+ #
+ # CONFIG_HID_A4TECH is not set
+ # CONFIG_HID_ACRUX is not set
  CONFIG_HID_APPLE=m
! # CONFIG_HID_APPLEIR is not set
! # CONFIG_HID_AUREAL is not set
! # CONFIG_HID_BELKIN is not set
! # CONFIG_HID_CHERRY is not set
! # CONFIG_HID_CHICONY is not set
! # CONFIG_HID_PRODIKEYS is not set
! # CONFIG_HID_CYPRESS is not set
! # CONFIG_HID_DRAGONRISE is not set
! # CONFIG_HID_EMS_FF is not set
! # CONFIG_HID_ELECOM is not set
! # CONFIG_HID_ELO is not set
! # CONFIG_HID_EZKEY is not set
! # CONFIG_HID_HOLTEK is not set
! # CONFIG_HID_HUION is not set
! # CONFIG_HID_KEYTOUCH is not set
! # CONFIG_HID_KYE is not set
! # CONFIG_HID_UCLOGIC is not set
! # CONFIG_HID_WALTOP is not set
! # CONFIG_HID_GYRATION is not set
! # CONFIG_HID_ICADE is not set
! # CONFIG_HID_TWINHAN is not set
! # CONFIG_HID_KENSINGTON is not set
! # CONFIG_HID_LCPOWER is not set
! # CONFIG_HID_LENOVO_TPKBD is not set
! # CONFIG_HID_LOGITECH is not set
! # CONFIG_HID_MAGICMOUSE is not set
! # CONFIG_HID_MICROSOFT is not set
! # CONFIG_HID_MONTEREY is not set
! # CONFIG_HID_MULTITOUCH is not set
! # CONFIG_HID_NTRIG is not set
! # CONFIG_HID_ORTEK is not set
! # CONFIG_HID_PANTHERLORD is not set
! # CONFIG_HID_PETALYNX is not set
! # CONFIG_HID_PICOLCD is not set
! # CONFIG_HID_PRIMAX is not set
! # CONFIG_HID_ROCCAT is not set
! # CONFIG_HID_SAITEK is not set
! # CONFIG_HID_SAMSUNG is not set
! # CONFIG_HID_SPEEDLINK is not set
! # CONFIG_HID_STEELSERIES is not set
! # CONFIG_HID_SUNPLUS is not set
! # CONFIG_HID_GREENASIA is not set
! # CONFIG_HID_SMARTJOYPLUS is not set
! # CONFIG_HID_TIVO is not set
! # CONFIG_HID_TOPSEED is not set
! # CONFIG_HID_THRUSTMASTER is not set
! # CONFIG_HID_XINMO is not set
! # CONFIG_HID_ZEROPLUS is not set
! # CONFIG_HID_ZYDACRON is not set
! # CONFIG_HID_SENSOR_HUB is not set
! 
! #
! # USB HID support
! #
! CONFIG_USB_HID=y
! # CONFIG_HID_PID is not set
! # CONFIG_USB_HIDDEV is not set
! 
! #
! # I2C HID support
! #
! # CONFIG_I2C_HID is not set
! CONFIG_USB_ARCH_HAS_OHCI=y
! CONFIG_USB_OHCI_LITTLE_ENDIAN=y
! CONFIG_USB_ARCH_HAS_EHCI=y
! CONFIG_USB_SUPPORT=y
! CONFIG_USB_COMMON=y
! CONFIG_USB_ARCH_HAS_HCD=y
! CONFIG_USB=y
! # CONFIG_USB_DEBUG is not set
! # CONFIG_USB_ANNOUNCE_NEW_DEVICES is not set
! 
! #
! # Miscellaneous USB options
! #
! CONFIG_USB_DEFAULT_PERSIST=y
! # CONFIG_USB_DYNAMIC_MINORS is not set
! # CONFIG_USB_OTG_WHITELIST is not set
! # CONFIG_USB_OTG_BLACKLIST_HUB is not set
! # CONFIG_USB_MON is not set
! # CONFIG_USB_WUSB_CBAF is not set
! 
! #
! # USB Host Controller Drivers
! #
! # CONFIG_USB_C67X00_HCD is not set
! # CONFIG_USB_XHCI_HCD is not set
! CONFIG_USB_EHCI_HCD=y
! # CONFIG_USB_EHCI_ROOT_HUB_TT is not set
! # CONFIG_USB_EHCI_TT_NEWSCHED is not set
! # CONFIG_XPS_USB_HCD_XILINX is not set
! # CONFIG_USB_EHCI_HCD_PPC_OF is not set
! CONFIG_USB_EHCI_HCD_HLWD=y
! # CONFIG_USB_EHCI_HCD_PLATFORM is not set
! # CONFIG_USB_OXU210HP_HCD is not set
! # CONFIG_USB_ISP116X_HCD is not set
! # CONFIG_USB_ISP1760_HCD is not set
! # CONFIG_USB_ISP1362_HCD is not set
! # CONFIG_USB_FUSBH200_HCD is not set
! # CONFIG_USB_FOTG210_HCD is not set
! CONFIG_USB_OHCI_HCD=y
! # CONFIG_USB_OHCI_HCD_PPC_OF_BE is not set
! # CONFIG_USB_OHCI_HCD_PPC_OF_LE is not set
! # CONFIG_USB_OHCI_HCD_PPC_OF is not set
! CONFIG_USB_OHCI_HCD_HLWD=y
! # CONFIG_USB_OHCI_HCD_SSB is not set
! # CONFIG_USB_OHCI_HCD_PLATFORM is not set
! # CONFIG_USB_SL811_HCD is not set
! # CONFIG_USB_R8A66597_HCD is not set
! # CONFIG_USB_HCD_SSB is not set
! # CONFIG_USB_HCD_TEST_MODE is not set
! 
! #
! # USB Device Class drivers
! #
! # CONFIG_USB_ACM is not set
! CONFIG_USB_PRINTER=y
! # CONFIG_USB_WDM is not set
! # CONFIG_USB_TMC is not set
! 
! #
! # NOTE: USB_STORAGE depends on SCSI but BLK_DEV_SD may
! #
! 
! #
! # also be needed; see USB_STORAGE Help for more info
! #
! # CONFIG_USB_STORAGE is not set
! 
! #
! # USB Imaging devices
! #
! # CONFIG_USB_MDC800 is not set
! # CONFIG_USB_MICROTEK is not set
! # CONFIG_USB_DWC3 is not set
! # CONFIG_USB_CHIPIDEA is not set
! 
! #
! # USB port drivers
! #
! # CONFIG_USB_SERIAL is not set
! 
! #
! # USB Miscellaneous drivers
! #
! # CONFIG_USB_EMI62 is not set
! # CONFIG_USB_EMI26 is not set
! # CONFIG_USB_ADUTUX is not set
! # CONFIG_USB_SEVSEG is not set
! # CONFIG_USB_RIO500 is not set
! # CONFIG_USB_LEGOTOWER is not set
! # CONFIG_USB_LCD is not set
! # CONFIG_USB_LED is not set
! # CONFIG_USB_CYPRESS_CY7C63 is not set
! # CONFIG_USB_CYTHERM is not set
! # CONFIG_USB_IDMOUSE is not set
! # CONFIG_USB_FTDI_ELAN is not set
! # CONFIG_USB_APPLEDISPLAY is not set
! # CONFIG_USB_SISUSBVGA is not set
! # CONFIG_USB_LD is not set
! # CONFIG_USB_TRANCEVIBRATOR is not set
! # CONFIG_USB_IOWARRIOR is not set
! # CONFIG_USB_TEST is not set
! # CONFIG_USB_EHSET_TEST_FIXTURE is not set
! # CONFIG_USB_ISIGHTFW is not set
! # CONFIG_USB_YUREX is not set
! # CONFIG_USB_EZUSB_FX2 is not set
! # CONFIG_USB_HSIC_USB3503 is not set
! 
! #
! # USB Physical Layer drivers
! #
! # CONFIG_USB_PHY is not set
! # CONFIG_NOP_USB_XCEIV is not set
! # CONFIG_AM335X_PHY_USB is not set
! # CONFIG_SAMSUNG_USB2PHY is not set
! # CONFIG_SAMSUNG_USB3PHY is not set
! # CONFIG_USB_GPIO_VBUS is not set
! # CONFIG_USB_ISP1301 is not set
! # CONFIG_USB_RCAR_PHY is not set
! # CONFIG_USB_GADGET is not set
  CONFIG_MMC=y
+ # CONFIG_MMC_DEBUG is not set
+ # CONFIG_MMC_UNSAFE_RESUME is not set
+ # CONFIG_MMC_CLKGATE is not set
+ 
+ #
+ # MMC/SD/SDIO Card Drivers
+ #
+ CONFIG_MMC_BLOCK=y
+ CONFIG_MMC_BLOCK_MINORS=8
+ CONFIG_MMC_BLOCK_BOUNCE=y
+ # CONFIG_SDIO_UART is not set
+ # CONFIG_MMC_TEST is not set
+ 
+ #
+ # MMC/SD/SDIO Host Controller Drivers
+ #
  CONFIG_MMC_SDHCI=y
+ CONFIG_MMC_SDHCI_IO_ACCESSORS=y
+ CONFIG_MMC_SDHCI_BIG_ENDIAN_32BIT_BYTE_SWAPPER=y
+ CONFIG_MMC_SDHCI_PLTFM=y
+ # CONFIG_MMC_SDHCI_OF_ESDHC is not set
+ CONFIG_MMC_SDHCI_OF=y
+ CONFIG_MMC_SDHCI_OF_HLWD=y
+ # CONFIG_MMC_VUB300 is not set
+ # CONFIG_MMC_USHC is not set
+ # CONFIG_MEMSTICK is not set
+ # CONFIG_NEW_LEDS is not set
+ # CONFIG_ACCESSIBILITY is not set
+ # CONFIG_EDAC is not set
+ CONFIG_RTC_LIB=y
  CONFIG_RTC_CLASS=y
+ CONFIG_RTC_HCTOSYS=y
+ CONFIG_RTC_SYSTOHC=y
+ CONFIG_RTC_HCTOSYS_DEVICE="rtc0"
+ # CONFIG_RTC_DEBUG is not set
+ 
+ #
+ # RTC interfaces
+ #
+ CONFIG_RTC_INTF_SYSFS=y
+ CONFIG_RTC_INTF_PROC=y
+ CONFIG_RTC_INTF_DEV=y
+ # CONFIG_RTC_INTF_DEV_UIE_EMUL is not set
+ # CONFIG_RTC_DRV_TEST is not set
+ 
+ #
+ # I2C RTC drivers
+ #
+ # CONFIG_RTC_DRV_DS1307 is not set
+ # CONFIG_RTC_DRV_DS1374 is not set
+ # CONFIG_RTC_DRV_DS1672 is not set
+ # CONFIG_RTC_DRV_DS3232 is not set
+ # CONFIG_RTC_DRV_MAX6900 is not set
+ # CONFIG_RTC_DRV_RS5C372 is not set
+ # CONFIG_RTC_DRV_ISL1208 is not set
+ # CONFIG_RTC_DRV_ISL12022 is not set
+ # CONFIG_RTC_DRV_X1205 is not set
+ # CONFIG_RTC_DRV_PCF2127 is not set
+ # CONFIG_RTC_DRV_PCF8523 is not set
+ # CONFIG_RTC_DRV_PCF8563 is not set
+ # CONFIG_RTC_DRV_PCF8583 is not set
+ # CONFIG_RTC_DRV_M41T80 is not set
+ # CONFIG_RTC_DRV_BQ32K is not set
+ # CONFIG_RTC_DRV_S35390A is not set
+ # CONFIG_RTC_DRV_FM3130 is not set
+ # CONFIG_RTC_DRV_RX8581 is not set
+ # CONFIG_RTC_DRV_RX8025 is not set
+ # CONFIG_RTC_DRV_EM3027 is not set
+ # CONFIG_RTC_DRV_RV3029C2 is not set
+ 
+ #
+ # SPI RTC drivers
+ #
+ 
+ #
+ # Platform RTC drivers
+ #
+ # CONFIG_RTC_DRV_CMOS is not set
+ # CONFIG_RTC_DRV_DS1286 is not set
+ # CONFIG_RTC_DRV_DS1511 is not set
+ # CONFIG_RTC_DRV_DS1553 is not set
+ # CONFIG_RTC_DRV_DS1742 is not set
+ # CONFIG_RTC_DRV_STK17TA8 is not set
+ # CONFIG_RTC_DRV_M48T86 is not set
+ # CONFIG_RTC_DRV_M48T35 is not set
+ # CONFIG_RTC_DRV_M48T59 is not set
+ # CONFIG_RTC_DRV_MSM6242 is not set
+ # CONFIG_RTC_DRV_BQ4802 is not set
+ # CONFIG_RTC_DRV_RP5C01 is not set
+ # CONFIG_RTC_DRV_V3020 is not set
+ # CONFIG_RTC_DRV_DS2404 is not set
+ CONFIG_RTC_DRV_GCN=y
+ 
+ #
+ # on-CPU RTC drivers
+ #
  CONFIG_RTC_DRV_GENERIC=y
+ # CONFIG_RTC_DRV_SNVS is not set
+ # CONFIG_RTC_DRV_MOXART is not set
+ 
+ #
+ # HID Sensor RTC drivers
+ #
+ # CONFIG_RTC_DRV_HID_SENSOR_TIME is not set
+ # CONFIG_DMADEVICES is not set
+ # CONFIG_AUXDISPLAY is not set
+ # CONFIG_UIO is not set
+ # CONFIG_VIRT_DRIVERS is not set
+ 
+ #
+ # Virtio drivers
+ #
+ # CONFIG_VIRTIO_MMIO is not set
+ 
+ #
+ # Microsoft Hyper-V guest support
+ #
+ # CONFIG_STAGING is not set
+ 
+ #
+ # Hardware Spinlock drivers
+ #
+ # CONFIG_MAILBOX is not set
+ CONFIG_IOMMU_SUPPORT=y
+ CONFIG_OF_IOMMU=y
+ 
+ #
+ # Remoteproc drivers
+ #
+ # CONFIG_STE_MODEM_RPROC is not set
+ 
+ #
+ # Rpmsg drivers
+ #
+ # CONFIG_PM_DEVFREQ is not set
+ # CONFIG_EXTCON is not set
+ # CONFIG_MEMORY is not set
+ # CONFIG_IIO is not set
+ # CONFIG_PWM is not set
+ CONFIG_IRQCHIP=y
+ # CONFIG_IPACK_BUS is not set
+ # CONFIG_RESET_CONTROLLER is not set
+ # CONFIG_FMC is not set
+ 
+ #
+ # File systems
+ #
  CONFIG_EXT2_FS=y
! # CONFIG_EXT2_FS_XATTR is not set
! CONFIG_EXT2_FS_XIP=y
! # CONFIG_EXT3_FS is not set
! CONFIG_EXT4_FS=y
! CONFIG_EXT4_USE_FOR_EXT23=y
! # CONFIG_EXT4_FS_POSIX_ACL is not set
! # CONFIG_EXT4_FS_SECURITY is not set
! # CONFIG_EXT4_DEBUG is not set
! CONFIG_FS_XIP=y
! CONFIG_JBD2=y
! # CONFIG_JBD2_DEBUG is not set
! CONFIG_FS_MBCACHE=y
! # CONFIG_REISERFS_FS is not set
! # CONFIG_JFS_FS is not set
! # CONFIG_XFS_FS is not set
! # CONFIG_GFS2_FS is not set
! # CONFIG_BTRFS_FS is not set
! # CONFIG_NILFS2_FS is not set
! # CONFIG_FS_POSIX_ACL is not set
! CONFIG_FILE_LOCKING=y
! CONFIG_FSNOTIFY=y
! CONFIG_DNOTIFY=y
! CONFIG_INOTIFY_USER=y
! # CONFIG_FANOTIFY is not set
! # CONFIG_QUOTA is not set
! # CONFIG_QUOTACTL is not set
! # CONFIG_AUTOFS4_FS is not set
  CONFIG_FUSE_FS=m
+ # CONFIG_CUSE is not set
+ 
+ #
+ # Caches
+ #
+ # CONFIG_FSCACHE is not set
+ 
+ #
+ # CD-ROM/DVD Filesystems
+ #
  CONFIG_ISO9660_FS=y
  CONFIG_JOLIET=y
+ # CONFIG_ZISOFS is not set
+ # CONFIG_UDF_FS is not set
+ 
+ #
+ # DOS/FAT/NT Filesystems
+ #
+ CONFIG_FAT_FS=y
  CONFIG_MSDOS_FS=y
  CONFIG_VFAT_FS=y
+ CONFIG_FAT_DEFAULT_CODEPAGE=437
+ CONFIG_FAT_DEFAULT_IOCHARSET="iso8859-1"
+ # CONFIG_NTFS_FS is not set
+ 
+ #
+ # Pseudo filesystems
+ #
+ CONFIG_PROC_FS=y
  CONFIG_PROC_KCORE=y
+ CONFIG_PROC_SYSCTL=y
  # CONFIG_PROC_PAGE_MONITOR is not set
+ CONFIG_SYSFS=y
  CONFIG_TMPFS=y
+ # CONFIG_TMPFS_POSIX_ACL is not set
+ # CONFIG_TMPFS_XATTR is not set
+ # CONFIG_HUGETLB_PAGE is not set
+ # CONFIG_CONFIGFS_FS is not set
+ CONFIG_MISC_FILESYSTEMS=y
+ # CONFIG_ADFS_FS is not set
+ # CONFIG_AFFS_FS is not set
+ # CONFIG_HFS_FS is not set
+ # CONFIG_HFSPLUS_FS is not set
+ # CONFIG_BEFS_FS is not set
+ # CONFIG_BFS_FS is not set
+ # CONFIG_EFS_FS is not set
+ # CONFIG_LOGFS is not set
+ # CONFIG_CRAMFS is not set
+ # CONFIG_SQUASHFS is not set
+ # CONFIG_VXFS_FS is not set
+ # CONFIG_MINIX_FS is not set
+ # CONFIG_OMFS_FS is not set
+ # CONFIG_HPFS_FS is not set
+ # CONFIG_QNX4FS_FS is not set
+ # CONFIG_QNX6FS_FS is not set
+ # CONFIG_ROMFS_FS is not set
+ # CONFIG_PSTORE is not set
+ # CONFIG_SYSV_FS is not set
+ # CONFIG_UFS_FS is not set
+ # CONFIG_F2FS_FS is not set
+ CONFIG_NETWORK_FILESYSTEMS=y
  CONFIG_NFS_FS=y
+ CONFIG_NFS_V2=y
+ CONFIG_NFS_V3=y
+ # CONFIG_NFS_V3_ACL is not set
+ # CONFIG_NFS_V4 is not set
+ # CONFIG_NFS_SWAP is not set
  CONFIG_ROOT_NFS=y
+ # CONFIG_NFSD is not set
+ CONFIG_LOCKD=y
+ CONFIG_LOCKD_V4=y
+ CONFIG_NFS_COMMON=y
+ CONFIG_SUNRPC=y
+ # CONFIG_SUNRPC_DEBUG is not set
+ # CONFIG_CEPH_FS is not set
  CONFIG_CIFS=m
+ # CONFIG_CIFS_STATS is not set
+ # CONFIG_CIFS_WEAK_PW_HASH is not set
+ # CONFIG_CIFS_XATTR is not set
+ CONFIG_CIFS_DEBUG=y
+ # CONFIG_CIFS_DEBUG2 is not set
+ # CONFIG_CIFS_SMB2 is not set
+ # CONFIG_NCP_FS is not set
+ # CONFIG_CODA_FS is not set
+ # CONFIG_AFS_FS is not set
+ CONFIG_NLS=y
+ CONFIG_NLS_DEFAULT="iso8859-1"
  CONFIG_NLS_CODEPAGE_437=y
+ # CONFIG_NLS_CODEPAGE_737 is not set
+ # CONFIG_NLS_CODEPAGE_775 is not set
+ # CONFIG_NLS_CODEPAGE_850 is not set
+ # CONFIG_NLS_CODEPAGE_852 is not set
+ # CONFIG_NLS_CODEPAGE_855 is not set
+ # CONFIG_NLS_CODEPAGE_857 is not set
+ # CONFIG_NLS_CODEPAGE_860 is not set
+ # CONFIG_NLS_CODEPAGE_861 is not set
+ # CONFIG_NLS_CODEPAGE_862 is not set
+ # CONFIG_NLS_CODEPAGE_863 is not set
+ # CONFIG_NLS_CODEPAGE_864 is not set
+ # CONFIG_NLS_CODEPAGE_865 is not set
+ # CONFIG_NLS_CODEPAGE_866 is not set
+ # CONFIG_NLS_CODEPAGE_869 is not set
+ # CONFIG_NLS_CODEPAGE_936 is not set
+ # CONFIG_NLS_CODEPAGE_950 is not set
+ # CONFIG_NLS_CODEPAGE_932 is not set
+ # CONFIG_NLS_CODEPAGE_949 is not set
+ # CONFIG_NLS_CODEPAGE_874 is not set
+ # CONFIG_NLS_ISO8859_8 is not set
+ # CONFIG_NLS_CODEPAGE_1250 is not set
+ # CONFIG_NLS_CODEPAGE_1251 is not set
+ # CONFIG_NLS_ASCII is not set
  CONFIG_NLS_ISO8859_1=y
+ # CONFIG_NLS_ISO8859_2 is not set
+ # CONFIG_NLS_ISO8859_3 is not set
+ # CONFIG_NLS_ISO8859_4 is not set
+ # CONFIG_NLS_ISO8859_5 is not set
+ # CONFIG_NLS_ISO8859_6 is not set
+ # CONFIG_NLS_ISO8859_7 is not set
+ # CONFIG_NLS_ISO8859_9 is not set
+ # CONFIG_NLS_ISO8859_13 is not set
+ # CONFIG_NLS_ISO8859_14 is not set
+ # CONFIG_NLS_ISO8859_15 is not set
+ # CONFIG_NLS_KOI8_R is not set
+ # CONFIG_NLS_KOI8_U is not set
+ # CONFIG_NLS_MAC_ROMAN is not set
+ # CONFIG_NLS_MAC_CELTIC is not set
+ # CONFIG_NLS_MAC_CENTEURO is not set
+ # CONFIG_NLS_MAC_CROATIAN is not set
+ # CONFIG_NLS_MAC_CYRILLIC is not set
+ # CONFIG_NLS_MAC_GAELIC is not set
+ # CONFIG_NLS_MAC_GREEK is not set
+ # CONFIG_NLS_MAC_ICELAND is not set
+ # CONFIG_NLS_MAC_INUIT is not set
+ # CONFIG_NLS_MAC_ROMANIAN is not set
+ # CONFIG_NLS_MAC_TURKISH is not set
+ # CONFIG_NLS_UTF8 is not set
+ CONFIG_BINARY_PRINTF=y
+ 
+ #
+ # Library routines
+ #
+ CONFIG_BITREVERSE=y
+ CONFIG_GENERIC_STRNCPY_FROM_USER=y
+ CONFIG_GENERIC_STRNLEN_USER=y
+ CONFIG_GENERIC_NET_UTILS=y
+ CONFIG_GENERIC_IO=y
  CONFIG_CRC_CCITT=y
+ CONFIG_CRC16=y
+ # CONFIG_CRC_T10DIF is not set
+ # CONFIG_CRC_ITU_T is not set
+ CONFIG_CRC32=y
+ # CONFIG_CRC32_SELFTEST is not set
+ CONFIG_CRC32_SLICEBY8=y
+ # CONFIG_CRC32_SLICEBY4 is not set
+ # CONFIG_CRC32_SARWATE is not set
+ # CONFIG_CRC32_BIT is not set
+ # CONFIG_CRC7 is not set
+ # CONFIG_LIBCRC32C is not set
+ # CONFIG_CRC8 is not set
+ CONFIG_ZLIB_INFLATE=y
+ # CONFIG_XZ_DEC is not set
+ # CONFIG_XZ_DEC_BCJ is not set
+ CONFIG_DECOMPRESS_GZIP=y
+ CONFIG_HAS_IOMEM=y
+ CONFIG_HAS_IOPORT=y
+ CONFIG_HAS_DMA=y
+ CONFIG_DQL=y
+ CONFIG_NLATTR=y
+ CONFIG_GENERIC_ATOMIC64=y
+ CONFIG_ARCH_HAS_ATOMIC64_DEC_IF_POSITIVE=y
+ CONFIG_AVERAGE=y
+ # CONFIG_CORDIC is not set
+ # CONFIG_DDR is not set
+ CONFIG_FONT_SUPPORT=y
+ CONFIG_FONTS=y
+ # CONFIG_FONT_8x8 is not set
+ CONFIG_FONT_8x16=y
+ # CONFIG_FONT_6x11 is not set
+ # CONFIG_FONT_7x14 is not set
+ # CONFIG_FONT_PEARL_8x8 is not set
+ # CONFIG_FONT_ACORN_8x8 is not set
+ # CONFIG_FONT_MINI_4x6 is not set
+ # CONFIG_FONT_SUN8x16 is not set
+ # CONFIG_FONT_SUN12x22 is not set
+ # CONFIG_FONT_10x18 is not set
+ CONFIG_FONT_AUTOSELECT=y
+ 
+ #
+ # Kernel hacking
+ #
+ 
+ #
+ # printk and dmesg options
+ #
  CONFIG_PRINTK_TIME=y
+ CONFIG_DEFAULT_MESSAGE_LOGLEVEL=4
+ # CONFIG_DYNAMIC_DEBUG is not set
+ 
+ #
+ # Compile-time checks and compiler options
+ #
+ # CONFIG_DEBUG_INFO is not set
+ CONFIG_ENABLE_WARN_DEPRECATED=y
+ CONFIG_ENABLE_MUST_CHECK=y
+ CONFIG_FRAME_WARN=1024
+ # CONFIG_STRIP_ASM_SYMS is not set
+ # CONFIG_READABLE_ASM is not set
+ # CONFIG_UNUSED_SYMBOLS is not set
+ CONFIG_DEBUG_FS=y
+ # CONFIG_HEADERS_CHECK is not set
+ # CONFIG_DEBUG_SECTION_MISMATCH is not set
+ # CONFIG_DEBUG_FORCE_WEAK_PER_CPU is not set
  CONFIG_MAGIC_SYSRQ=y
+ CONFIG_DEBUG_KERNEL=y
+ 
+ #
+ # Memory Debugging
+ #
+ # CONFIG_DEBUG_PAGEALLOC is not set
+ # CONFIG_DEBUG_OBJECTS is not set
+ # CONFIG_DEBUG_SLAB is not set
+ CONFIG_HAVE_DEBUG_KMEMLEAK=y
+ # CONFIG_DEBUG_KMEMLEAK is not set
+ # CONFIG_DEBUG_STACK_USAGE is not set
+ # CONFIG_DEBUG_VM is not set
+ # CONFIG_DEBUG_MEMORY_INIT is not set
+ CONFIG_HAVE_DEBUG_STACKOVERFLOW=y
+ # CONFIG_DEBUG_STACKOVERFLOW is not set
+ # CONFIG_DEBUG_SHIRQ is not set
+ 
+ #
+ # Debug Lockups and Hangs
+ #
+ # CONFIG_LOCKUP_DETECTOR is not set
+ # CONFIG_DETECT_HUNG_TASK is not set
+ # CONFIG_PANIC_ON_OOPS is not set
+ CONFIG_PANIC_ON_OOPS_VALUE=0
+ CONFIG_SCHED_DEBUG=y
+ CONFIG_SCHEDSTATS=y
+ # CONFIG_TIMER_STATS is not set
+ CONFIG_DEBUG_PREEMPT=y
+ 
+ #
+ # Lock Debugging (spinlocks, mutexes, etc...)
+ #
+ # CONFIG_DEBUG_RT_MUTEXES is not set
+ # CONFIG_RT_MUTEX_TESTER is not set
  CONFIG_DEBUG_SPINLOCK=y
  CONFIG_DEBUG_MUTEXES=y
+ # CONFIG_DEBUG_WW_MUTEX_SLOWPATH is not set
+ # CONFIG_DEBUG_LOCK_ALLOC is not set
+ # CONFIG_PROVE_LOCKING is not set
+ # CONFIG_LOCK_STAT is not set
+ # CONFIG_DEBUG_ATOMIC_SLEEP is not set
+ # CONFIG_DEBUG_LOCKING_API_SELFTESTS is not set
+ CONFIG_STACKTRACE=y
+ # CONFIG_DEBUG_KOBJECT is not set
+ CONFIG_DEBUG_BUGVERBOSE=y
+ # CONFIG_DEBUG_WRITECOUNT is not set
+ # CONFIG_DEBUG_LIST is not set
+ # CONFIG_DEBUG_SG is not set
+ # CONFIG_DEBUG_NOTIFIERS is not set
+ # CONFIG_DEBUG_CREDENTIALS is not set
+ 
+ #
+ # RCU Debugging
+ #
+ # CONFIG_PROVE_RCU_DELAY is not set
+ # CONFIG_SPARSE_RCU_POINTER is not set
+ # CONFIG_RCU_TORTURE_TEST is not set
+ CONFIG_RCU_CPU_STALL_TIMEOUT=21
+ CONFIG_RCU_CPU_STALL_VERBOSE=y
+ # CONFIG_RCU_CPU_STALL_INFO is not set
+ # CONFIG_RCU_TRACE is not set
+ # CONFIG_DEBUG_BLOCK_EXT_DEVT is not set
+ # CONFIG_NOTIFIER_ERROR_INJECTION is not set
+ # CONFIG_FAULT_INJECTION is not set
  CONFIG_LATENCYTOP=y
+ CONFIG_NOP_TRACER=y
+ CONFIG_HAVE_FUNCTION_TRACER=y
+ CONFIG_HAVE_FUNCTION_GRAPH_TRACER=y
+ CONFIG_HAVE_DYNAMIC_FTRACE=y
+ CONFIG_HAVE_FTRACE_MCOUNT_RECORD=y
+ CONFIG_HAVE_SYSCALL_TRACEPOINTS=y
+ CONFIG_TRACER_MAX_TRACE=y
+ CONFIG_TRACE_CLOCK=y
+ CONFIG_RING_BUFFER=y
+ CONFIG_EVENT_TRACING=y
+ CONFIG_CONTEXT_SWITCH_TRACER=y
+ CONFIG_TRACING=y
+ CONFIG_GENERIC_TRACER=y
+ CONFIG_TRACING_SUPPORT=y
+ CONFIG_FTRACE=y
+ # CONFIG_FUNCTION_TRACER is not set
+ # CONFIG_IRQSOFF_TRACER is not set
+ # CONFIG_PREEMPT_TRACER is not set
  CONFIG_SCHED_TRACER=y
+ # CONFIG_FTRACE_SYSCALLS is not set
+ CONFIG_TRACER_SNAPSHOT=y
+ # CONFIG_TRACER_SNAPSHOT_PER_CPU_SWAP is not set
+ CONFIG_BRANCH_PROFILE_NONE=y
+ # CONFIG_PROFILE_ANNOTATED_BRANCHES is not set
+ # CONFIG_PROFILE_ALL_BRANCHES is not set
+ # CONFIG_STACK_TRACER is not set
  CONFIG_BLK_DEV_IO_TRACE=y
+ # CONFIG_UPROBE_EVENT is not set
+ # CONFIG_PROBE_EVENTS is not set
+ # CONFIG_FTRACE_STARTUP_TEST is not set
+ # CONFIG_RING_BUFFER_BENCHMARK is not set
+ # CONFIG_RING_BUFFER_STARTUP_TEST is not set
+ 
+ #
+ # Runtime Testing
+ #
+ # CONFIG_LKDTM is not set
+ # CONFIG_TEST_LIST_SORT is not set
+ # CONFIG_BACKTRACE_SELF_TEST is not set
+ # CONFIG_RBTREE_TEST is not set
+ # CONFIG_INTERVAL_TREE_TEST is not set
+ # CONFIG_ATOMIC64_SELFTEST is not set
+ # CONFIG_TEST_STRING_HELPERS is not set
+ # CONFIG_TEST_KSTRTOX is not set
  CONFIG_DMA_API_DEBUG=y
+ # CONFIG_SAMPLES is not set
+ CONFIG_HAVE_ARCH_KGDB=y
+ # CONFIG_KGDB is not set
+ # CONFIG_PPC_DISABLE_WERROR is not set
+ CONFIG_PPC_WERROR=y
+ CONFIG_PRINT_STACK_DEPTH=64
+ # CONFIG_PPC_EMULATED_STATS is not set
+ # CONFIG_CODE_PATCHING_SELFTEST is not set
+ # CONFIG_FTR_FIXUP_SELFTEST is not set
+ # CONFIG_MSI_BITMAP_SELFTEST is not set
+ # CONFIG_XMON is not set
+ # CONFIG_BDI_SWITCH is not set
+ # CONFIG_BOOTX_TEXT is not set
  CONFIG_PPC_EARLY_DEBUG=y
+ CONFIG_PPC_EARLY_DEBUG_MEMCONS=y
+ CONFIG_PPC_MEMCONS_OUTPUT_SIZE=4096
+ CONFIG_PPC_MEMCONS_INPUT_SIZE=128
+ CONFIG_STRICT_DEVMEM=y
+ 
+ #
+ # Security options
+ #
+ # CONFIG_KEYS is not set
+ # CONFIG_SECURITY_DMESG_RESTRICT is not set
+ # CONFIG_SECURITY is not set
+ # CONFIG_SECURITYFS is not set
+ CONFIG_DEFAULT_SECURITY_DAC=y
+ CONFIG_DEFAULT_SECURITY=""
+ CONFIG_CRYPTO=y
+ 
+ #
+ # Crypto core or helper
+ #
+ CONFIG_CRYPTO_ALGAPI=y
+ CONFIG_CRYPTO_ALGAPI2=y
+ CONFIG_CRYPTO_AEAD2=y
+ CONFIG_CRYPTO_BLKCIPHER=y
+ CONFIG_CRYPTO_BLKCIPHER2=y
+ CONFIG_CRYPTO_HASH=y
+ CONFIG_CRYPTO_HASH2=y
+ CONFIG_CRYPTO_RNG2=y
+ CONFIG_CRYPTO_PCOMP2=y
+ CONFIG_CRYPTO_MANAGER=y
+ CONFIG_CRYPTO_MANAGER2=y
+ # CONFIG_CRYPTO_USER is not set
+ CONFIG_CRYPTO_MANAGER_DISABLE_TESTS=y
+ # CONFIG_CRYPTO_GF128MUL is not set
+ # CONFIG_CRYPTO_NULL is not set
+ CONFIG_CRYPTO_WORKQUEUE=y
+ # CONFIG_CRYPTO_CRYPTD is not set
+ # CONFIG_CRYPTO_AUTHENC is not set
+ # CONFIG_CRYPTO_TEST is not set
+ 
+ #
+ # Authenticated Encryption with Associated Data
+ #
+ # CONFIG_CRYPTO_CCM is not set
+ # CONFIG_CRYPTO_GCM is not set
+ # CONFIG_CRYPTO_SEQIV is not set
+ 
+ #
+ # Block modes
+ #
+ # CONFIG_CRYPTO_CBC is not set
+ # CONFIG_CRYPTO_CTR is not set
+ # CONFIG_CRYPTO_CTS is not set
+ CONFIG_CRYPTO_ECB=y
+ # CONFIG_CRYPTO_LRW is not set
+ # CONFIG_CRYPTO_PCBC is not set
+ # CONFIG_CRYPTO_XTS is not set
+ 
+ #
+ # Hash modes
+ #
+ CONFIG_CRYPTO_CMAC=m
+ CONFIG_CRYPTO_HMAC=m
+ # CONFIG_CRYPTO_XCBC is not set
+ # CONFIG_CRYPTO_VMAC is not set
+ 
+ #
+ # Digest
+ #
+ CONFIG_CRYPTO_CRC32C=y
+ # CONFIG_CRYPTO_CRC32 is not set
+ # CONFIG_CRYPTO_CRCT10DIF is not set
+ # CONFIG_CRYPTO_GHASH is not set
+ CONFIG_CRYPTO_MD4=m
+ CONFIG_CRYPTO_MD5=m
+ # CONFIG_CRYPTO_MICHAEL_MIC is not set
+ # CONFIG_CRYPTO_RMD128 is not set
+ # CONFIG_CRYPTO_RMD160 is not set
+ # CONFIG_CRYPTO_RMD256 is not set
+ # CONFIG_CRYPTO_RMD320 is not set
+ # CONFIG_CRYPTO_SHA1 is not set
+ # CONFIG_CRYPTO_SHA1_PPC is not set
+ CONFIG_CRYPTO_SHA256=y
+ # CONFIG_CRYPTO_SHA512 is not set
+ # CONFIG_CRYPTO_TGR192 is not set
+ # CONFIG_CRYPTO_WP512 is not set
+ 
+ #
+ # Ciphers
+ #
+ CONFIG_CRYPTO_AES=y
+ # CONFIG_CRYPTO_ANUBIS is not set
+ CONFIG_CRYPTO_ARC4=y
+ # CONFIG_CRYPTO_BLOWFISH is not set
+ # CONFIG_CRYPTO_CAMELLIA is not set
+ # CONFIG_CRYPTO_CAST5 is not set
+ # CONFIG_CRYPTO_CAST6 is not set
+ CONFIG_CRYPTO_DES=m
+ # CONFIG_CRYPTO_FCRYPT is not set
+ # CONFIG_CRYPTO_KHAZAD is not set
+ # CONFIG_CRYPTO_SALSA20 is not set
+ # CONFIG_CRYPTO_SEED is not set
+ # CONFIG_CRYPTO_SERPENT is not set
+ # CONFIG_CRYPTO_TEA is not set
+ # CONFIG_CRYPTO_TWOFISH is not set
+ 
+ #
+ # Compression
+ #
+ # CONFIG_CRYPTO_DEFLATE is not set
+ # CONFIG_CRYPTO_ZLIB is not set
+ # CONFIG_CRYPTO_LZO is not set
+ # CONFIG_CRYPTO_LZ4 is not set
+ # CONFIG_CRYPTO_LZ4HC is not set
+ 
+ #
+ # Random Number Generation
+ #
  # CONFIG_CRYPTO_ANSI_CPRNG is not set
+ # CONFIG_CRYPTO_USER_API_HASH is not set
+ # CONFIG_CRYPTO_USER_API_SKCIPHER is not set
  # CONFIG_CRYPTO_HW is not set
+ # CONFIG_PPC_CLOCK is not set
+ # CONFIG_VIRTUALIZATION is not set
diff -crB /home/rxtx/Desktop/linux-4.3.3/arch/powerpc/mm/pgtable_32.c ./arch/powerpc/mm/pgtable_32.c
*** /home/rxtx/Desktop/linux-4.3.3/arch/powerpc/mm/pgtable_32.c	2015-12-15 16:41:43.000000000 +1100
--- ./arch/powerpc/mm/pgtable_32.c	2015-12-19 19:20:14.232889632 +1100
***************
*** 41,47 ****
  unsigned long ioremap_bot;
  EXPORT_SYMBOL(ioremap_bot);	/* aka VMALLOC_END */
  
! #ifdef CONFIG_6xx
  #define HAVE_BATS	1
  #endif
  
--- 41,47 ----
  unsigned long ioremap_bot;
  EXPORT_SYMBOL(ioremap_bot);	/* aka VMALLOC_END */
  
! #if defined(CONFIG_6xx) || defined(CONFIG_POWER3)
  #define HAVE_BATS	1
  #endif
  
***************
*** 54,65 ****
--- 54,69 ----
  #ifdef HAVE_BATS
  extern phys_addr_t v_mapped_by_bats(unsigned long va);
  extern unsigned long p_mapped_by_bats(phys_addr_t pa);
+ void setbat(int index, unsigned long virt, phys_addr_t phys,
+ 	    unsigned int size, int flags);
+ 
  #else /* !HAVE_BATS */
  #define v_mapped_by_bats(x)	(0UL)
  #define p_mapped_by_bats(x)	(0UL)
  #endif /* HAVE_BATS */
  
  #ifdef HAVE_TLBCAM
+ extern unsigned int tlbcam_index;
  extern phys_addr_t v_mapped_by_tlbcam(unsigned long va);
  extern unsigned long p_mapped_by_tlbcam(phys_addr_t pa);
  #else /* !HAVE_TLBCAM */
***************
*** 69,93 ****
  
  #define PGDIR_ORDER	(32 + PGD_T_LOG2 - PGDIR_SHIFT)
  
- #ifndef CONFIG_PPC_4K_PAGES
- static struct kmem_cache *pgtable_cache;
- 
- void pgtable_cache_init(void)
- {
- 	pgtable_cache = kmem_cache_create("PGDIR cache", 1 << PGDIR_ORDER,
- 					  1 << PGDIR_ORDER, 0, NULL);
- 	if (pgtable_cache == NULL)
- 		panic("Couldn't allocate pgtable caches");
- }
- #endif
- 
  pgd_t *pgd_alloc(struct mm_struct *mm)
  {
  	pgd_t *ret;
  
  	/* pgdir take page or two with 4K pages and a page fraction otherwise */
  #ifndef CONFIG_PPC_4K_PAGES
! 	ret = kmem_cache_alloc(pgtable_cache, GFP_KERNEL | __GFP_ZERO);
  #else
  	ret = (pgd_t *)__get_free_pages(GFP_KERNEL|__GFP_ZERO,
  			PGDIR_ORDER - PAGE_SHIFT);
--- 73,85 ----
  
  #define PGDIR_ORDER	(32 + PGD_T_LOG2 - PGDIR_SHIFT)
  
  pgd_t *pgd_alloc(struct mm_struct *mm)
  {
  	pgd_t *ret;
  
  	/* pgdir take page or two with 4K pages and a page fraction otherwise */
  #ifndef CONFIG_PPC_4K_PAGES
! 	ret = kzalloc(1 << PGDIR_ORDER, GFP_KERNEL);
  #else
  	ret = (pgd_t *)__get_free_pages(GFP_KERNEL|__GFP_ZERO,
  			PGDIR_ORDER - PAGE_SHIFT);
***************
*** 98,104 ****
  void pgd_free(struct mm_struct *mm, pgd_t *pgd)
  {
  #ifndef CONFIG_PPC_4K_PAGES
! 	kmem_cache_free(pgtable_cache, (void *)pgd);
  #else
  	free_pages((unsigned long)pgd, PGDIR_ORDER - PAGE_SHIFT);
  #endif
--- 90,96 ----
  void pgd_free(struct mm_struct *mm, pgd_t *pgd)
  {
  #ifndef CONFIG_PPC_4K_PAGES
! 	kfree((void *)pgd);
  #else
  	free_pages((unsigned long)pgd, PGDIR_ORDER - PAGE_SHIFT);
  #endif
***************
*** 107,117 ****
  __init_refok pte_t *pte_alloc_one_kernel(struct mm_struct *mm, unsigned long address)
  {
  	pte_t *pte;
  
! 	if (slab_is_available()) {
  		pte = (pte_t *)__get_free_page(GFP_KERNEL|__GFP_REPEAT|__GFP_ZERO);
  	} else {
! 		pte = __va(memblock_alloc(PAGE_SIZE, PAGE_SIZE));
  		if (pte)
  			clear_page(pte);
  	}
--- 99,111 ----
  __init_refok pte_t *pte_alloc_one_kernel(struct mm_struct *mm, unsigned long address)
  {
  	pte_t *pte;
+ 	extern int mem_init_done;
+ 	extern void *early_get_page(void);
  
! 	if (mem_init_done) {
  		pte = (pte_t *)__get_free_page(GFP_KERNEL|__GFP_REPEAT|__GFP_ZERO);
  	} else {
! 		pte = (pte_t *)early_get_page();
  		if (pte)
  			clear_page(pte);
  	}
***************
*** 127,136 ****
  	ptepage = alloc_pages(flags, 0);
  	if (!ptepage)
  		return NULL;
! 	if (!pgtable_page_ctor(ptepage)) {
! 		__free_page(ptepage);
! 		return NULL;
! 	}
  	return ptepage;
  }
  
--- 121,127 ----
  	ptepage = alloc_pages(flags, 0);
  	if (!ptepage)
  		return NULL;
! 	pgtable_page_ctor(ptepage);
  	return ptepage;
  }
  
***************
*** 154,160 ****
  ioremap_prot(phys_addr_t addr, unsigned long size, unsigned long flags)
  {
  	/* writeable implies dirty for kernel addresses */
! 	if ((flags & (_PAGE_RW | _PAGE_RO)) != _PAGE_RO)
  		flags |= _PAGE_DIRTY | _PAGE_HWWRITE;
  
  	/* we don't want to let _PAGE_USER and _PAGE_EXEC leak out */
--- 145,151 ----
  ioremap_prot(phys_addr_t addr, unsigned long size, unsigned long flags)
  {
  	/* writeable implies dirty for kernel addresses */
! 	if (flags & _PAGE_RW)
  		flags |= _PAGE_DIRTY | _PAGE_HWWRITE;
  
  	/* we don't want to let _PAGE_USER and _PAGE_EXEC leak out */
***************
*** 188,194 ****
  
  	/* Make sure we have the base flags */
  	if ((flags & _PAGE_PRESENT) == 0)
! 		flags |= pgprot_val(PAGE_KERNEL);
  
  	/* Non-cacheable page cannot be coherent */
  	if (flags & _PAGE_NO_CACHE)
--- 179,185 ----
  
  	/* Make sure we have the base flags */
  	if ((flags & _PAGE_PRESENT) == 0)
! 		flags |= PAGE_KERNEL;
  
  	/* Non-cacheable page cannot be coherent */
  	if (flags & _PAGE_NO_CACHE)
***************
*** 215,225 ****
  	 * Don't allow anybody to remap normal RAM that we're using.
  	 * mem_init() sets high_memory so only do the check after that.
  	 */
! 	if (slab_is_available() && (p < virt_to_phys(high_memory)) &&
! 	    !(__allow_ioremap_reserved && memblock_is_region_reserved(p, size))) {
! 		printk("__ioremap(): phys addr 0x%llx is RAM lr %ps\n",
! 		       (unsigned long long)p, __builtin_return_address(0));
! 		return NULL;
  	}
  #endif
  
--- 206,225 ----
  	 * Don't allow anybody to remap normal RAM that we're using.
  	 * mem_init() sets high_memory so only do the check after that.
  	 */
! 	if (mem_init_done && (p < virt_to_phys(high_memory))) {
! 		/*
! 		 * On some systems, though, we may want to remap normal RAM
! 		 * that we have memreserve'd at the device tree.
! 		 * But we can't do that safely if we are using BATs.
! 		 *
! 		 */
! 		if (!__map_without_bats) {
! 			printk(KERN_WARNING
! 			       "__ioremap(): phys addr 0x%llx is RAM lr %pf\n",
! 			       (unsigned long long)p,
! 				 __builtin_return_address(0));
! 			return NULL;
! 		}
  	}
  #endif
  
***************
*** 243,249 ****
  	if ((v = p_mapped_by_tlbcam(p)))
  		goto out;
  
! 	if (slab_is_available()) {
  		struct vm_struct *area;
  		area = get_vm_area_caller(size, VM_IOREMAP, caller);
  		if (area == 0)
--- 243,249 ----
  	if ((v = p_mapped_by_tlbcam(p)))
  		goto out;
  
! 	if (mem_init_done) {
  		struct vm_struct *area;
  		area = get_vm_area_caller(size, VM_IOREMAP, caller);
  		if (area == 0)
***************
*** 262,268 ****
  	for (i = 0; i < size && err == 0; i += PAGE_SIZE)
  		err = map_page(v+i, p+i, flags);
  	if (err) {
! 		if (slab_is_available())
  			vunmap((void *)v);
  		return NULL;
  	}
--- 262,268 ----
  	for (i = 0; i < size && err == 0; i += PAGE_SIZE)
  		err = map_page(v+i, p+i, flags);
  	if (err) {
! 		if (mem_init_done)
  			vunmap((void *)v);
  		return NULL;
  	}
***************
*** 305,311 ****
  		set_pte_at(&init_mm, va, pg, pfn_pte(pa >> PAGE_SHIFT,
  						     __pgprot(flags)));
  	}
- 	smp_wmb();
  	return err;
  }
  
--- 305,310 ----
***************
*** 323,329 ****
  	p = memstart_addr + s;
  	for (; s < top; s += PAGE_SIZE) {
  		ktext = ((char *) v >= _stext && (char *) v < etext);
! 		f = ktext ? pgprot_val(PAGE_KERNEL_TEXT) : pgprot_val(PAGE_KERNEL);
  		map_page(v, p, f);
  #ifdef CONFIG_PPC_STD_MMU_32
  		if (ktext)
--- 322,328 ----
  	p = memstart_addr + s;
  	for (; s < top; s += PAGE_SIZE) {
  		ktext = ((char *) v >= _stext && (char *) v < etext);
! 		f = ktext ? PAGE_KERNEL_TEXT : PAGE_KERNEL;
  		map_page(v, p, f);
  #ifdef CONFIG_PPC_STD_MMU_32
  		if (ktext)
***************
*** 436,442 ****
  }
  
  
! void __kernel_map_pages(struct page *page, int numpages, int enable)
  {
  	if (PageHighMem(page))
  		return;
--- 435,441 ----
  }
  
  
! void kernel_map_pages(struct page *page, int numpages, int enable)
  {
  	if (PageHighMem(page))
  		return;
diff -crB /home/rxtx/Desktop/linux-4.3.3/arch/powerpc/platforms/embedded6xx/Makefile ./arch/powerpc/platforms/embedded6xx/Makefile
*** /home/rxtx/Desktop/linux-4.3.3/arch/powerpc/platforms/embedded6xx/Makefile	2015-12-15 16:41:43.000000000 +1100
--- ./arch/powerpc/platforms/embedded6xx/Makefile	2015-12-19 19:21:06.032691619 +1100
***************
*** 5,13 ****
  obj-$(CONFIG_LINKSTATION)	+= linkstation.o ls_uart.o
  obj-$(CONFIG_STORCENTER)	+= storcenter.o
  obj-$(CONFIG_PPC_HOLLY)		+= holly.o
  obj-$(CONFIG_PPC_C2K)		+= c2k.o
  obj-$(CONFIG_USBGECKO_UDBG)	+= usbgecko_udbg.o
  obj-$(CONFIG_GAMECUBE_COMMON)	+= flipper-pic.o
  obj-$(CONFIG_GAMECUBE)		+= gamecube.o
! obj-$(CONFIG_WII)		+= wii.o hlwd-pic.o
! obj-$(CONFIG_MVME5100)		+= mvme5100.o
--- 5,20 ----
  obj-$(CONFIG_LINKSTATION)	+= linkstation.o ls_uart.o
  obj-$(CONFIG_STORCENTER)	+= storcenter.o
  obj-$(CONFIG_PPC_HOLLY)		+= holly.o
+ obj-$(CONFIG_PPC_PRPMC2800)	+= prpmc2800.o
  obj-$(CONFIG_PPC_C2K)		+= c2k.o
+ obj-$(CONFIG_GAMECUBE_VIDEO_UDBG)	+= gcnvi_udbg.o
+ obj-$(CONFIG_GAMECUBE_RSW)	+= gcn-rsw.o
  obj-$(CONFIG_USBGECKO_UDBG)	+= usbgecko_udbg.o
  obj-$(CONFIG_GAMECUBE_COMMON)	+= flipper-pic.o
  obj-$(CONFIG_GAMECUBE)		+= gamecube.o
! obj-$(CONFIG_WII)		+= wii.o
! obj-$(CONFIG_HLWD_PIC)		+= hlwd-pic.o
! obj-$(CONFIG_HLWD_GPIO)		+= hlwd-gpio.o
! obj-$(CONFIG_STARLET_MINI)	+= starlet-mipc.o
! obj-$(CONFIG_STARLET_IOS)	+= starlet-ipc.o starlet-malloc.o \
! 					starlet-stm.o starlet-es.o
diff -crB /home/rxtx/Desktop/linux-4.3.3/arch/powerpc/platforms/embedded6xx/wii.c ./arch/powerpc/platforms/embedded6xx/wii.c
*** /home/rxtx/Desktop/linux-4.3.3/arch/powerpc/platforms/embedded6xx/wii.c	2015-12-15 16:41:43.000000000 +1100
--- ./arch/powerpc/platforms/embedded6xx/wii.c	2015-12-19 19:21:46.188574064 +1100
***************
*** 18,35 ****
--- 18,42 ----
  #include <linux/init.h>
  #include <linux/irq.h>
  #include <linux/seq_file.h>
+ #include <linux/kexec.h>
  #include <linux/of_platform.h>
  #include <linux/memblock.h>
  #include <mm/mmu_decl.h>
+ #include <linux/exi.h>
+ #include <linux/gpio.h>
  
  #include <asm/io.h>
  #include <asm/machdep.h>
  #include <asm/prom.h>
  #include <asm/time.h>
+ #include <asm/starlet.h>
+ #include <asm/starlet-ios.h>
+ #include <asm/starlet-mini.h>
  #include <asm/udbg.h>
  
  #include "flipper-pic.h"
  #include "hlwd-pic.h"
+ #include "gcnvi_udbg.h"
  #include "usbgecko_udbg.h"
  
  /* control block */
***************
*** 56,61 ****
--- 63,70 ----
  unsigned long wii_hole_start;
  unsigned long wii_hole_size;
  
+ static enum starlet_ipc_flavour starlet_ipc_flavour;
+ 
  
  static int __init page_aligned(unsigned long x)
  {
***************
*** 158,165 ****
--- 167,208 ----
  		clrbits32(hw_gpio + HW_GPIO_OUT(0),
  			  HW_GPIO_SLOT_LED | HW_GPIO_SENSOR_BAR);
  	}
+ 
+ 	ug_udbg_init();
+ 	gcnvi_udbg_init();
+ 	starlet_discover_ipc_flavour();
  }
  
+ #ifdef CONFIG_STARLET_IOS
+ static void wii_restart(char *cmd)
+ {
+ 	local_irq_disable();
+ 
+ 	/* try first to launch The Homebrew Channel... */
+ 	starlet_es_reload_ios_and_launch(STARLET_TITLE_HBC_V107);
+ 	starlet_es_reload_ios_and_launch(STARLET_TITLE_HBC_JODI);
+ 	starlet_es_reload_ios_and_launch(STARLET_TITLE_HBC_HAXX);
+ 	/* ..and if that fails, try an assisted restart */
+ 	starlet_stm_restart();
+ 
+ 	/* fallback to spinning until the power button pressed */
+ 	for (;;)
+ 		cpu_relax();
+  }
+ 
+ static void wii_power_off(void)
+ {
+ 	local_irq_disable();
+ 
+ 	/* try an assisted poweroff */
+ 	starlet_stm_power_off();
+ 
+ 	/* fallback to spinning until the power button pressed */
+ 	for (;;)
+ 		cpu_relax();
+ }
+ 
+ #elif defined CONFIG_STARLET_MINI /* end of CONFIG_STARLET_IOS */
  static void wii_restart(char *cmd)
  {
  	local_irq_disable();
***************
*** 184,189 ****
--- 227,233 ----
  	}
  	wii_spin();
  }
+ #endif /* CONFIG_STARLET_MINI */
  
  static void wii_halt(void)
  {
***************
*** 200,206 ****
--- 244,252 ----
  static void __init wii_pic_probe(void)
  {
  	flipper_pic_probe();
+ #ifdef CONFIG_HLWD_PIC
  	hlwd_pic_probe();
+ #endif
  }
  
  static int __init wii_probe(void)
***************
*** 211,224 ****
  	if (!of_flat_dt_is_compatible(dt_root, "nintendo,wii"))
  		return 0;
  
- 	pm_power_off = wii_power_off;
- 
  	return 1;
  }
  
  static void wii_shutdown(void)
  {
  	hlwd_quiesce();
  	flipper_quiesce();
  }
  
--- 257,376 ----
  	if (!of_flat_dt_is_compatible(dt_root, "nintendo,wii"))
  		return 0;
  
  	return 1;
  }
  
+ static void wii_show_cpuinfo(struct seq_file *m)
+ {
+ 	seq_printf(m, "vendor\t\t: IBM\n");
+ 	seq_printf(m, "machine\t\t: Nintendo Wii\n");
+ }
+ 
+ int starlet_discover_ipc_flavour(void)
+ {
+ 	struct mipc_infohdr *hdrp;
+ 	int error;
+ 
+ 	error = mipc_discover(&hdrp);
+ 
+ 	if (!error) {
+ 		starlet_ipc_flavour = STARLET_IPC_MINI;
+ 	} else {
+ 		starlet_ipc_flavour = STARLET_IPC_IOS;
+ 	}
+ 
+ 	ppc_md.restart = wii_restart;
+ 	ppc_md.power_off = wii_power_off;
+ 
+ 	return 0;
+ }
+ 
+ enum starlet_ipc_flavour starlet_get_ipc_flavour(void)
+ {
+ 	return starlet_ipc_flavour;
+ }
+ 
+ #ifdef CONFIG_KEXEC
+ 
+ static int restore_lowmem_stub(struct kimage *image)
+ {
+ 	struct device_node *node;
+ 	struct resource res;
+ 	const unsigned long *prop;
+ 	unsigned long dst, src;
+ 	size_t size;
+ 	int error;
+ 
+ 	node = of_find_node_by_name(NULL, "lowmem-stub");
+ 	if (!node) {
+ 		printk(KERN_ERR "unable to find node %s\n", "lowmem-stub");
+ 		error = -ENODEV;
+ 		goto out;
+ 	}
+ 
+ 	error = of_address_to_resource(node, 0, &res);
+ 	if (error) {
+ 		printk(KERN_ERR "no lowmem-stub range found\n");
+ 	  goto out_put;
+ 	}
+ 	dst = res.start;
+ 	size = res.end - res.start + 1;
+ 
+ 	prop = of_get_property(node, "save-area", NULL);
+ 	if (!prop) {
+ 		printk(KERN_ERR "unable to find %s property\n", "save-area");
+ 		error = -EINVAL;
+ 		goto out_put;
+ 	}
+ 	src = *prop;
+ 
+ 	printk(KERN_DEBUG "lowmem-stub: preparing restore from %08lX to %08lX"
+ 		" (%u bytes)\n", src, dst, size);
+ 
+ 	/* schedule a copy of the lowmem stub to its original location */
+ 	error = kimage_add_preserved_region(image, dst, src, PAGE_ALIGN(size));
+ 
+ out_put:
+ 	of_node_put(node);
+ out:
+ 	return error;
+ }
+ 
+ static int wii_machine_kexec_prepare(struct kimage *image)
+ {
+ 	int error;
+ 
+ 	error = restore_lowmem_stub(image);
+ 	if (error)
+ 		printk(KERN_ERR "%s: error %d\n", __func__, error);
+ 	return error;
+ }
+ 
+ static void wii_machine_kexec(struct kimage *image)
+ {
+ 	local_irq_disable();
+ 
+ #ifdef CONFIG_STARLET_IOS
+ 	/*
+ 	 * Reload IOS to make sure that I/O resources are freed before
+ 	 * the final kexec phase.
+ 	 */
+ 	if (starlet_get_ipc_flavour() == STARLET_IPC_IOS)
+ 		starlet_es_reload_ios_and_discard();
+ #endif
+ 
+ 	default_machine_kexec(image);
+ }
+ 
+ #endif /* CONFIG_KEXEC */
+ 
+ 
  static void wii_shutdown(void)
  {
+ #ifdef CONFIG_HLWD_PIC
  	hlwd_quiesce();
+ #endif
+ 	exi_quiesce();
  	flipper_quiesce();
  }
  
***************
*** 228,252 ****
  	.init_early		= wii_init_early,
  	.setup_arch		= wii_setup_arch,
  	.restart		= wii_restart,
  	.halt			= wii_halt,
  	.init_IRQ		= wii_pic_probe,
  	.get_irq		= flipper_pic_get_irq,
  	.calibrate_decr		= generic_calibrate_decr,
  	.progress		= udbg_progress,
  	.machine_shutdown	= wii_shutdown,
  };
  
! static const struct of_device_id wii_of_bus[] = {
  	{ .compatible = "nintendo,hollywood", },
  	{ },
  };
  
  static int __init wii_device_probe(void)
  {
  	if (!machine_is(wii))
  		return 0;
  
  	of_platform_bus_probe(NULL, wii_of_bus, NULL);
  	return 0;
  }
  device_initcall(wii_device_probe);
--- 380,425 ----
  	.init_early		= wii_init_early,
  	.setup_arch		= wii_setup_arch,
  	.restart		= wii_restart,
+ 	.power_off		= wii_power_off,
+ 	.show_cpuinfo		= wii_show_cpuinfo,
  	.halt			= wii_halt,
  	.init_IRQ		= wii_pic_probe,
  	.get_irq		= flipper_pic_get_irq,
  	.calibrate_decr		= generic_calibrate_decr,
  	.progress		= udbg_progress,
  	.machine_shutdown	= wii_shutdown,
+ #ifdef CONFIG_KEXEC	/* REMOVE THIS (as of 2.6.39)? */
+ 	.machine_kexec_prepare	= wii_machine_kexec_prepare,
+ 	.machine_kexec		= wii_machine_kexec,
+ #endif
  };
  
! static struct of_device_id wii_of_bus[] = {
  	{ .compatible = "nintendo,hollywood", },
+ #ifdef CONFIG_STARLET_IOS
+ 	{ .compatible = "nintendo,starlet-ios-ipc", },
+ #endif
+ #ifdef CONFIG_STARLET_MINI
+ 	{ .compatible = "twiizers,starlet-mini-ipc", },
+ #endif
  	{ },
  };
  
  static int __init wii_device_probe(void)
  {
+ 	struct device_node *np;
+ 
  	if (!machine_is(wii))
  		return 0;
  
  	of_platform_bus_probe(NULL, wii_of_bus, NULL);
+ 
+ 	np = of_find_compatible_node(NULL, NULL, "nintendo,hollywood-mem2");
+ 	if (np) {
+ 		of_platform_device_create(np, NULL, NULL);
+ 		of_node_put(np);
+ 	}
+ 
  	return 0;
  }
  device_initcall(wii_device_probe);
diff -crB /home/rxtx/Desktop/linux-4.3.3/drivers/i2c/busses/Makefile ./drivers/i2c/busses/Makefile
*** /home/rxtx/Desktop/linux-4.3.3/drivers/i2c/busses/Makefile	2015-12-15 16:41:43.000000000 +1100
--- ./drivers/i2c/busses/Makefile	2015-12-19 19:22:41.512458824 +1100
***************
*** 31,71 ****
  # Embedded system I2C/SMBus host controller drivers
  obj-$(CONFIG_I2C_AT91)		+= i2c-at91.o
  obj-$(CONFIG_I2C_AU1550)	+= i2c-au1550.o
- obj-$(CONFIG_I2C_AXXIA)		+= i2c-axxia.o
  obj-$(CONFIG_I2C_BCM2835)	+= i2c-bcm2835.o
- obj-$(CONFIG_I2C_BCM_IPROC)	+= i2c-bcm-iproc.o
  obj-$(CONFIG_I2C_BLACKFIN_TWI)	+= i2c-bfin-twi.o
- obj-$(CONFIG_I2C_CADENCE)	+= i2c-cadence.o
  obj-$(CONFIG_I2C_CBUS_GPIO)	+= i2c-cbus-gpio.o
  obj-$(CONFIG_I2C_CPM)		+= i2c-cpm.o
  obj-$(CONFIG_I2C_DAVINCI)	+= i2c-davinci.o
  obj-$(CONFIG_I2C_DESIGNWARE_CORE)	+= i2c-designware-core.o
  obj-$(CONFIG_I2C_DESIGNWARE_PLATFORM)	+= i2c-designware-platform.o
  i2c-designware-platform-objs := i2c-designware-platdrv.o
- i2c-designware-platform-$(CONFIG_I2C_DESIGNWARE_BAYTRAIL) += i2c-designware-baytrail.o
  obj-$(CONFIG_I2C_DESIGNWARE_PCI)	+= i2c-designware-pci.o
  i2c-designware-pci-objs := i2c-designware-pcidrv.o
- obj-$(CONFIG_I2C_DIGICOLOR)	+= i2c-digicolor.o
- obj-$(CONFIG_I2C_EFM32)		+= i2c-efm32.o
  obj-$(CONFIG_I2C_EG20T)		+= i2c-eg20t.o
! obj-$(CONFIG_I2C_EMEV2)		+= i2c-emev2.o
! obj-$(CONFIG_I2C_EXYNOS5)	+= i2c-exynos5.o
  obj-$(CONFIG_I2C_GPIO)		+= i2c-gpio.o
  obj-$(CONFIG_I2C_HIGHLANDER)	+= i2c-highlander.o
- obj-$(CONFIG_I2C_HIX5HD2)	+= i2c-hix5hd2.o
  obj-$(CONFIG_I2C_IBM_IIC)	+= i2c-ibm_iic.o
- obj-$(CONFIG_I2C_IMG)		+= i2c-img-scb.o
  obj-$(CONFIG_I2C_IMX)		+= i2c-imx.o
  obj-$(CONFIG_I2C_IOP3XX)	+= i2c-iop3xx.o
- obj-$(CONFIG_I2C_JZ4780)	+= i2c-jz4780.o
  obj-$(CONFIG_I2C_KEMPLD)	+= i2c-kempld.o
- obj-$(CONFIG_I2C_LPC2K)		+= i2c-lpc2k.o
- obj-$(CONFIG_I2C_MESON)		+= i2c-meson.o
  obj-$(CONFIG_I2C_MPC)		+= i2c-mpc.o
- obj-$(CONFIG_I2C_MT65XX)	+= i2c-mt65xx.o
  obj-$(CONFIG_I2C_MV64XXX)	+= i2c-mv64xxx.o
  obj-$(CONFIG_I2C_MXS)		+= i2c-mxs.o
  obj-$(CONFIG_I2C_NOMADIK)	+= i2c-nomadik.o
  obj-$(CONFIG_I2C_OCORES)	+= i2c-ocores.o
  obj-$(CONFIG_I2C_OMAP)		+= i2c-omap.o
  obj-$(CONFIG_I2C_PASEMI)	+= i2c-pasemi.o
--- 31,60 ----
  # Embedded system I2C/SMBus host controller drivers
  obj-$(CONFIG_I2C_AT91)		+= i2c-at91.o
  obj-$(CONFIG_I2C_AU1550)	+= i2c-au1550.o
  obj-$(CONFIG_I2C_BCM2835)	+= i2c-bcm2835.o
  obj-$(CONFIG_I2C_BLACKFIN_TWI)	+= i2c-bfin-twi.o
  obj-$(CONFIG_I2C_CBUS_GPIO)	+= i2c-cbus-gpio.o
  obj-$(CONFIG_I2C_CPM)		+= i2c-cpm.o
  obj-$(CONFIG_I2C_DAVINCI)	+= i2c-davinci.o
  obj-$(CONFIG_I2C_DESIGNWARE_CORE)	+= i2c-designware-core.o
  obj-$(CONFIG_I2C_DESIGNWARE_PLATFORM)	+= i2c-designware-platform.o
  i2c-designware-platform-objs := i2c-designware-platdrv.o
  obj-$(CONFIG_I2C_DESIGNWARE_PCI)	+= i2c-designware-pci.o
  i2c-designware-pci-objs := i2c-designware-pcidrv.o
  obj-$(CONFIG_I2C_EG20T)		+= i2c-eg20t.o
! obj-$(CONFIG_I2C_GPIO_COMMON)	+= i2c-gpio-common.o
  obj-$(CONFIG_I2C_GPIO)		+= i2c-gpio.o
+ obj-$(CONFIG_I2C_GPIO_OF)	+= i2c-gpio-of.o
  obj-$(CONFIG_I2C_HIGHLANDER)	+= i2c-highlander.o
  obj-$(CONFIG_I2C_IBM_IIC)	+= i2c-ibm_iic.o
  obj-$(CONFIG_I2C_IMX)		+= i2c-imx.o
  obj-$(CONFIG_I2C_IOP3XX)	+= i2c-iop3xx.o
  obj-$(CONFIG_I2C_KEMPLD)	+= i2c-kempld.o
  obj-$(CONFIG_I2C_MPC)		+= i2c-mpc.o
  obj-$(CONFIG_I2C_MV64XXX)	+= i2c-mv64xxx.o
  obj-$(CONFIG_I2C_MXS)		+= i2c-mxs.o
  obj-$(CONFIG_I2C_NOMADIK)	+= i2c-nomadik.o
+ obj-$(CONFIG_I2C_NUC900)	+= i2c-nuc900.o
  obj-$(CONFIG_I2C_OCORES)	+= i2c-ocores.o
  obj-$(CONFIG_I2C_OMAP)		+= i2c-omap.o
  obj-$(CONFIG_I2C_PASEMI)	+= i2c-pasemi.o
***************
*** 75,120 ****
  obj-$(CONFIG_I2C_PUV3)		+= i2c-puv3.o
  obj-$(CONFIG_I2C_PXA)		+= i2c-pxa.o
  obj-$(CONFIG_I2C_PXA_PCI)	+= i2c-pxa-pci.o
- obj-$(CONFIG_I2C_QUP)		+= i2c-qup.o
- obj-$(CONFIG_I2C_RIIC)		+= i2c-riic.o
- obj-$(CONFIG_I2C_RK3X)		+= i2c-rk3x.o
  obj-$(CONFIG_I2C_S3C2410)	+= i2c-s3c2410.o
  obj-$(CONFIG_I2C_SH7760)	+= i2c-sh7760.o
  obj-$(CONFIG_I2C_SH_MOBILE)	+= i2c-sh_mobile.o
  obj-$(CONFIG_I2C_SIMTEC)	+= i2c-simtec.o
  obj-$(CONFIG_I2C_SIRF)		+= i2c-sirf.o
- obj-$(CONFIG_I2C_ST)		+= i2c-st.o
  obj-$(CONFIG_I2C_STU300)	+= i2c-stu300.o
- obj-$(CONFIG_I2C_SUN6I_P2WI)	+= i2c-sun6i-p2wi.o
  obj-$(CONFIG_I2C_TEGRA)		+= i2c-tegra.o
  obj-$(CONFIG_I2C_VERSATILE)	+= i2c-versatile.o
  obj-$(CONFIG_I2C_WMT)		+= i2c-wmt.o
  obj-$(CONFIG_I2C_OCTEON)	+= i2c-octeon.o
  obj-$(CONFIG_I2C_XILINX)	+= i2c-xiic.o
  obj-$(CONFIG_I2C_XLR)		+= i2c-xlr.o
- obj-$(CONFIG_I2C_XLP9XX)	+= i2c-xlp9xx.o
  obj-$(CONFIG_I2C_RCAR)		+= i2c-rcar.o
  
  # External I2C/SMBus adapter drivers
  obj-$(CONFIG_I2C_DIOLAN_U2C)	+= i2c-diolan-u2c.o
- obj-$(CONFIG_I2C_DLN2)		+= i2c-dln2.o
  obj-$(CONFIG_I2C_PARPORT)	+= i2c-parport.o
  obj-$(CONFIG_I2C_PARPORT_LIGHT)	+= i2c-parport-light.o
- obj-$(CONFIG_I2C_ROBOTFUZZ_OSIF)	+= i2c-robotfuzz-osif.o
  obj-$(CONFIG_I2C_TAOS_EVM)	+= i2c-taos-evm.o
  obj-$(CONFIG_I2C_TINY_USB)	+= i2c-tiny-usb.o
  obj-$(CONFIG_I2C_VIPERBOARD)	+= i2c-viperboard.o
  
  # Other I2C/SMBus bus drivers
  obj-$(CONFIG_I2C_ACORN)		+= i2c-acorn.o
- obj-$(CONFIG_I2C_BCM_KONA)	+= i2c-bcm-kona.o
- obj-$(CONFIG_I2C_BRCMSTB)	+= i2c-brcmstb.o
- obj-$(CONFIG_I2C_CROS_EC_TUNNEL)	+= i2c-cros-ec-tunnel.o
  obj-$(CONFIG_I2C_ELEKTOR)	+= i2c-elektor.o
- obj-$(CONFIG_I2C_OPAL)		+= i2c-opal.o
  obj-$(CONFIG_I2C_PCA_ISA)	+= i2c-pca-isa.o
  obj-$(CONFIG_I2C_SIBYTE)	+= i2c-sibyte.o
- obj-$(CONFIG_I2C_XGENE_SLIMPRO) += i2c-xgene-slimpro.o
  obj-$(CONFIG_SCx200_ACB)	+= scx200_acb.o
  
  ccflags-$(CONFIG_I2C_DEBUG_BUS) := -DDEBUG
--- 64,98 ----
  obj-$(CONFIG_I2C_PUV3)		+= i2c-puv3.o
  obj-$(CONFIG_I2C_PXA)		+= i2c-pxa.o
  obj-$(CONFIG_I2C_PXA_PCI)	+= i2c-pxa-pci.o
  obj-$(CONFIG_I2C_S3C2410)	+= i2c-s3c2410.o
+ obj-$(CONFIG_I2C_S6000)		+= i2c-s6000.o
  obj-$(CONFIG_I2C_SH7760)	+= i2c-sh7760.o
  obj-$(CONFIG_I2C_SH_MOBILE)	+= i2c-sh_mobile.o
  obj-$(CONFIG_I2C_SIMTEC)	+= i2c-simtec.o
  obj-$(CONFIG_I2C_SIRF)		+= i2c-sirf.o
  obj-$(CONFIG_I2C_STU300)	+= i2c-stu300.o
  obj-$(CONFIG_I2C_TEGRA)		+= i2c-tegra.o
  obj-$(CONFIG_I2C_VERSATILE)	+= i2c-versatile.o
  obj-$(CONFIG_I2C_WMT)		+= i2c-wmt.o
  obj-$(CONFIG_I2C_OCTEON)	+= i2c-octeon.o
  obj-$(CONFIG_I2C_XILINX)	+= i2c-xiic.o
  obj-$(CONFIG_I2C_XLR)		+= i2c-xlr.o
  obj-$(CONFIG_I2C_RCAR)		+= i2c-rcar.o
  
  # External I2C/SMBus adapter drivers
  obj-$(CONFIG_I2C_DIOLAN_U2C)	+= i2c-diolan-u2c.o
  obj-$(CONFIG_I2C_PARPORT)	+= i2c-parport.o
  obj-$(CONFIG_I2C_PARPORT_LIGHT)	+= i2c-parport-light.o
  obj-$(CONFIG_I2C_TAOS_EVM)	+= i2c-taos-evm.o
  obj-$(CONFIG_I2C_TINY_USB)	+= i2c-tiny-usb.o
  obj-$(CONFIG_I2C_VIPERBOARD)	+= i2c-viperboard.o
  
  # Other I2C/SMBus bus drivers
  obj-$(CONFIG_I2C_ACORN)		+= i2c-acorn.o
  obj-$(CONFIG_I2C_ELEKTOR)	+= i2c-elektor.o
  obj-$(CONFIG_I2C_PCA_ISA)	+= i2c-pca-isa.o
  obj-$(CONFIG_I2C_SIBYTE)	+= i2c-sibyte.o
  obj-$(CONFIG_SCx200_ACB)	+= scx200_acb.o
+ obj-$(CONFIG_SCx200_I2C)	+= scx200_i2c.o
  
  ccflags-$(CONFIG_I2C_DEBUG_BUS) := -DDEBUG
diff -crB /home/rxtx/Desktop/linux-4.3.3/drivers/usb/host/Makefile ./drivers/usb/host/Makefile
*** /home/rxtx/Desktop/linux-4.3.3/drivers/usb/host/Makefile	2015-12-15 16:41:43.000000000 +1100
--- ./drivers/usb/host/Makefile	2015-12-19 19:23:22.228405659 +1100
***************
*** 2,10 ****
--- 2,14 ----
  # Makefile for USB Host Controller Drivers
  #
  
+ ccflags-$(CONFIG_USB_DEBUG) := -DDEBUG
+ 
  # tell define_trace.h where to find the xhci trace header
  CFLAGS_xhci-trace.o := -I$(src)
  
+ isp1760-y := isp1760-hcd.o isp1760-if.o
+ 
  fhci-y := fhci-hcd.o fhci-hub.o fhci-q.o
  fhci-y += fhci-mem.o fhci-tds.o fhci-sched.o
  
***************
*** 13,35 ****
  xhci-hcd-y := xhci.o xhci-mem.o
  xhci-hcd-y += xhci-ring.o xhci-hub.o xhci-dbg.o
  xhci-hcd-y += xhci-trace.o
  
! xhci-plat-hcd-y := xhci-plat.o
! ifneq ($(CONFIG_USB_XHCI_MVEBU), )
! 	xhci-plat-hcd-y		+= xhci-mvebu.o
! endif
! ifneq ($(CONFIG_USB_XHCI_RCAR), )
! 	xhci-plat-hcd-y		+= xhci-rcar.o
  endif
  
  obj-$(CONFIG_USB_WHCI_HCD)	+= whci/
  
! ifneq ($(CONFIG_USB), )
! 	obj-$(CONFIG_PCI)	+= pci-quirks.o
! endif
! 
! obj-$(CONFIG_USB_XHCI_PCI)	+= xhci-pci.o
! obj-$(CONFIG_USB_XHCI_PLATFORM) += xhci-plat-hcd.o
  
  obj-$(CONFIG_USB_EHCI_HCD)	+= ehci-hcd.o
  obj-$(CONFIG_USB_EHCI_PCI)	+= ehci-pci.o
--- 17,31 ----
  xhci-hcd-y := xhci.o xhci-mem.o
  xhci-hcd-y += xhci-ring.o xhci-hub.o xhci-dbg.o
  xhci-hcd-y += xhci-trace.o
+ xhci-hcd-$(CONFIG_PCI)	+= xhci-pci.o
  
! ifneq ($(CONFIG_USB_XHCI_PLATFORM), )
! 	xhci-hcd-y		+= xhci-plat.o
  endif
  
  obj-$(CONFIG_USB_WHCI_HCD)	+= whci/
  
! obj-$(CONFIG_PCI)		+= pci-quirks.o
  
  obj-$(CONFIG_USB_EHCI_HCD)	+= ehci-hcd.o
  obj-$(CONFIG_USB_EHCI_PCI)	+= ehci-pci.o
***************
*** 38,49 ****
  obj-$(CONFIG_USB_EHCI_HCD_OMAP)	+= ehci-omap.o
  obj-$(CONFIG_USB_EHCI_HCD_ORION)	+= ehci-orion.o
  obj-$(CONFIG_USB_EHCI_HCD_SPEAR)	+= ehci-spear.o
! obj-$(CONFIG_USB_EHCI_HCD_STI)	+= ehci-st.o
! obj-$(CONFIG_USB_EHCI_EXYNOS)	+= ehci-exynos.o
  obj-$(CONFIG_USB_EHCI_HCD_AT91) += ehci-atmel.o
  obj-$(CONFIG_USB_EHCI_MSM)	+= ehci-msm.o
  obj-$(CONFIG_USB_EHCI_TEGRA)	+= ehci-tegra.o
- obj-$(CONFIG_USB_W90X900_EHCI)	+= ehci-w90x900.o
  
  obj-$(CONFIG_USB_OXU210HP_HCD)	+= oxu210hp-hcd.o
  obj-$(CONFIG_USB_ISP116X_HCD)	+= isp116x-hcd.o
--- 34,43 ----
  obj-$(CONFIG_USB_EHCI_HCD_OMAP)	+= ehci-omap.o
  obj-$(CONFIG_USB_EHCI_HCD_ORION)	+= ehci-orion.o
  obj-$(CONFIG_USB_EHCI_HCD_SPEAR)	+= ehci-spear.o
! obj-$(CONFIG_USB_EHCI_S5P)	+= ehci-s5p.o
  obj-$(CONFIG_USB_EHCI_HCD_AT91) += ehci-atmel.o
  obj-$(CONFIG_USB_EHCI_MSM)	+= ehci-msm.o
  obj-$(CONFIG_USB_EHCI_TEGRA)	+= ehci-tegra.o
  
  obj-$(CONFIG_USB_OXU210HP_HCD)	+= oxu210hp-hcd.o
  obj-$(CONFIG_USB_ISP116X_HCD)	+= isp116x-hcd.o
***************
*** 52,66 ****
  obj-$(CONFIG_USB_OHCI_HCD)	+= ohci-hcd.o
  obj-$(CONFIG_USB_OHCI_HCD_PCI)	+= ohci-pci.o
  obj-$(CONFIG_USB_OHCI_HCD_PLATFORM)	+= ohci-platform.o
- obj-$(CONFIG_USB_OHCI_EXYNOS)	+= ohci-exynos.o
- obj-$(CONFIG_USB_OHCI_HCD_OMAP1)	+= ohci-omap.o
- obj-$(CONFIG_USB_OHCI_HCD_OMAP3)	+= ohci-omap3.o
- obj-$(CONFIG_USB_OHCI_HCD_SPEAR)	+= ohci-spear.o
- obj-$(CONFIG_USB_OHCI_HCD_STI)	+= ohci-st.o
- obj-$(CONFIG_USB_OHCI_HCD_AT91)	+= ohci-at91.o
- obj-$(CONFIG_USB_OHCI_HCD_S3C2410)	+= ohci-s3c2410.o
- obj-$(CONFIG_USB_OHCI_HCD_LPC32XX)	+= ohci-nxp.o
- obj-$(CONFIG_USB_OHCI_HCD_PXA27X)	+= ohci-pxa27x.o
  
  obj-$(CONFIG_USB_UHCI_HCD)	+= uhci-hcd.o
  obj-$(CONFIG_USB_FHCI_HCD)	+= fhci.o
--- 46,51 ----
***************
*** 69,80 ****
  obj-$(CONFIG_USB_SL811_CS)	+= sl811_cs.o
  obj-$(CONFIG_USB_U132_HCD)	+= u132-hcd.o
  obj-$(CONFIG_USB_R8A66597_HCD)	+= r8a66597-hcd.o
  obj-$(CONFIG_USB_HWA_HCD)	+= hwa-hc.o
  obj-$(CONFIG_USB_IMX21_HCD)	+= imx21-hcd.o
  obj-$(CONFIG_USB_FSL_MPH_DR_OF)	+= fsl-mph-dr-of.o
! obj-$(CONFIG_USB_EHCI_FSL)	+= ehci-fsl.o
  obj-$(CONFIG_USB_HCD_BCMA)	+= bcma-hcd.o
  obj-$(CONFIG_USB_HCD_SSB)	+= ssb-hcd.o
  obj-$(CONFIG_USB_FUSBH200_HCD)	+= fusbh200-hcd.o
  obj-$(CONFIG_USB_FOTG210_HCD)	+= fotg210-hcd.o
- obj-$(CONFIG_USB_MAX3421_HCD)	+= max3421-hcd.o
--- 54,66 ----
  obj-$(CONFIG_USB_SL811_CS)	+= sl811_cs.o
  obj-$(CONFIG_USB_U132_HCD)	+= u132-hcd.o
  obj-$(CONFIG_USB_R8A66597_HCD)	+= r8a66597-hcd.o
+ obj-$(CONFIG_USB_ISP1760_HCD)	+= isp1760.o
+ obj-$(CONFIG_USB_WII_HCD)	+= rvl-sthcd.o
  obj-$(CONFIG_USB_HWA_HCD)	+= hwa-hc.o
  obj-$(CONFIG_USB_IMX21_HCD)	+= imx21-hcd.o
  obj-$(CONFIG_USB_FSL_MPH_DR_OF)	+= fsl-mph-dr-of.o
! obj-$(CONFIG_USB_OCTEON2_COMMON) += octeon2-common.o
  obj-$(CONFIG_USB_HCD_BCMA)	+= bcma-hcd.o
  obj-$(CONFIG_USB_HCD_SSB)	+= ssb-hcd.o
  obj-$(CONFIG_USB_FUSBH200_HCD)	+= fusbh200-hcd.o
  obj-$(CONFIG_USB_FOTG210_HCD)	+= fotg210-hcd.o
diff -crB /home/rxtx/Desktop/linux-4.3.3/drivers/usb/host/ohci.h ./drivers/usb/host/ohci.h
*** /home/rxtx/Desktop/linux-4.3.3/drivers/usb/host/ohci.h	2015-12-15 16:41:43.000000000 +1100
--- ./drivers/usb/host/ohci.h	2015-12-19 19:24:24.116371217 +1100
***************
*** 16,21 ****
--- 16,43 ----
  typedef __u16 __bitwise __hc16;
  
  /*
+  * Some platforms have weird constraints when accessing memory.
+  *
+  * For example, the Nintendo Wii video game console is unable to perform
+  * non-32 bit writes to non-cached memory for its second block of 64MB of RAM.
+  * As this platform also requires CONFIG_NOT_COHERENT_CACHE, all memory
+  * allocated using the dma memory allocation functions can only be written
+  * using 32-bit accesses.
+  *
+  * Because of this constraint, as a workaround, we make sure that all
+  * fields in struct ed and td (which are allocated from dma pools) are
+  * always 32 bit fields.
+  * Note that the remaining structs allocated from dma-able memory are already
+  * 32 bit fields.
+  */
+ #ifdef CONFIG_USB_OHCI_HCD_HLWD
+ #define ohci_fld(type)  u32
+ #else
+ #define ohci_fld(type)  type
+ #endif
+ 
+ 
+ /*
   * OHCI Endpoint Descriptor (ED) ... holds TD queue
   * See OHCI spec, section 4.2
   *
***************
*** 47,79 ****
  	struct ed		*ed_next;	/* on schedule or rm_list */
  	struct ed		*ed_prev;	/* for non-interrupt EDs */
  	struct list_head	td_list;	/* "shadow list" of our TDs */
- 	struct list_head	in_use_list;
  
  	/* create --> IDLE --> OPER --> ... --> IDLE --> destroy
  	 * usually:  OPER --> UNLINK --> (IDLE | OPER) --> ...
  	 */
! 	u8			state;		/* ED_{IDLE,UNLINK,OPER} */
  #define ED_IDLE		0x00		/* NOT linked to HC */
  #define ED_UNLINK	0x01		/* being unlinked from hc */
  #define ED_OPER		0x02		/* IS linked to hc */
  
! 	u8			type;		/* PIPE_{BULK,...} */
  
  	/* periodic scheduling params (for intr and iso) */
! 	u8			branch;
! 	u16			interval;
! 	u16			load;
! 	u16			last_iso;	/* iso only */
  
  	/* HC may see EDs on rm_list until next frame (frame_no == tick) */
! 	u16			tick;
! 
! 	/* Detect TDs not added to the done queue */
! 	unsigned		takeback_wdh_cnt;
! 	struct td		*pending_td;
! #define	OKAY_TO_TAKEBACK(ohci, ed)			\
! 		((int) (ohci->wdh_cnt - ed->takeback_wdh_cnt) >= 0)
! 
  } __attribute__ ((aligned(16)));
  
  #define ED_MASK	((u32)~0x0f)		/* strip hw status in low addr bits */
--- 69,93 ----
  	struct ed		*ed_next;	/* on schedule or rm_list */
  	struct ed		*ed_prev;	/* for non-interrupt EDs */
  	struct list_head	td_list;	/* "shadow list" of our TDs */
  
  	/* create --> IDLE --> OPER --> ... --> IDLE --> destroy
  	 * usually:  OPER --> UNLINK --> (IDLE | OPER) --> ...
  	 */
! 	ohci_fld(u8)		state;		/* ED_{IDLE,UNLINK,OPER} */
  #define ED_IDLE		0x00		/* NOT linked to HC */
  #define ED_UNLINK	0x01		/* being unlinked from hc */
  #define ED_OPER		0x02		/* IS linked to hc */
  
! 	ohci_fld(u8)		type;		/* PIPE_{BULK,...} */
  
  	/* periodic scheduling params (for intr and iso) */
! 	ohci_fld(u8)		branch;
! 	ohci_fld(u16)		interval;
! 	ohci_fld(u16)		load;
! 	ohci_fld(u16)		last_iso;	/* iso only */
  
  	/* HC may see EDs on rm_list until next frame (frame_no == tick) */
! 	ohci_fld(u16)		tick;
  } __attribute__ ((aligned(16)));
  
  #define ED_MASK	((u32)~0x0f)		/* strip hw status in low addr bits */
***************
*** 126,132 ****
  	__hc16		hwPSW [MAXPSW];
  
  	/* rest are purely for the driver's use */
! 	__u8		index;
  	struct ed	*ed;
  	struct td	*td_hash;	/* dma-->td hashtable */
  	struct td	*next_dl_td;
--- 140,146 ----
  	__hc16		hwPSW [MAXPSW];
  
  	/* rest are purely for the driver's use */
! 	ohci_fld(__u8)	index;
  	struct ed	*ed;
  	struct td	*td_hash;	/* dma-->td hashtable */
  	struct td	*next_dl_td;
***************
*** 388,396 ****
  	struct dma_pool		*td_cache;
  	struct dma_pool		*ed_cache;
  	struct td		*td_hash [TD_HASH_SIZE];
- 	struct td		*dl_start, *dl_end;	/* the done list */
  	struct list_head	pending;
- 	struct list_head	eds_in_use;	/* all EDs with at least 1 TD */
  
  	/*
  	 * driver state
--- 402,408 ----
***************
*** 402,409 ****
  	unsigned long		next_statechange;	/* suspend/resume */
  	u32			fminterval;		/* saved register */
  	unsigned		autostop:1;	/* rh auto stopping/stopped */
- 	unsigned		working:1;
- 	unsigned		restart_work:1;
  
  	unsigned long		flags;		/* for HC bugs */
  #define	OHCI_QUIRK_AMD756	0x01			/* erratum #4 */
--- 414,419 ----
***************
*** 417,438 ****
  #define	OHCI_QUIRK_HUB_POWER	0x100			/* distrust firmware power/oc setup */
  #define	OHCI_QUIRK_AMD_PLL	0x200			/* AMD PLL quirk*/
  #define	OHCI_QUIRK_AMD_PREFETCH	0x400			/* pre-fetch for ISO transfer */
! #define	OHCI_QUIRK_GLOBAL_SUSPEND	0x800		/* must suspend ports */
! 
  	// there are also chip quirks/bugs in init logic
  
- 	unsigned		prev_frame_no;
- 	unsigned		wdh_cnt, prev_wdh_cnt;
- 	u32			prev_donehead;
- 	struct timer_list	io_watchdog;
- 
  	struct work_struct	nec_work;	/* Worker for NEC quirk */
  
  	struct dentry		*debug_dir;
  	struct dentry		*debug_async;
  	struct dentry		*debug_periodic;
  	struct dentry		*debug_registers;
! 
  	/* platform-specific data -- must come last */
  	unsigned long           priv[0] __aligned(sizeof(s64));
  
--- 427,449 ----
  #define	OHCI_QUIRK_HUB_POWER	0x100			/* distrust firmware power/oc setup */
  #define	OHCI_QUIRK_AMD_PLL	0x200			/* AMD PLL quirk*/
  #define	OHCI_QUIRK_AMD_PREFETCH	0x400			/* pre-fetch for ISO transfer */
! #define	OHCI_QUIRK_WII		0x800			/* Hollywood chipset */
  	// there are also chip quirks/bugs in init logic
  
  	struct work_struct	nec_work;	/* Worker for NEC quirk */
  
+ 	/* Needed for ZF Micro quirk */
+ 	struct timer_list	unlink_watchdog;
+ 	unsigned		eds_scheduled;
+ 	struct ed		*ed_to_check;
+ 	unsigned		zf_delay;
+ 
+ #ifdef DEBUG
  	struct dentry		*debug_dir;
  	struct dentry		*debug_async;
  	struct dentry		*debug_periodic;
  	struct dentry		*debug_registers;
! #endif
  	/* platform-specific data -- must come last */
  	unsigned long           priv[0] __aligned(sizeof(s64));
  
***************
*** 486,491 ****
--- 497,506 ----
  
  /*-------------------------------------------------------------------------*/
  
+ #ifndef DEBUG
+ #define STUB_DEBUG_FILES
+ #endif	/* DEBUG */
+ 
  #define ohci_dbg(ohci, fmt, args...) \
  	dev_dbg (ohci_to_hcd(ohci)->self.controller , fmt , ## args )
  #define ohci_err(ohci, fmt, args...) \
***************
*** 495,500 ****
--- 510,521 ----
  #define ohci_warn(ohci, fmt, args...) \
  	dev_warn (ohci_to_hcd(ohci)->self.controller , fmt , ## args )
  
+ #ifdef OHCI_VERBOSE_DEBUG
+ #	define ohci_vdbg ohci_dbg
+ #else
+ #	define ohci_vdbg(ohci, fmt, args...) do { } while (0)
+ #endif
+ 
  /*-------------------------------------------------------------------------*/
  
  /*
***************
*** 552,557 ****
--- 573,609 ----
  #define big_endian_mmio(ohci)	0		/* only little endian */
  #endif
  
+ #ifdef CONFIG_USB_OHCI_HCD_HLWD
+ 
+ #include <asm/starlet-mini.h>
+ 
+ static inline unsigned int _ohci_readl(const struct ohci_hcd *ohci,
+ 				       __hc32 __iomem *regs)
+ {
+ 	return in_be32(regs);
+ }
+ 
+ static inline void _ohci_writel(const struct ohci_hcd *ohci,
+ 				const unsigned int val, __hc32 __iomem *regs)
+ {
+ 	out_be32(regs, val);
+ }
+ 
+ extern void ohci_hlwd_control_quirk(struct ohci_hcd *ohci);
+ extern void ohci_hlwd_bulk_quirk(struct ohci_hcd *ohci);
+ 
+ #else
+ 
+ static inline void ohci_hlwd_control_quirk(struct ohci_hcd *ohci)
+ {
+ 	return;
+ }
+ 
+ static inline void ohci_hlwd_bulk_quirk(struct ohci_hcd *ohci)
+ {
+ 	return;
+ }
+ 
  /*
   * Big-endian read/write functions are arch-specific.
   * Other arches can be added if/when they're needed.
***************
*** 581,586 ****
--- 633,640 ----
  #endif
  }
  
+ #endif /* CONFIG_USB_OHCI_HCD_HLWD */
+ 
  #define ohci_readl(o,r)		_ohci_readl(o,r)
  #define ohci_writel(o,v,r)	_ohci_writel(o,v,r)
  
***************
*** 647,668 ****
  
  /*-------------------------------------------------------------------------*/
  
! /*
!  * The HCCA frame number is 16 bits, but is accessed as 32 bits since not all
!  * hardware handles 16 bit reads.  Depending on the SoC implementation, the
!  * frame number can wind up in either bits [31:16] (default) or
!  * [15:0] (OHCI_QUIRK_FRAME_NO) on big endian hosts.
!  *
!  * Somewhat similarly, the 16-bit PSW fields in a transfer descriptor are
!  * reordered on BE.
   */
  
  static inline u16 ohci_frame_no(const struct ohci_hcd *ohci)
  {
  	u32 tmp;
  	if (big_endian_desc(ohci)) {
  		tmp = be32_to_cpup((__force __be32 *)&ohci->hcca->frame_no);
! 		if (!(ohci->flags & OHCI_QUIRK_FRAME_NO))
  			tmp >>= 16;
  	} else
  		tmp = le32_to_cpup((__force __le32 *)&ohci->hcca->frame_no);
--- 701,723 ----
  
  /*-------------------------------------------------------------------------*/
  
! /* HCCA frame number is 16 bits, but is accessed as 32 bits since not all
!  * hardware handles 16 bit reads.  That creates a different confusion on
!  * some big-endian SOC implementations.  Same thing happens with PSW access.
   */
  
+ #ifdef CONFIG_PPC_MPC52xx
+ #define big_endian_frame_no_quirk(ohci)	(ohci->flags & OHCI_QUIRK_FRAME_NO)
+ #else
+ #define big_endian_frame_no_quirk(ohci)	0
+ #endif
+ 
  static inline u16 ohci_frame_no(const struct ohci_hcd *ohci)
  {
  	u32 tmp;
  	if (big_endian_desc(ohci)) {
  		tmp = be32_to_cpup((__force __be32 *)&ohci->hcca->frame_no);
! 		if (!big_endian_frame_no_quirk(ohci))
  			tmp >>= 16;
  	} else
  		tmp = le32_to_cpup((__force __le32 *)&ohci->hcca->frame_no);
***************
*** 739,744 ****
  extern int	ohci_suspend(struct usb_hcd *hcd, bool do_wakeup);
  extern int	ohci_resume(struct usb_hcd *hcd, bool hibernated);
  #endif
- extern int	ohci_hub_control(struct usb_hcd	*hcd, u16 typeReq, u16 wValue,
- 				 u16 wIndex, char *buf, u16 wLength);
- extern int	ohci_hub_status_data(struct usb_hcd *hcd, char *buf);
--- 794,796 ----
diff -crB /home/rxtx/Desktop/linux-4.3.3/drivers/usb/host/ohci-hcd.c ./drivers/usb/host/ohci-hcd.c
*** /home/rxtx/Desktop/linux-4.3.3/drivers/usb/host/ohci-hcd.c	2015-12-15 16:41:43.000000000 +1100
--- ./drivers/usb/host/ohci-hcd.c	2015-12-19 19:23:59.496378554 +1100
***************
*** 51,56 ****
--- 51,58 ----
  
  /*-------------------------------------------------------------------------*/
  
+ #undef OHCI_VERBOSE_DEBUG	/* not always helpful */
+ 
  /* For initializing controller (mask in an HCFS mode too) */
  #define	OHCI_CONTROL_INIT	OHCI_CTRL_CBSR
  #define	OHCI_INTR_INIT \
***************
*** 72,85 ****
  static const char	hcd_name [] = "ohci_hcd";
  
  #define	STATECHANGE_DELAY	msecs_to_jiffies(300)
- #define	IO_WATCHDOG_DELAY	msecs_to_jiffies(250)
  
  #include "ohci.h"
  #include "pci-quirks.h"
  
! static void ohci_dump(struct ohci_hcd *ohci);
! static void ohci_stop(struct usb_hcd *hcd);
! static void io_watchdog_func(unsigned long _ohci);
  
  #include "ohci-hub.c"
  #include "ohci-dbg.c"
--- 74,85 ----
  static const char	hcd_name [] = "ohci_hcd";
  
  #define	STATECHANGE_DELAY	msecs_to_jiffies(300)
  
  #include "ohci.h"
  #include "pci-quirks.h"
  
! static void ohci_dump (struct ohci_hcd *ohci, int verbose);
! static void ohci_stop (struct usb_hcd *hcd);
  
  #include "ohci-hub.c"
  #include "ohci-dbg.c"
***************
*** 111,143 ****
  
  /*-------------------------------------------------------------------------*/
  
- static int number_of_tds(struct urb *urb)
- {
- 	int			len, i, num, this_sg_len;
- 	struct scatterlist	*sg;
- 
- 	len = urb->transfer_buffer_length;
- 	i = urb->num_mapped_sgs;
- 
- 	if (len > 0 && i > 0) {		/* Scatter-gather transfer */
- 		num = 0;
- 		sg = urb->sg;
- 		for (;;) {
- 			this_sg_len = min_t(int, sg_dma_len(sg), len);
- 			num += DIV_ROUND_UP(this_sg_len, 4096);
- 			len -= this_sg_len;
- 			if (--i <= 0 || len <= 0)
- 				break;
- 			sg = sg_next(sg);
- 		}
- 
- 	} else {			/* Non-SG transfer */
- 		/* one TD for every 4096 Bytes (could be up to 8K) */
- 		num = DIV_ROUND_UP(len, 4096);
- 	}
- 	return num;
- }
- 
  /*
   * queue up an urb for anything except the root hub
   */
--- 111,116 ----
***************
*** 154,162 ****
  	unsigned long	flags;
  	int		retval = 0;
  
  	/* every endpoint has a ed, locate and maybe (re)initialize it */
! 	ed = ed_get(ohci, urb->ep, urb->dev, pipe, urb->interval);
! 	if (! ed)
  		return -ENOMEM;
  
  	/* for the private part of the URB we need the number of TDs (size) */
--- 127,138 ----
  	unsigned long	flags;
  	int		retval = 0;
  
+ #ifdef OHCI_VERBOSE_DEBUG
+ 	urb_print(urb, "SUB", usb_pipein(pipe), -EINPROGRESS);
+ #endif
+ 
  	/* every endpoint has a ed, locate and maybe (re)initialize it */
! 	if (! (ed = ed_get (ohci, urb->ep, urb->dev, pipe, urb->interval)))
  		return -ENOMEM;
  
  	/* for the private part of the URB we need the number of TDs (size) */
***************
*** 172,179 ****
  		// case PIPE_INTERRUPT:
  		// case PIPE_BULK:
  		default:
! 			size += number_of_tds(urb);
! 			/* maybe a zero-length packet to wrap it up */
  			if (size == 0)
  				size++;
  			else if ((urb->transfer_flags & URB_ZERO_PACKET) != 0
--- 148,159 ----
  		// case PIPE_INTERRUPT:
  		// case PIPE_BULK:
  		default:
! 			/* one TD for every 4096 Bytes (can be up to 8K) */
! 			size += urb->transfer_buffer_length / 4096;
! 			/* ... and for any remaining bytes ... */
! 			if ((urb->transfer_buffer_length % 4096) != 0)
! 				size++;
! 			/* ... and maybe a zero length packet to wrap it up */
  			if (size == 0)
  				size++;
  			else if ((urb->transfer_flags & URB_ZERO_PACKET) != 0
***************
*** 228,243 ****
  			usb_hcd_unlink_urb_from_ep(hcd, urb);
  			goto fail;
  		}
- 
- 		/* Start up the I/O watchdog timer, if it's not running */
- 		if (!timer_pending(&ohci->io_watchdog) &&
- 				list_empty(&ohci->eds_in_use)) {
- 			ohci->prev_frame_no = ohci_frame_no(ohci);
- 			mod_timer(&ohci->io_watchdog,
- 					jiffies + IO_WATCHDOG_DELAY);
- 		}
- 		list_add(&ed->in_use_list, &ohci->eds_in_use);
- 
  		if (ed->type == PIPE_ISOCHRONOUS) {
  			u16	frame = ohci_frame_no(ohci);
  
--- 208,213 ----
***************
*** 313,336 ****
  	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
  	unsigned long		flags;
  	int			rc;
! 	urb_priv_t		*urb_priv;
  
  	spin_lock_irqsave (&ohci->lock, flags);
  	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
! 	if (rc == 0) {
  
  		/* Unless an IRQ completed the unlink while it was being
  		 * handed to us, flag it for unlink and giveback, and force
  		 * some upcoming INTR_SF to call finish_unlinks()
  		 */
  		urb_priv = urb->hcpriv;
! 		if (urb_priv->ed->state == ED_OPER)
! 			start_ed_unlink(ohci, urb_priv->ed);
! 
! 		if (ohci->rh_state != OHCI_RH_RUNNING) {
! 			/* With HC dead, we can clean up right away */
! 			ohci_work(ohci);
  		}
  	}
  	spin_unlock_irqrestore (&ohci->lock, flags);
  	return rc;
--- 283,316 ----
  	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
  	unsigned long		flags;
  	int			rc;
! 
! #ifdef OHCI_VERBOSE_DEBUG
! 	urb_print(urb, "UNLINK", 1, status);
! #endif
  
  	spin_lock_irqsave (&ohci->lock, flags);
  	rc = usb_hcd_check_unlink_urb(hcd, urb, status);
! 	if (rc) {
! 		;	/* Do nothing */
! 	} else if (ohci->rh_state == OHCI_RH_RUNNING) {
! 		urb_priv_t  *urb_priv;
  
  		/* Unless an IRQ completed the unlink while it was being
  		 * handed to us, flag it for unlink and giveback, and force
  		 * some upcoming INTR_SF to call finish_unlinks()
  		 */
  		urb_priv = urb->hcpriv;
! 		if (urb_priv) {
! 			if (urb_priv->ed->state == ED_OPER)
! 				start_ed_unlink (ohci, urb_priv->ed);
  		}
+ 	} else {
+ 		/*
+ 		 * with HC dead, we won't respect hc queue pointers
+ 		 * any more ... just clean up every urb's memory.
+ 		 */
+ 		if (urb->hcpriv)
+ 			finish_urb(ohci, urb, status);
  	}
  	spin_unlock_irqrestore (&ohci->lock, flags);
  	return rc;
***************
*** 362,368 ****
  	if (ohci->rh_state != OHCI_RH_RUNNING) {
  sanitize:
  		ed->state = ED_IDLE;
! 		ohci_work(ohci);
  	}
  
  	switch (ed->state) {
--- 342,350 ----
  	if (ohci->rh_state != OHCI_RH_RUNNING) {
  sanitize:
  		ed->state = ED_IDLE;
! 		if (quirk_zfmicro(ohci) && ed->type == PIPE_INTERRUPT)
! 			ohci->eds_scheduled--;
! 		finish_unlinks (ohci, 0);
  	}
  
  	switch (ed->state) {
***************
*** 370,375 ****
--- 352,362 ----
  		/* major IRQ delivery trouble loses INTR_SF too... */
  		if (limit-- == 0) {
  			ohci_warn(ohci, "ED unlink timeout\n");
+ 			if (quirk_zfmicro(ohci)) {
+ 				ohci_warn(ohci, "Attempting ZF TD recovery\n");
+ 				ohci->ed_to_check = ed;
+ 				ohci->zf_delay = 2;
+ 			}
  			goto sanitize;
  		}
  		spin_unlock_irqrestore (&ohci->lock, flags);
***************
*** 429,435 ****
  	udelay(10);
  
  	ohci_writel(ohci, ohci->fminterval, &ohci->regs->fminterval);
! 	ohci->rh_state = OHCI_RH_HALTED;
  }
  
  /*-------------------------------------------------------------------------*
--- 416,508 ----
  	udelay(10);
  
  	ohci_writel(ohci, ohci->fminterval, &ohci->regs->fminterval);
! }
! 
! static int check_ed(struct ohci_hcd *ohci, struct ed *ed)
! {
! 	return (hc32_to_cpu(ohci, ed->hwINFO) & ED_IN) != 0
! 		&& (hc32_to_cpu(ohci, ed->hwHeadP) & TD_MASK)
! 			== (hc32_to_cpu(ohci, ed->hwTailP) & TD_MASK)
! 		&& !list_empty(&ed->td_list);
! }
! 
! /* ZF Micro watchdog timer callback. The ZF Micro chipset sometimes completes
!  * an interrupt TD but neglects to add it to the donelist.  On systems with
!  * this chipset, we need to periodically check the state of the queues to look
!  * for such "lost" TDs.
!  */
! static void unlink_watchdog_func(unsigned long _ohci)
! {
! 	unsigned long	flags;
! 	unsigned	max;
! 	unsigned	seen_count = 0;
! 	unsigned	i;
! 	struct ed	**seen = NULL;
! 	struct ohci_hcd	*ohci = (struct ohci_hcd *) _ohci;
! 
! 	spin_lock_irqsave(&ohci->lock, flags);
! 	max = ohci->eds_scheduled;
! 	if (!max)
! 		goto done;
! 
! 	if (ohci->ed_to_check)
! 		goto out;
! 
! 	seen = kcalloc(max, sizeof *seen, GFP_ATOMIC);
! 	if (!seen)
! 		goto out;
! 
! 	for (i = 0; i < NUM_INTS; i++) {
! 		struct ed	*ed = ohci->periodic[i];
! 
! 		while (ed) {
! 			unsigned	temp;
! 
! 			/* scan this branch of the periodic schedule tree */
! 			for (temp = 0; temp < seen_count; temp++) {
! 				if (seen[temp] == ed) {
! 					/* we've checked it and what's after */
! 					ed = NULL;
! 					break;
! 				}
! 			}
! 			if (!ed)
! 				break;
! 			seen[seen_count++] = ed;
! 			if (!check_ed(ohci, ed)) {
! 				ed = ed->ed_next;
! 				continue;
! 			}
! 
! 			/* HC's TD list is empty, but HCD sees at least one
! 			 * TD that's not been sent through the donelist.
! 			 */
! 			ohci->ed_to_check = ed;
! 			ohci->zf_delay = 2;
! 
! 			/* The HC may wait until the next frame to report the
! 			 * TD as done through the donelist and INTR_WDH.  (We
! 			 * just *assume* it's not a multi-TD interrupt URB;
! 			 * those could defer the IRQ more than one frame, using
! 			 * DI...)  Check again after the next INTR_SF.
! 			 */
! 			ohci_writel(ohci, OHCI_INTR_SF,
! 					&ohci->regs->intrstatus);
! 			ohci_writel(ohci, OHCI_INTR_SF,
! 					&ohci->regs->intrenable);
! 
! 			/* flush those writes */
! 			(void) ohci_readl(ohci, &ohci->regs->control);
! 
! 			goto out;
! 		}
! 	}
! out:
! 	kfree(seen);
! 	if (ohci->eds_scheduled)
! 		mod_timer(&ohci->unlink_watchdog, round_jiffies(jiffies + HZ));
! done:
! 	spin_unlock_irqrestore(&ohci->lock, flags);
  }
  
  /*-------------------------------------------------------------------------*
***************
*** 443,451 ****
  	int ret;
  	struct usb_hcd *hcd = ohci_to_hcd(ohci);
  
- 	/* Accept arbitrarily long scatter-gather lists */
- 	hcd->self.sg_tablesize = ~0;
- 
  	if (distrust_firmware)
  		ohci->flags |= OHCI_QUIRK_HUB_POWER;
  
--- 516,521 ----
***************
*** 498,509 ****
  	if (ohci->hcca)
  		return 0;
  
- 	setup_timer(&ohci->io_watchdog, io_watchdog_func,
- 			(unsigned long) ohci);
- 	set_timer_slack(&ohci->io_watchdog, msecs_to_jiffies(20));
- 
  	ohci->hcca = dma_alloc_coherent (hcd->self.controller,
! 			sizeof(*ohci->hcca), &ohci->hcca_dma, GFP_KERNEL);
  	if (!ohci->hcca)
  		return -ENOMEM;
  
--- 568,575 ----
  	if (ohci->hcca)
  		return 0;
  
  	ohci->hcca = dma_alloc_coherent (hcd->self.controller,
! 			sizeof *ohci->hcca, &ohci->hcca_dma, 0);
  	if (!ohci->hcca)
  		return -ENOMEM;
  
***************
*** 633,639 ****
  		return -EOVERFLOW;
  	}
  
! 	/* use rhsc irqs after hub_wq is allocated */
  	set_bit(HCD_FLAG_POLL_RH, &hcd->flags);
  	hcd->uses_new_polling = 1;
  
--- 699,705 ----
  		return -EOVERFLOW;
  	}
  
! 	/* use rhsc irqs after khubd is fully initialized */
  	set_bit(HCD_FLAG_POLL_RH, &hcd->flags);
  	hcd->uses_new_polling = 1;
  
***************
*** 679,685 ****
  	// POTPGT delay is bits 24-31, in 2 ms units.
  	mdelay ((val >> 23) & 0x1fe);
  
! 	ohci_dump(ohci);
  
  	return 0;
  }
--- 745,760 ----
  	// POTPGT delay is bits 24-31, in 2 ms units.
  	mdelay ((val >> 23) & 0x1fe);
  
! 	if (quirk_zfmicro(ohci)) {
! 		/* Create timer to watch for bad queue state on ZF Micro */
! 		setup_timer(&ohci->unlink_watchdog, unlink_watchdog_func,
! 				(unsigned long) ohci);
! 
! 		ohci->eds_scheduled = 0;
! 		ohci->ed_to_check = NULL;
! 	}
! 
! 	ohci_dump (ohci, 1);
  
  	return 0;
  }
***************
*** 712,853 ****
  
  /*-------------------------------------------------------------------------*/
  
- /*
-  * Some OHCI controllers are known to lose track of completed TDs.  They
-  * don't add the TDs to the hardware done queue, which means we never see
-  * them as being completed.
-  *
-  * This watchdog routine checks for such problems.  Without some way to
-  * tell when those TDs have completed, we would never take their EDs off
-  * the unlink list.  As a result, URBs could never be dequeued and
-  * endpoints could never be released.
-  */
- static void io_watchdog_func(unsigned long _ohci)
- {
- 	struct ohci_hcd	*ohci = (struct ohci_hcd *) _ohci;
- 	bool		takeback_all_pending = false;
- 	u32		status;
- 	u32		head;
- 	struct ed	*ed;
- 	struct td	*td, *td_start, *td_next;
- 	unsigned	frame_no;
- 	unsigned long	flags;
- 
- 	spin_lock_irqsave(&ohci->lock, flags);
- 
- 	/*
- 	 * One way to lose track of completed TDs is if the controller
- 	 * never writes back the done queue head.  If it hasn't been
- 	 * written back since the last time this function ran and if it
- 	 * was non-empty at that time, something is badly wrong with the
- 	 * hardware.
- 	 */
- 	status = ohci_readl(ohci, &ohci->regs->intrstatus);
- 	if (!(status & OHCI_INTR_WDH) && ohci->wdh_cnt == ohci->prev_wdh_cnt) {
- 		if (ohci->prev_donehead) {
- 			ohci_err(ohci, "HcDoneHead not written back; disabled\n");
-  died:
- 			usb_hc_died(ohci_to_hcd(ohci));
- 			ohci_dump(ohci);
- 			ohci_shutdown(ohci_to_hcd(ohci));
- 			goto done;
- 		} else {
- 			/* No write back because the done queue was empty */
- 			takeback_all_pending = true;
- 		}
- 	}
- 
- 	/* Check every ED which might have pending TDs */
- 	list_for_each_entry(ed, &ohci->eds_in_use, in_use_list) {
- 		if (ed->pending_td) {
- 			if (takeback_all_pending ||
- 					OKAY_TO_TAKEBACK(ohci, ed)) {
- 				unsigned tmp = hc32_to_cpu(ohci, ed->hwINFO);
- 
- 				ohci_dbg(ohci, "takeback pending TD for dev %d ep 0x%x\n",
- 						0x007f & tmp,
- 						(0x000f & (tmp >> 7)) +
- 							((tmp & ED_IN) >> 5));
- 				add_to_done_list(ohci, ed->pending_td);
- 			}
- 		}
- 
- 		/* Starting from the latest pending TD, */
- 		td = ed->pending_td;
- 
- 		/* or the last TD on the done list, */
- 		if (!td) {
- 			list_for_each_entry(td_next, &ed->td_list, td_list) {
- 				if (!td_next->next_dl_td)
- 					break;
- 				td = td_next;
- 			}
- 		}
- 
- 		/* find the last TD processed by the controller. */
- 		head = hc32_to_cpu(ohci, ACCESS_ONCE(ed->hwHeadP)) & TD_MASK;
- 		td_start = td;
- 		td_next = list_prepare_entry(td, &ed->td_list, td_list);
- 		list_for_each_entry_continue(td_next, &ed->td_list, td_list) {
- 			if (head == (u32) td_next->td_dma)
- 				break;
- 			td = td_next;	/* head pointer has passed this TD */
- 		}
- 		if (td != td_start) {
- 			/*
- 			 * In case a WDH cycle is in progress, we will wait
- 			 * for the next two cycles to complete before assuming
- 			 * this TD will never get on the done queue.
- 			 */
- 			ed->takeback_wdh_cnt = ohci->wdh_cnt + 2;
- 			ed->pending_td = td;
- 		}
- 	}
- 
- 	ohci_work(ohci);
- 
- 	if (ohci->rh_state == OHCI_RH_RUNNING) {
- 
- 		/*
- 		 * Sometimes a controller just stops working.  We can tell
- 		 * by checking that the frame counter has advanced since
- 		 * the last time we ran.
- 		 *
- 		 * But be careful: Some controllers violate the spec by
- 		 * stopping their frame counter when no ports are active.
- 		 */
- 		frame_no = ohci_frame_no(ohci);
- 		if (frame_no == ohci->prev_frame_no) {
- 			int		active_cnt = 0;
- 			int		i;
- 			unsigned	tmp;
- 
- 			for (i = 0; i < ohci->num_ports; ++i) {
- 				tmp = roothub_portstatus(ohci, i);
- 				/* Enabled and not suspended? */
- 				if ((tmp & RH_PS_PES) && !(tmp & RH_PS_PSS))
- 					++active_cnt;
- 			}
- 
- 			if (active_cnt > 0) {
- 				ohci_err(ohci, "frame counter not updating; disabled\n");
- 				goto died;
- 			}
- 		}
- 		if (!list_empty(&ohci->eds_in_use)) {
- 			ohci->prev_frame_no = frame_no;
- 			ohci->prev_wdh_cnt = ohci->wdh_cnt;
- 			ohci->prev_donehead = ohci_readl(ohci,
- 					&ohci->regs->donehead);
- 			mod_timer(&ohci->io_watchdog,
- 					jiffies + IO_WATCHDOG_DELAY);
- 		}
- 	}
- 
-  done:
- 	spin_unlock_irqrestore(&ohci->lock, flags);
- }
- 
  /* an interrupt happens */
  
  static irqreturn_t ohci_irq (struct usb_hcd *hcd)
--- 787,792 ----
***************
*** 896,907 ****
  			usb_hc_died(hcd);
  		}
  
! 		ohci_dump(ohci);
  		ohci_usb_reset (ohci);
  	}
  
  	if (ints & OHCI_INTR_RHSC) {
! 		ohci_dbg(ohci, "rhsc\n");
  		ohci->next_statechange = jiffies + STATECHANGE_DELAY;
  		ohci_writel(ohci, OHCI_INTR_RD | OHCI_INTR_RHSC,
  				&regs->intrstatus);
--- 835,846 ----
  			usb_hc_died(hcd);
  		}
  
! 		ohci_dump (ohci, 1);
  		ohci_usb_reset (ohci);
  	}
  
  	if (ints & OHCI_INTR_RHSC) {
! 		ohci_vdbg(ohci, "rhsc\n");
  		ohci->next_statechange = jiffies + STATECHANGE_DELAY;
  		ohci_writel(ohci, OHCI_INTR_RD | OHCI_INTR_RHSC,
  				&regs->intrstatus);
***************
*** 910,917 ****
  		 * choices for RHSC.  Many followed the spec; RHSC triggers
  		 * on an edge, like setting and maybe clearing a port status
  		 * change bit.  With others it's level-triggered, active
! 		 * until hub_wq clears all the port status change bits.  We'll
! 		 * always disable it here and rely on polling until hub_wq
  		 * re-enables it.
  		 */
  		ohci_writel(ohci, OHCI_INTR_RHSC, &regs->intrdisable);
--- 849,856 ----
  		 * choices for RHSC.  Many followed the spec; RHSC triggers
  		 * on an edge, like setting and maybe clearing a port status
  		 * change bit.  With others it's level-triggered, active
! 		 * until khubd clears all the port status change bits.  We'll
! 		 * always disable it here and rely on polling until khubd
  		 * re-enables it.
  		 */
  		ohci_writel(ohci, OHCI_INTR_RHSC, &regs->intrdisable);
***************
*** 923,929 ****
  	 * this might not happen.
  	 */
  	else if (ints & OHCI_INTR_RD) {
! 		ohci_dbg(ohci, "resume detect\n");
  		ohci_writel(ohci, OHCI_INTR_RD, &regs->intrstatus);
  		set_bit(HCD_FLAG_POLL_RH, &hcd->flags);
  		if (ohci->autostop) {
--- 862,868 ----
  	 * this might not happen.
  	 */
  	else if (ints & OHCI_INTR_RD) {
! 		ohci_vdbg(ohci, "resume detect\n");
  		ohci_writel(ohci, OHCI_INTR_RD, &regs->intrstatus);
  		set_bit(HCD_FLAG_POLL_RH, &hcd->flags);
  		if (ohci->autostop) {
***************
*** 934,963 ****
  			usb_hcd_resume_root_hub(hcd);
  	}
  
! 	spin_lock(&ohci->lock);
! 	if (ints & OHCI_INTR_WDH)
! 		update_done_list(ohci);
  
  	/* could track INTR_SO to reduce available PCI/... bandwidth */
  
  	/* handle any pending URB/ED unlinks, leaving INTR_SF enabled
  	 * when there's still unlinking to be done (next frame).
  	 */
! 	ohci_work(ohci);
! 	if ((ints & OHCI_INTR_SF) != 0 && !ohci->ed_rm_list
  			&& ohci->rh_state == OHCI_RH_RUNNING)
  		ohci_writel (ohci, OHCI_INTR_SF, &regs->intrdisable);
  
  	if (ohci->rh_state == OHCI_RH_RUNNING) {
  		ohci_writel (ohci, ints, &regs->intrstatus);
- 		if (ints & OHCI_INTR_WDH)
- 			++ohci->wdh_cnt;
- 
  		ohci_writel (ohci, OHCI_INTR_MIE, &regs->intrenable);
  		// flush those writes
  		(void) ohci_readl (ohci, &ohci->regs->control);
  	}
- 	spin_unlock(&ohci->lock);
  
  	return IRQ_HANDLED;
  }
--- 873,930 ----
  			usb_hcd_resume_root_hub(hcd);
  	}
  
! 	if (ints & OHCI_INTR_WDH) {
! 		spin_lock (&ohci->lock);
! 		dl_done_list (ohci);
! 		spin_unlock (&ohci->lock);
! 	}
! 
! 	if (quirk_zfmicro(ohci) && (ints & OHCI_INTR_SF)) {
! 		spin_lock(&ohci->lock);
! 		if (ohci->ed_to_check) {
! 			struct ed *ed = ohci->ed_to_check;
! 
! 			if (check_ed(ohci, ed)) {
! 				/* HC thinks the TD list is empty; HCD knows
! 				 * at least one TD is outstanding
! 				 */
! 				if (--ohci->zf_delay == 0) {
! 					struct td *td = list_entry(
! 						ed->td_list.next,
! 						struct td, td_list);
! 					ohci_warn(ohci,
! 						  "Reclaiming orphan TD %p\n",
! 						  td);
! 					takeback_td(ohci, td);
! 					ohci->ed_to_check = NULL;
! 				}
! 			} else
! 				ohci->ed_to_check = NULL;
! 		}
! 		spin_unlock(&ohci->lock);
! 	}
  
  	/* could track INTR_SO to reduce available PCI/... bandwidth */
  
  	/* handle any pending URB/ED unlinks, leaving INTR_SF enabled
  	 * when there's still unlinking to be done (next frame).
  	 */
! 	spin_lock (&ohci->lock);
! 	if (ohci->ed_rm_list)
! 		finish_unlinks (ohci, ohci_frame_no(ohci));
! 	if ((ints & OHCI_INTR_SF) != 0
! 			&& !ohci->ed_rm_list
! 			&& !ohci->ed_to_check
  			&& ohci->rh_state == OHCI_RH_RUNNING)
  		ohci_writel (ohci, OHCI_INTR_SF, &regs->intrdisable);
+ 	spin_unlock (&ohci->lock);
  
  	if (ohci->rh_state == OHCI_RH_RUNNING) {
  		ohci_writel (ohci, ints, &regs->intrstatus);
  		ohci_writel (ohci, OHCI_INTR_MIE, &regs->intrenable);
  		// flush those writes
  		(void) ohci_readl (ohci, &ohci->regs->control);
  	}
  
  	return IRQ_HANDLED;
  }
***************
*** 968,984 ****
  {
  	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
  
! 	ohci_dump(ohci);
  
  	if (quirk_nec(ohci))
  		flush_work(&ohci->nec_work);
- 	del_timer_sync(&ohci->io_watchdog);
  
  	ohci_writel (ohci, OHCI_INTR_MIE, &ohci->regs->intrdisable);
  	ohci_usb_reset(ohci);
  	free_irq(hcd->irq, hcd);
  	hcd->irq = 0;
  
  	if (quirk_amdiso(ohci))
  		usb_amd_dev_put();
  
--- 935,952 ----
  {
  	struct ohci_hcd		*ohci = hcd_to_ohci (hcd);
  
! 	ohci_dump (ohci, 1);
  
  	if (quirk_nec(ohci))
  		flush_work(&ohci->nec_work);
  
  	ohci_writel (ohci, OHCI_INTR_MIE, &ohci->regs->intrdisable);
  	ohci_usb_reset(ohci);
  	free_irq(hcd->irq, hcd);
  	hcd->irq = 0;
  
+ 	if (quirk_zfmicro(ohci))
+ 		del_timer(&ohci->unlink_watchdog);
  	if (quirk_amdiso(ohci))
  		usb_amd_dev_put();
  
***************
*** 1035,1041 ****
  		if (!urb->unlinked)
  			urb->unlinked = -ESHUTDOWN;
  	}
! 	ohci_work(ohci);
  	spin_unlock_irq(&ohci->lock);
  
  	/* paranoia, in case that didn't work: */
--- 1003,1009 ----
  		if (!urb->unlinked)
  			urb->unlinked = -ESHUTDOWN;
  	}
! 	finish_unlinks (ohci, 0);
  	spin_unlock_irq(&ohci->lock);
  
  	/* paranoia, in case that didn't work: */
***************
*** 1068,1074 ****
  {
  	struct ohci_hcd	*ohci = hcd_to_ohci (hcd);
  	unsigned long	flags;
- 	int		rc = 0;
  
  	/* Disable irq emission and mark HW unaccessible. Use
  	 * the spinlock to properly synchronize with possible pending
--- 1036,1041 ----
***************
*** 1081,1093 ****
  	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
  	spin_unlock_irqrestore (&ohci->lock, flags);
  
! 	synchronize_irq(hcd->irq);
! 
! 	if (do_wakeup && HCD_WAKEUP_PENDING(hcd)) {
! 		ohci_resume(hcd, false);
! 		rc = -EBUSY;
! 	}
! 	return rc;
  }
  EXPORT_SYMBOL_GPL(ohci_suspend);
  
--- 1048,1054 ----
  	clear_bit(HCD_FLAG_HW_ACCESSIBLE, &hcd->flags);
  	spin_unlock_irqrestore (&ohci->lock, flags);
  
! 	return 0;
  }
  EXPORT_SYMBOL_GPL(ohci_suspend);
  
***************
*** 1200,1211 ****
  	/* Copy the generic table to drv and then apply the overrides */
  	*drv = ohci_hc_driver;
  
! 	if (over) {
! 		drv->product_desc = over->product_desc;
! 		drv->hcd_priv_size += over->extra_priv_size;
! 		if (over->reset)
! 			drv->reset = over->reset;
! 	}
  }
  EXPORT_SYMBOL_GPL(ohci_init_driver);
  
--- 1161,1170 ----
  	/* Copy the generic table to drv and then apply the overrides */
  	*drv = ohci_hc_driver;
  
! 	drv->product_desc = over->product_desc;
! 	drv->hcd_priv_size += over->extra_priv_size;
! 	if (over->reset)
! 		drv->reset = over->reset;
  }
  EXPORT_SYMBOL_GPL(ohci_init_driver);
  
***************
*** 1220,1226 ****
  #define SA1111_DRIVER		ohci_hcd_sa1111_driver
  #endif
  
! #ifdef CONFIG_USB_OHCI_HCD_DAVINCI
  #include "ohci-da8xx.c"
  #define DAVINCI_PLATFORM_DRIVER	ohci_hcd_da8xx_driver
  #endif
--- 1179,1225 ----
  #define SA1111_DRIVER		ohci_hcd_sa1111_driver
  #endif
  
! #if defined(CONFIG_ARCH_S3C24XX) || defined(CONFIG_ARCH_S3C64XX)
! #include "ohci-s3c2410.c"
! #define S3C2410_PLATFORM_DRIVER	ohci_hcd_s3c2410_driver
! #endif
! 
! #ifdef CONFIG_USB_OHCI_EXYNOS
! #include "ohci-exynos.c"
! #define EXYNOS_PLATFORM_DRIVER	exynos_ohci_driver
! #endif
! 
! #ifdef CONFIG_USB_OHCI_HCD_OMAP1
! #include "ohci-omap.c"
! #define OMAP1_PLATFORM_DRIVER	ohci_hcd_omap_driver
! #endif
! 
! #ifdef CONFIG_USB_OHCI_HCD_OMAP3
! #include "ohci-omap3.c"
! #define OMAP3_PLATFORM_DRIVER	ohci_hcd_omap3_driver
! #endif
! 
! #if defined(CONFIG_PXA27x) || defined(CONFIG_PXA3xx)
! #include "ohci-pxa27x.c"
! #define PLATFORM_DRIVER		ohci_hcd_pxa27x_driver
! #endif
! 
! #ifdef CONFIG_ARCH_EP93XX
! #include "ohci-ep93xx.c"
! #define EP93XX_PLATFORM_DRIVER	ohci_hcd_ep93xx_driver
! #endif
! 
! #ifdef CONFIG_ARCH_AT91
! #include "ohci-at91.c"
! #define AT91_PLATFORM_DRIVER	ohci_hcd_at91_driver
! #endif
! 
! #ifdef CONFIG_ARCH_LPC32XX
! #include "ohci-nxp.c"
! #define NXP_PLATFORM_DRIVER	usb_hcd_nxp_driver
! #endif
! 
! #ifdef CONFIG_ARCH_DAVINCI_DA8XX
  #include "ohci-da8xx.c"
  #define DAVINCI_PLATFORM_DRIVER	ohci_hcd_da8xx_driver
  #endif
***************
*** 1230,1235 ****
--- 1229,1244 ----
  #define OF_PLATFORM_DRIVER	ohci_hcd_ppc_of_driver
  #endif
  
+ #ifdef CONFIG_USB_OHCI_HCD_HLWD
+ #include "ohci-hlwd.c"
+ #define OF_PLATFORM_DRIVER	ohci_hcd_hlwd_driver
+ #endif
+ 
+ #ifdef CONFIG_PLAT_SPEAR
+ #include "ohci-spear.c"
+ #define SPEAR_PLATFORM_DRIVER	spear_ohci_hcd_driver
+ #endif
+ 
  #ifdef CONFIG_PPC_PS3
  #include "ohci-ps3.c"
  #define PS3_SYSTEM_BUS_DRIVER	ps3_ohci_driver
***************
*** 1250,1255 ****
--- 1259,1269 ----
  #define PLATFORM_DRIVER	ohci_hcd_jz4740_driver
  #endif
  
+ #ifdef CONFIG_USB_OCTEON_OHCI
+ #include "ohci-octeon.c"
+ #define PLATFORM_DRIVER		ohci_octeon_driver
+ #endif
+ 
  #ifdef CONFIG_TILE_USB
  #include "ohci-tilegx.c"
  #define PLATFORM_DRIVER		ohci_hcd_tilegx_driver
***************
*** 1267,1277 ****
--- 1281,1293 ----
  		sizeof (struct ed), sizeof (struct td));
  	set_bit(USB_OHCI_LOADED, &usb_hcds_loaded);
  
+ #ifdef DEBUG
  	ohci_debug_root = debugfs_create_dir("ohci", usb_debug_root);
  	if (!ohci_debug_root) {
  		retval = -ENOENT;
  		goto error_debug;
  	}
+ #endif
  
  #ifdef PS3_SYSTEM_BUS_DRIVER
  	retval = ps3_ohci_driver_register(&PS3_SYSTEM_BUS_DRIVER);
***************
*** 1285,1290 ****
--- 1301,1318 ----
  		goto error_platform;
  #endif
  
+ #ifdef OMAP1_PLATFORM_DRIVER
+ 	retval = platform_driver_register(&OMAP1_PLATFORM_DRIVER);
+ 	if (retval < 0)
+ 		goto error_omap1_platform;
+ #endif
+ 
+ #ifdef OMAP3_PLATFORM_DRIVER
+ 	retval = platform_driver_register(&OMAP3_PLATFORM_DRIVER);
+ 	if (retval < 0)
+ 		goto error_omap3_platform;
+ #endif
+ 
  #ifdef OF_PLATFORM_DRIVER
  	retval = platform_driver_register(&OF_PLATFORM_DRIVER);
  	if (retval < 0)
***************
*** 1309,1327 ****
--- 1337,1415 ----
  		goto error_tmio;
  #endif
  
+ #ifdef S3C2410_PLATFORM_DRIVER
+ 	retval = platform_driver_register(&S3C2410_PLATFORM_DRIVER);
+ 	if (retval < 0)
+ 		goto error_s3c2410;
+ #endif
+ 
+ #ifdef EXYNOS_PLATFORM_DRIVER
+ 	retval = platform_driver_register(&EXYNOS_PLATFORM_DRIVER);
+ 	if (retval < 0)
+ 		goto error_exynos;
+ #endif
+ 
+ #ifdef EP93XX_PLATFORM_DRIVER
+ 	retval = platform_driver_register(&EP93XX_PLATFORM_DRIVER);
+ 	if (retval < 0)
+ 		goto error_ep93xx;
+ #endif
+ 
+ #ifdef AT91_PLATFORM_DRIVER
+ 	retval = platform_driver_register(&AT91_PLATFORM_DRIVER);
+ 	if (retval < 0)
+ 		goto error_at91;
+ #endif
+ 
+ #ifdef NXP_PLATFORM_DRIVER
+ 	retval = platform_driver_register(&NXP_PLATFORM_DRIVER);
+ 	if (retval < 0)
+ 		goto error_nxp;
+ #endif
+ 
  #ifdef DAVINCI_PLATFORM_DRIVER
  	retval = platform_driver_register(&DAVINCI_PLATFORM_DRIVER);
  	if (retval < 0)
  		goto error_davinci;
  #endif
  
+ #ifdef SPEAR_PLATFORM_DRIVER
+ 	retval = platform_driver_register(&SPEAR_PLATFORM_DRIVER);
+ 	if (retval < 0)
+ 		goto error_spear;
+ #endif
+ 
  	return retval;
  
  	/* Error path */
+ #ifdef SPEAR_PLATFORM_DRIVER
+ 	platform_driver_unregister(&SPEAR_PLATFORM_DRIVER);
+  error_spear:
+ #endif
  #ifdef DAVINCI_PLATFORM_DRIVER
  	platform_driver_unregister(&DAVINCI_PLATFORM_DRIVER);
   error_davinci:
  #endif
+ #ifdef NXP_PLATFORM_DRIVER
+ 	platform_driver_unregister(&NXP_PLATFORM_DRIVER);
+  error_nxp:
+ #endif
+ #ifdef AT91_PLATFORM_DRIVER
+ 	platform_driver_unregister(&AT91_PLATFORM_DRIVER);
+  error_at91:
+ #endif
+ #ifdef EP93XX_PLATFORM_DRIVER
+ 	platform_driver_unregister(&EP93XX_PLATFORM_DRIVER);
+  error_ep93xx:
+ #endif
+ #ifdef EXYNOS_PLATFORM_DRIVER
+ 	platform_driver_unregister(&EXYNOS_PLATFORM_DRIVER);
+  error_exynos:
+ #endif
+ #ifdef S3C2410_PLATFORM_DRIVER
+ 	platform_driver_unregister(&S3C2410_PLATFORM_DRIVER);
+  error_s3c2410:
+ #endif
  #ifdef TMIO_OHCI_DRIVER
  	platform_driver_unregister(&TMIO_OHCI_DRIVER);
   error_tmio:
***************
*** 1338,1343 ****
--- 1426,1439 ----
  	platform_driver_unregister(&OF_PLATFORM_DRIVER);
   error_of_platform:
  #endif
+ #ifdef OMAP3_PLATFORM_DRIVER
+ 	platform_driver_unregister(&OMAP3_PLATFORM_DRIVER);
+  error_omap3_platform:
+ #endif
+ #ifdef OMAP1_PLATFORM_DRIVER
+ 	platform_driver_unregister(&OMAP1_PLATFORM_DRIVER);
+  error_omap1_platform:
+ #endif
  #ifdef PLATFORM_DRIVER
  	platform_driver_unregister(&PLATFORM_DRIVER);
   error_platform:
***************
*** 1346,1354 ****
--- 1442,1452 ----
  	ps3_ohci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
   error_ps3:
  #endif
+ #ifdef DEBUG
  	debugfs_remove(ohci_debug_root);
  	ohci_debug_root = NULL;
   error_debug:
+ #endif
  
  	clear_bit(USB_OHCI_LOADED, &usb_hcds_loaded);
  	return retval;
***************
*** 1357,1365 ****
--- 1455,1481 ----
  
  static void __exit ohci_hcd_mod_exit(void)
  {
+ #ifdef SPEAR_PLATFORM_DRIVER
+ 	platform_driver_unregister(&SPEAR_PLATFORM_DRIVER);
+ #endif
  #ifdef DAVINCI_PLATFORM_DRIVER
  	platform_driver_unregister(&DAVINCI_PLATFORM_DRIVER);
  #endif
+ #ifdef NXP_PLATFORM_DRIVER
+ 	platform_driver_unregister(&NXP_PLATFORM_DRIVER);
+ #endif
+ #ifdef AT91_PLATFORM_DRIVER
+ 	platform_driver_unregister(&AT91_PLATFORM_DRIVER);
+ #endif
+ #ifdef EP93XX_PLATFORM_DRIVER
+ 	platform_driver_unregister(&EP93XX_PLATFORM_DRIVER);
+ #endif
+ #ifdef EXYNOS_PLATFORM_DRIVER
+ 	platform_driver_unregister(&EXYNOS_PLATFORM_DRIVER);
+ #endif
+ #ifdef S3C2410_PLATFORM_DRIVER
+ 	platform_driver_unregister(&S3C2410_PLATFORM_DRIVER);
+ #endif
  #ifdef TMIO_OHCI_DRIVER
  	platform_driver_unregister(&TMIO_OHCI_DRIVER);
  #endif
***************
*** 1372,1384 ****
--- 1488,1508 ----
  #ifdef OF_PLATFORM_DRIVER
  	platform_driver_unregister(&OF_PLATFORM_DRIVER);
  #endif
+ #ifdef OMAP3_PLATFORM_DRIVER
+ 	platform_driver_unregister(&OMAP3_PLATFORM_DRIVER);
+ #endif
+ #ifdef OMAP1_PLATFORM_DRIVER
+ 	platform_driver_unregister(&OMAP1_PLATFORM_DRIVER);
+ #endif
  #ifdef PLATFORM_DRIVER
  	platform_driver_unregister(&PLATFORM_DRIVER);
  #endif
  #ifdef PS3_SYSTEM_BUS_DRIVER
  	ps3_ohci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
  #endif
+ #ifdef DEBUG
  	debugfs_remove(ohci_debug_root);
+ #endif
  	clear_bit(USB_OHCI_LOADED, &usb_hcds_loaded);
  }
  module_exit(ohci_hcd_mod_exit);
diff -crB /home/rxtx/Desktop/linux-4.3.3/drivers/video/Makefile ./drivers/video/Makefile
*** /home/rxtx/Desktop/linux-4.3.3/drivers/video/Makefile	2015-12-15 16:41:43.000000000 +1100
--- ./drivers/video/Makefile	2015-12-19 19:25:37.072394727 +1100
***************
*** 1,12 ****
  obj-$(CONFIG_VGASTATE)            += vgastate.o
  obj-$(CONFIG_HDMI)                += hdmi.o
  
  obj-$(CONFIG_VT)		  += console/
  obj-$(CONFIG_LOGO)		  += logo/
  obj-y				  += backlight/
  
! obj-y				  += fbdev/
  
  obj-$(CONFIG_VIDEOMODE_HELPERS) += display_timing.o videomode.o
  ifeq ($(CONFIG_OF),y)
  obj-$(CONFIG_VIDEOMODE_HELPERS) += of_display_timing.o of_videomode.o
--- 1,179 ----
+ # Makefile for the Linux video drivers.
+ # 5 Aug 1999, James Simmons, <mailto:jsimmons@users.sf.net>
+ # Rewritten to use lists instead of if-statements.
+ 
+ # Each configuration option enables a list of files.
+ 
  obj-$(CONFIG_VGASTATE)            += vgastate.o
  obj-$(CONFIG_HDMI)                += hdmi.o
+ obj-y                             += fb_notify.o
+ obj-$(CONFIG_FB)                  += fb.o
+ fb-y                              := fbmem.o fbmon.o fbcmap.o fbsysfs.o \
+                                      modedb.o fbcvt.o
+ fb-objs                           := $(fb-y)
  
  obj-$(CONFIG_VT)		  += console/
  obj-$(CONFIG_LOGO)		  += logo/
  obj-y				  += backlight/
  
! obj-$(CONFIG_EXYNOS_VIDEO)     += exynos/
! 
! obj-$(CONFIG_FB_CFB_FILLRECT)  += cfbfillrect.o
! obj-$(CONFIG_FB_CFB_COPYAREA)  += cfbcopyarea.o
! obj-$(CONFIG_FB_CFB_IMAGEBLIT) += cfbimgblt.o
! obj-$(CONFIG_FB_SYS_FILLRECT)  += sysfillrect.o
! obj-$(CONFIG_FB_SYS_COPYAREA)  += syscopyarea.o
! obj-$(CONFIG_FB_SYS_IMAGEBLIT) += sysimgblt.o
! obj-$(CONFIG_FB_SYS_FOPS)      += fb_sys_fops.o
! obj-$(CONFIG_FB_SVGALIB)       += svgalib.o
! obj-$(CONFIG_FB_MACMODES)      += macmodes.o
! obj-$(CONFIG_FB_DDC)           += fb_ddc.o
! obj-$(CONFIG_FB_DEFERRED_IO)   += fb_defio.o
! obj-$(CONFIG_FB_WMT_GE_ROPS)   += wmt_ge_rops.o
! 
! # Hardware specific drivers go first
! obj-$(CONFIG_FB_AMIGA)            += amifb.o c2p_planar.o
! obj-$(CONFIG_FB_ARC)              += arcfb.o
! obj-$(CONFIG_FB_CLPS711X)         += clps711xfb.o
! obj-$(CONFIG_FB_CYBER2000)        += cyber2000fb.o
! obj-$(CONFIG_FB_GRVGA)            += grvga.o
! obj-$(CONFIG_FB_PM2)              += pm2fb.o
! obj-$(CONFIG_FB_PM3)		  += pm3fb.o
! 
! obj-$(CONFIG_FB_I740)		  += i740fb.o
! obj-$(CONFIG_FB_MATROX)		  += matrox/
! obj-$(CONFIG_FB_RIVA)		  += riva/
! obj-$(CONFIG_FB_NVIDIA)		  += nvidia/
! obj-$(CONFIG_FB_ATY)		  += aty/ macmodes.o
! obj-$(CONFIG_FB_ATY128)		  += aty/ macmodes.o
! obj-$(CONFIG_FB_RADEON)		  += aty/
! obj-$(CONFIG_FB_SIS)		  += sis/
! obj-$(CONFIG_FB_VIA)		  += via/
! obj-$(CONFIG_FB_KYRO)             += kyro/
! obj-$(CONFIG_FB_SAVAGE)		  += savage/
! obj-$(CONFIG_FB_GEODE)		  += geode/
! obj-$(CONFIG_FB_MBX)		  += mbx/
! obj-$(CONFIG_FB_NEOMAGIC)         += neofb.o
! obj-$(CONFIG_FB_3DFX)             += tdfxfb.o
! obj-$(CONFIG_FB_CONTROL)          += controlfb.o
! obj-$(CONFIG_FB_PLATINUM)         += platinumfb.o
! obj-$(CONFIG_FB_VALKYRIE)         += valkyriefb.o
! obj-$(CONFIG_FB_CT65550)          += chipsfb.o
! obj-$(CONFIG_FB_IMSTT)            += imsttfb.o
! obj-$(CONFIG_FB_FM2)              += fm2fb.o
! obj-$(CONFIG_FB_VT8623)           += vt8623fb.o
! obj-$(CONFIG_FB_TRIDENT)          += tridentfb.o
! obj-$(CONFIG_FB_LE80578)          += vermilion/
! obj-$(CONFIG_FB_S3)               += s3fb.o
! obj-$(CONFIG_FB_ARK)              += arkfb.o
! obj-$(CONFIG_FB_STI)              += stifb.o
! obj-$(CONFIG_FB_FFB)              += ffb.o sbuslib.o
! obj-$(CONFIG_FB_CG6)              += cg6.o sbuslib.o
! obj-$(CONFIG_FB_CG3)              += cg3.o sbuslib.o
! obj-$(CONFIG_FB_BW2)              += bw2.o sbuslib.o
! obj-$(CONFIG_FB_CG14)             += cg14.o sbuslib.o
! obj-$(CONFIG_FB_P9100)            += p9100.o sbuslib.o
! obj-$(CONFIG_FB_TCX)              += tcx.o sbuslib.o
! obj-$(CONFIG_FB_LEO)              += leo.o sbuslib.o
! obj-$(CONFIG_FB_SGIVW)            += sgivwfb.o
! obj-$(CONFIG_FB_ACORN)            += acornfb.o
! obj-$(CONFIG_FB_ATARI)            += atafb.o c2p_iplan2.o atafb_mfb.o \
!                                      atafb_iplan2p2.o atafb_iplan2p4.o atafb_iplan2p8.o
! obj-$(CONFIG_FB_MAC)              += macfb.o
! obj-$(CONFIG_FB_HECUBA)           += hecubafb.o
! obj-$(CONFIG_FB_N411)             += n411.o
! obj-$(CONFIG_FB_HGA)              += hgafb.o
! obj-$(CONFIG_FB_XVR500)           += sunxvr500.o
! obj-$(CONFIG_FB_XVR2500)          += sunxvr2500.o
! obj-$(CONFIG_FB_XVR1000)          += sunxvr1000.o
! obj-$(CONFIG_FB_IGA)              += igafb.o
! obj-$(CONFIG_FB_APOLLO)           += dnfb.o
! obj-$(CONFIG_FB_Q40)              += q40fb.o
! obj-$(CONFIG_FB_TGA)              += tgafb.o
! obj-$(CONFIG_FB_HP300)            += hpfb.o
! obj-$(CONFIG_FB_G364)             += g364fb.o
! obj-$(CONFIG_FB_EP93XX)		  += ep93xx-fb.o
! obj-$(CONFIG_FB_SA1100)           += sa1100fb.o
! obj-$(CONFIG_FB_HIT)              += hitfb.o
! obj-$(CONFIG_FB_ATMEL)		  += atmel_lcdfb.o
! obj-$(CONFIG_FB_PVR2)             += pvr2fb.o
! obj-$(CONFIG_FB_VOODOO1)          += sstfb.o
! obj-$(CONFIG_FB_ARMCLCD)	  += amba-clcd.o
! obj-$(CONFIG_FB_GOLDFISH)         += goldfishfb.o
! obj-$(CONFIG_FB_68328)            += 68328fb.o
! obj-$(CONFIG_FB_GBE)              += gbefb.o
! obj-$(CONFIG_FB_CIRRUS)		  += cirrusfb.o
! obj-$(CONFIG_FB_ASILIANT)	  += asiliantfb.o
! obj-$(CONFIG_FB_PXA)		  += pxafb.o
! obj-$(CONFIG_FB_PXA168)		  += pxa168fb.o
! obj-$(CONFIG_PXA3XX_GCU)	  += pxa3xx-gcu.o
! obj-$(CONFIG_MMP_DISP)           += mmp/
! obj-$(CONFIG_FB_W100)		  += w100fb.o
! obj-$(CONFIG_FB_TMIO)		  += tmiofb.o
! obj-$(CONFIG_FB_AU1100)		  += au1100fb.o
! obj-$(CONFIG_FB_AU1200)		  += au1200fb.o
! obj-$(CONFIG_FB_VT8500)		  += vt8500lcdfb.o
! obj-$(CONFIG_FB_WM8505)		  += wm8505fb.o
! obj-$(CONFIG_FB_PMAG_AA)	  += pmag-aa-fb.o
! obj-$(CONFIG_FB_PMAG_BA)	  += pmag-ba-fb.o
! obj-$(CONFIG_FB_PMAGB_B)	  += pmagb-b-fb.o
! obj-$(CONFIG_FB_MAXINE)		  += maxinefb.o
! obj-$(CONFIG_FB_METRONOME)        += metronomefb.o
! obj-$(CONFIG_FB_BROADSHEET)       += broadsheetfb.o
! obj-$(CONFIG_FB_AUO_K190X)	  += auo_k190x.o
! obj-$(CONFIG_FB_AUO_K1900)	  += auo_k1900fb.o
! obj-$(CONFIG_FB_AUO_K1901)	  += auo_k1901fb.o
! obj-$(CONFIG_FB_S1D13XXX)	  += s1d13xxxfb.o
! obj-$(CONFIG_FB_SH7760)		  += sh7760fb.o
! obj-$(CONFIG_FB_IMX)              += imxfb.o
! obj-$(CONFIG_FB_S3C)		  += s3c-fb.o
! obj-$(CONFIG_FB_S3C2410)	  += s3c2410fb.o
! obj-$(CONFIG_FB_FSL_DIU)	  += fsl-diu-fb.o
! obj-$(CONFIG_FB_COBALT)           += cobalt_lcdfb.o
! obj-$(CONFIG_FB_IBM_GXT4500)	  += gxt4500.o
! obj-$(CONFIG_FB_PS3)		  += ps3fb.o
! obj-$(CONFIG_FB_SM501)            += sm501fb.o
! obj-$(CONFIG_FB_UDL)		  += udlfb.o
! obj-$(CONFIG_FB_SMSCUFX)	  += smscufx.o
! obj-$(CONFIG_FB_XILINX)           += xilinxfb.o
! obj-$(CONFIG_SH_MIPI_DSI)	  += sh_mipi_dsi.o
! obj-$(CONFIG_FB_SH_MOBILE_HDMI)	  += sh_mobile_hdmi.o
! obj-$(CONFIG_FB_SH_MOBILE_MERAM)  += sh_mobile_meram.o
! obj-$(CONFIG_FB_SH_MOBILE_LCDC)	  += sh_mobile_lcdcfb.o
! obj-$(CONFIG_FB_OMAP)             += omap/
! obj-y                             += omap2/
! obj-$(CONFIG_XEN_FBDEV_FRONTEND)  += xen-fbfront.o
! obj-$(CONFIG_FB_CARMINE)          += carminefb.o
! obj-$(CONFIG_FB_MB862XX)	  += mb862xx/
! obj-$(CONFIG_FB_MSM)              += msm/
! obj-$(CONFIG_FB_GAMECUBE)	  += gcnfb.o
! obj-$(CONFIG_FB_NUC900)           += nuc900fb.o
! obj-$(CONFIG_FB_JZ4740)		  += jz4740_fb.o
! obj-$(CONFIG_FB_PUV3_UNIGFX)      += fb-puv3.o
! obj-$(CONFIG_FB_HYPERV)		  += hyperv_fb.o
! 
! # Platform or fallback drivers go here
! obj-$(CONFIG_FB_UVESA)            += uvesafb.o
! obj-$(CONFIG_FB_VESA)             += vesafb.o
! obj-$(CONFIG_FB_EFI)              += efifb.o
! obj-$(CONFIG_FB_VGA16)            += vga16fb.o
! obj-$(CONFIG_FB_OF)               += offb.o
! obj-$(CONFIG_FB_BF537_LQ035)      += bf537-lq035.o
! obj-$(CONFIG_FB_BF54X_LQ043)	  += bf54x-lq043fb.o
! obj-$(CONFIG_FB_BFIN_LQ035Q1)     += bfin-lq035q1-fb.o
! obj-$(CONFIG_FB_BFIN_T350MCQB)	  += bfin-t350mcqb-fb.o
! obj-$(CONFIG_FB_BFIN_7393)        += bfin_adv7393fb.o
! obj-$(CONFIG_FB_MX3)		  += mx3fb.o
! obj-$(CONFIG_FB_DA8XX)		  += da8xx-fb.o
! obj-$(CONFIG_FB_MXS)		  += mxsfb.o
! obj-$(CONFIG_FB_SSD1307)	  += ssd1307fb.o
! obj-$(CONFIG_FB_SIMPLE)           += simplefb.o
! 
! # the test framebuffer is last
! obj-$(CONFIG_FB_VIRTUAL)          += vfb.o
  
+ #video output switch sysfs driver
+ obj-$(CONFIG_VIDEO_OUTPUT_CONTROL) += output.o
  obj-$(CONFIG_VIDEOMODE_HELPERS) += display_timing.o videomode.o
  ifeq ($(CONFIG_OF),y)
  obj-$(CONFIG_VIDEOMODE_HELPERS) += of_display_timing.o of_videomode.o
diff -crB /home/rxtx/Desktop/linux-4.3.3/include/asm-generic/gpio.h ./include/asm-generic/gpio.h
*** /home/rxtx/Desktop/linux-4.3.3/include/asm-generic/gpio.h	2015-12-15 16:41:43.000000000 +1100
--- ./include/asm-generic/gpio.h	2015-12-19 19:26:24.208442673 +1100
***************
*** 5,16 ****
  #include <linux/types.h>
  #include <linux/errno.h>
  #include <linux/of.h>
  
  #ifdef CONFIG_GPIOLIB
  
  #include <linux/compiler.h>
- #include <linux/gpio/driver.h>
- #include <linux/gpio/consumer.h>
  
  /* Platforms may implement their GPIO interface with library code,
   * at a small performance cost for non-inlined operations and some
--- 5,15 ----
  #include <linux/types.h>
  #include <linux/errno.h>
  #include <linux/of.h>
+ #include <linux/pinctrl/pinctrl.h>
  
  #ifdef CONFIG_GPIOLIB
  
  #include <linux/compiler.h>
  
  /* Platforms may implement their GPIO interface with library code,
   * at a small performance cost for non-inlined operations and some
***************
*** 26,32 ****
   */
  
  #ifndef ARCH_NR_GPIOS
! #define ARCH_NR_GPIOS		512
  #endif
  
  /*
--- 25,31 ----
   */
  
  #ifndef ARCH_NR_GPIOS
! #define ARCH_NR_GPIOS		256
  #endif
  
  /*
***************
*** 50,60 ****
  struct device_node;
  struct gpio_desc;
  
! /* caller holds gpio_lock *OR* gpio is marked as requested */
! static inline struct gpio_chip *gpio_to_chip(unsigned gpio)
! {
! 	return gpiod_to_chip(gpio_to_desc(gpio));
! }
  
  /* Always use the library code for GPIO management calls,
   * or when sleeping may be involved.
--- 49,170 ----
  struct device_node;
  struct gpio_desc;
  
! /**
!  * struct gpio_chip - abstract a GPIO controller
!  * @label: for diagnostics
!  * @dev: optional device providing the GPIOs
!  * @owner: helps prevent removal of modules exporting active GPIOs
!  * @list: links gpio_chips together for traversal
!  * @request: optional hook for chip-specific activation, such as
!  *	enabling module power and clock; may sleep
!  * @free: optional hook for chip-specific deactivation, such as
!  *	disabling module power and clock; may sleep
!  * @get_direction: returns direction for signal "offset", 0=out, 1=in,
!  *	(same as GPIOF_DIR_XXX), or negative error
!  * @direction_input: configures signal "offset" as input, or returns error
!  * @get: returns value for signal "offset"; for output signals this
!  *	returns either the value actually sensed, or zero
!  * @direction_output: configures signal "offset" as output, or returns error
!  * @set_debounce: optional hook for setting debounce time for specified gpio in
!  *      interrupt triggered gpio chips
!  * @set: assigns output value for signal "offset"
!  * @to_irq: optional hook supporting non-static gpio_to_irq() mappings;
!  *	implementation may not sleep
!  * @dbg_show: optional routine to show contents in debugfs; default code
!  *	will be used when this is omitted, but custom code can show extra
!  *	state (such as pullup/pulldown configuration).
!  * @base: identifies the first GPIO number handled by this chip; or, if
!  *	negative during registration, requests dynamic ID allocation.
!  * @ngpio: the number of GPIOs handled by this controller; the last GPIO
!  *	handled is (base + ngpio - 1).
!  * @desc: array of ngpio descriptors. Private.
!  * @can_sleep: flag must be set iff get()/set() methods sleep, as they
!  *	must while accessing GPIO expander chips over I2C or SPI
!  * @names: if set, must be an array of strings to use as alternative
!  *      names for the GPIOs in this chip. Any entry in the array
!  *      may be NULL if there is no alias for the GPIO, however the
!  *      array must be @ngpio entries long.  A name can include a single printk
!  *      format specifier for an unsigned int.  It is substituted by the actual
!  *      number of the gpio.
!  *
!  * A gpio_chip can help platforms abstract various sources of GPIOs so
!  * they can all be accessed through a common programing interface.
!  * Example sources would be SOC controllers, FPGAs, multifunction
!  * chips, dedicated GPIO expanders, and so on.
!  *
!  * Each chip controls a number of signals, identified in method calls
!  * by "offset" values in the range 0..(@ngpio - 1).  When those signals
!  * are referenced through calls like gpio_get_value(gpio), the offset
!  * is calculated by subtracting @base from the gpio number.
!  */
! struct gpio_chip {
! 	const char		*label;
! 	struct device		*dev;
! 	struct module		*owner;
! 	struct list_head        list;
! 
! 	int			(*request)(struct gpio_chip *chip,
! 						unsigned offset);
! 	void			(*free)(struct gpio_chip *chip,
! 						unsigned offset);
! 	int			(*get_direction)(struct gpio_chip *chip,
! 						unsigned offset);
! 	int			(*direction_input)(struct gpio_chip *chip,
! 						unsigned offset);
! 	int			(*get)(struct gpio_chip *chip,
! 						unsigned offset);
! 	int			(*direction_output)(struct gpio_chip *chip,
! 						unsigned offset, int value);
! 	int			(*set_debounce)(struct gpio_chip *chip,
! 						unsigned offset, unsigned debounce);
! 
! 	void			(*set)(struct gpio_chip *chip,
! 						unsigned offset, int value);
! 
! 	int			(*to_irq)(struct gpio_chip *chip,
! 						unsigned offset);
! 
! 	void			(*dbg_show)(struct seq_file *s,
! 						struct gpio_chip *chip);
! 	int			base;
! 	u16			ngpio;
! 	struct gpio_desc	*desc;
! 	const char		*const *names;
! 	unsigned		can_sleep:1;
! 	unsigned		exported:1;
! 
! #if defined(CONFIG_OF_GPIO)
! 	/*
! 	 * If CONFIG_OF is enabled, then all GPIO controllers described in the
! 	 * device tree automatically may have an OF translation
! 	 */
! 	struct device_node *of_node;
! 	int of_gpio_n_cells;
! 	int (*of_xlate)(struct gpio_chip *gc,
! 		        const struct of_phandle_args *gpiospec, u32 *flags);
! #endif
! #ifdef CONFIG_PINCTRL
! 	/*
! 	 * If CONFIG_PINCTRL is enabled, then gpio controllers can optionally
! 	 * describe the actual pin range which they serve in an SoC. This
! 	 * information would be used by pinctrl subsystem to configure
! 	 * corresponding pins for gpio usage.
! 	 */
! 	struct list_head pin_ranges;
! #endif
! };
! 
! extern const char *gpiochip_is_requested(struct gpio_chip *chip,
! 			unsigned offset);
! extern struct gpio_chip *gpio_to_chip(unsigned gpio);
! 
! /* add/remove chips */
! extern int gpiochip_add(struct gpio_chip *chip);
! extern int __must_check gpiochip_remove(struct gpio_chip *chip);
! extern struct gpio_chip *gpiochip_find(void *data,
! 					int (*match)(struct gpio_chip *chip,
! 						     void *data));
! 
  
  /* Always use the library code for GPIO management calls,
   * or when sleeping may be involved.
***************
*** 62,138 ****
  extern int gpio_request(unsigned gpio, const char *label);
  extern void gpio_free(unsigned gpio);
  
! static inline int gpio_direction_input(unsigned gpio)
! {
! 	return gpiod_direction_input(gpio_to_desc(gpio));
! }
! static inline int gpio_direction_output(unsigned gpio, int value)
! {
! 	return gpiod_direction_output_raw(gpio_to_desc(gpio), value);
! }
  
! static inline int gpio_set_debounce(unsigned gpio, unsigned debounce)
! {
! 	return gpiod_set_debounce(gpio_to_desc(gpio), debounce);
! }
  
! static inline int gpio_get_value_cansleep(unsigned gpio)
! {
! 	return gpiod_get_raw_value_cansleep(gpio_to_desc(gpio));
! }
! static inline void gpio_set_value_cansleep(unsigned gpio, int value)
! {
! 	return gpiod_set_raw_value_cansleep(gpio_to_desc(gpio), value);
! }
  
  
  /* A platform's <asm/gpio.h> code may want to inline the I/O calls when
   * the GPIO is constant and refers to some always-present controller,
   * giving direct access to chip registers and tight bitbanging loops.
   */
! static inline int __gpio_get_value(unsigned gpio)
! {
! 	return gpiod_get_raw_value(gpio_to_desc(gpio));
! }
! static inline void __gpio_set_value(unsigned gpio, int value)
! {
! 	return gpiod_set_raw_value(gpio_to_desc(gpio), value);
! }
  
! static inline int __gpio_cansleep(unsigned gpio)
! {
! 	return gpiod_cansleep(gpio_to_desc(gpio));
! }
  
! static inline int __gpio_to_irq(unsigned gpio)
! {
! 	return gpiod_to_irq(gpio_to_desc(gpio));
! }
  
  extern int gpio_request_one(unsigned gpio, unsigned long flags, const char *label);
  extern int gpio_request_array(const struct gpio *array, size_t num);
  extern void gpio_free_array(const struct gpio *array, size_t num);
  
  /*
   * A sysfs interface can be exported by individual drivers if they want,
   * but more typically is configured entirely from userspace.
   */
! static inline int gpio_export(unsigned gpio, bool direction_may_change)
! {
! 	return gpiod_export(gpio_to_desc(gpio), direction_may_change);
! }
  
! static inline int gpio_export_link(struct device *dev, const char *name,
! 				   unsigned gpio)
  {
! 	return gpiod_export_link(dev, name, gpio_to_desc(gpio));
  }
  
! static inline void gpio_unexport(unsigned gpio)
  {
- 	gpiod_unexport(gpio_to_desc(gpio));
  }
  
  #else	/* !CONFIG_GPIOLIB */
  
  static inline bool gpio_is_valid(int number)
--- 172,253 ----
  extern int gpio_request(unsigned gpio, const char *label);
  extern void gpio_free(unsigned gpio);
  
! extern int gpio_direction_input(unsigned gpio);
! extern int gpio_direction_output(unsigned gpio, int value);
! extern int gpio_direction_is_output(unsigned gpio);
  
! extern int gpio_set_debounce(unsigned gpio, unsigned debounce);
  
! extern int gpio_get_value_cansleep(unsigned gpio);
! extern void gpio_set_value_cansleep(unsigned gpio, int value);
  
  
  /* A platform's <asm/gpio.h> code may want to inline the I/O calls when
   * the GPIO is constant and refers to some always-present controller,
   * giving direct access to chip registers and tight bitbanging loops.
   */
! extern int __gpio_get_value(unsigned gpio);
! extern void __gpio_set_value(unsigned gpio, int value);
  
! extern int __gpio_cansleep(unsigned gpio);
  
! extern int __gpio_to_irq(unsigned gpio);
  
  extern int gpio_request_one(unsigned gpio, unsigned long flags, const char *label);
  extern int gpio_request_array(const struct gpio *array, size_t num);
  extern void gpio_free_array(const struct gpio *array, size_t num);
  
+ #ifdef CONFIG_GPIO_SYSFS
+ 
  /*
   * A sysfs interface can be exported by individual drivers if they want,
   * but more typically is configured entirely from userspace.
   */
! extern int gpio_export(unsigned gpio, bool direction_may_change);
! extern int gpio_export_link(struct device *dev, const char *name,
! 			unsigned gpio);
! extern int gpio_sysfs_set_active_low(unsigned gpio, int value);
! extern void gpio_unexport(unsigned gpio);
! 
! #endif	/* CONFIG_GPIO_SYSFS */
! 
! #ifdef CONFIG_PINCTRL
! 
! /**
!  * struct gpio_pin_range - pin range controlled by a gpio chip
!  * @head: list for maintaining set of pin ranges, used internally
!  * @pctldev: pinctrl device which handles corresponding pins
!  * @range: actual range of pins controlled by a gpio controller
!  */
  
! struct gpio_pin_range {
! 	struct list_head node;
! 	struct pinctrl_dev *pctldev;
! 	struct pinctrl_gpio_range range;
! };
! 
! int gpiochip_add_pin_range(struct gpio_chip *chip, const char *pinctl_name,
! 			   unsigned int gpio_offset, unsigned int pin_offset,
! 			   unsigned int npins);
! void gpiochip_remove_pin_ranges(struct gpio_chip *chip);
! 
! #else
! 
! static inline int
! gpiochip_add_pin_range(struct gpio_chip *chip, const char *pinctl_name,
! 		       unsigned int gpio_offset, unsigned int pin_offset,
! 		       unsigned int npins)
  {
! 	return 0;
  }
  
! static inline void
! gpiochip_remove_pin_ranges(struct gpio_chip *chip)
  {
  }
  
+ #endif /* CONFIG_PINCTRL */
+ 
  #else	/* !CONFIG_GPIOLIB */
  
  static inline bool gpio_is_valid(int number)
***************
*** 164,167 ****
--- 279,309 ----
  
  #endif /* !CONFIG_GPIOLIB */
  
+ #ifndef CONFIG_GPIO_SYSFS
+ 
+ struct device;
+ 
+ /* sysfs support is only available with gpiolib, where it's optional */
+ 
+ static inline int gpio_export(unsigned gpio, bool direction_may_change)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ static inline int gpio_export_link(struct device *dev, const char *name,
+ 				unsigned gpio)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ static inline int gpio_sysfs_set_active_low(unsigned gpio, int value)
+ {
+ 	return -ENOSYS;
+ }
+ 
+ static inline void gpio_unexport(unsigned gpio)
+ {
+ }
+ #endif	/* CONFIG_GPIO_SYSFS */
+ 
  #endif /* _ASM_GENERIC_GPIO_H */
diff -crB /home/rxtx/Desktop/linux-4.3.3/include/linux/kexec.h ./include/linux/kexec.h
*** /home/rxtx/Desktop/linux-4.3.3/include/linux/kexec.h	2015-12-15 16:41:43.000000000 +1100
--- ./include/linux/kexec.h	2015-12-19 19:27:32.020551551 +1100
***************
*** 1,29 ****
  #ifndef LINUX_KEXEC_H
  #define LINUX_KEXEC_H
  
- #define IND_DESTINATION_BIT 0
- #define IND_INDIRECTION_BIT 1
- #define IND_DONE_BIT        2
- #define IND_SOURCE_BIT      3
- 
- #define IND_DESTINATION  (1 << IND_DESTINATION_BIT)
- #define IND_INDIRECTION  (1 << IND_INDIRECTION_BIT)
- #define IND_DONE         (1 << IND_DONE_BIT)
- #define IND_SOURCE       (1 << IND_SOURCE_BIT)
- #define IND_FLAGS (IND_DESTINATION | IND_INDIRECTION | IND_DONE | IND_SOURCE)
- 
- #if !defined(__ASSEMBLY__)
- 
  #include <uapi/linux/kexec.h>
  
! #ifdef CONFIG_KEXEC_CORE
  #include <linux/list.h>
  #include <linux/linkage.h>
  #include <linux/compat.h>
  #include <linux/ioport.h>
  #include <linux/elfcore.h>
  #include <linux/elf.h>
- #include <linux/module.h>
  #include <asm/kexec.h>
  
  /* Verify architecture specific macros are defined */
--- 1,15 ----
  #ifndef LINUX_KEXEC_H
  #define LINUX_KEXEC_H
  
  #include <uapi/linux/kexec.h>
  
! #ifdef CONFIG_KEXEC
  #include <linux/list.h>
  #include <linux/linkage.h>
  #include <linux/compat.h>
  #include <linux/ioport.h>
  #include <linux/elfcore.h>
  #include <linux/elf.h>
  #include <asm/kexec.h>
  
  /* Verify architecture specific macros are defined */
***************
*** 40,49 ****
  #error KEXEC_CONTROL_MEMORY_LIMIT not defined
  #endif
  
- #ifndef KEXEC_CONTROL_MEMORY_GFP
- #define KEXEC_CONTROL_MEMORY_GFP GFP_KERNEL
- #endif
- 
  #ifndef KEXEC_CONTROL_PAGE_SIZE
  #error KEXEC_CONTROL_PAGE_SIZE not defined
  #endif
--- 26,31 ----
***************
*** 81,100 ****
   */
  
  typedef unsigned long kimage_entry_t;
  
  struct kexec_segment {
! 	/*
! 	 * This pointer can point to user memory if kexec_load() system
! 	 * call is used or will point to kernel memory if
! 	 * kexec_file_load() system call is used.
! 	 *
! 	 * Use ->buf when expecting to deal with user memory and use ->kbuf
! 	 * when expecting to deal with kernel memory.
! 	 */
! 	union {
! 		void __user *buf;
! 		void *kbuf;
! 	};
  	size_t bufsz;
  	unsigned long mem;
  	size_t memsz;
--- 63,76 ----
   */
  
  typedef unsigned long kimage_entry_t;
+ #define IND_DESTINATION  0x01
+ #define IND_INDIRECTION  0x02
+ #define IND_DONE         0x04
+ #define IND_SOURCE       0x08
+ #define IND_NOALLOC      0x10 /* special case for memory preserving code */
  
  struct kexec_segment {
! 	void __user *buf;
  	size_t bufsz;
  	unsigned long mem;
  	size_t memsz;
***************
*** 109,140 ****
  };
  #endif
  
- struct kexec_sha_region {
- 	unsigned long start;
- 	unsigned long len;
- };
- 
- struct purgatory_info {
- 	/* Pointer to elf header of read only purgatory */
- 	Elf_Ehdr *ehdr;
- 
- 	/* Pointer to purgatory sechdrs which are modifiable */
- 	Elf_Shdr *sechdrs;
- 	/*
- 	 * Temporary buffer location where purgatory is loaded and relocated
- 	 * This memory can be freed post image load
- 	 */
- 	void *purgatory_buf;
- 
- 	/* Address where purgatory is finally loaded and is executed from */
- 	unsigned long purgatory_load_addr;
- };
- 
  struct kimage {
  	kimage_entry_t head;
  	kimage_entry_t *entry;
  	kimage_entry_t *last_entry;
  
  	unsigned long start;
  	struct page *control_code_page;
  	struct page *swap_page;
--- 85,97 ----
  };
  #endif
  
  struct kimage {
  	kimage_entry_t head;
  	kimage_entry_t *entry;
  	kimage_entry_t *last_entry;
  
+ 	unsigned long destination;
+ 
  	unsigned long start;
  	struct page *control_code_page;
  	struct page *swap_page;
***************
*** 144,150 ****
  
  	struct list_head control_pages;
  	struct list_head dest_pages;
! 	struct list_head unusable_pages;
  
  	/* Address of next control page to allocate for crash kernels. */
  	unsigned long control_page;
--- 101,107 ----
  
  	struct list_head control_pages;
  	struct list_head dest_pages;
! 	struct list_head unuseable_pages;
  
  	/* Address of next control page to allocate for crash kernels. */
  	unsigned long control_page;
***************
*** 154,217 ****
  #define KEXEC_TYPE_DEFAULT 0
  #define KEXEC_TYPE_CRASH   1
  	unsigned int preserve_context : 1;
- 	/* If set, we are using file mode kexec syscall */
- 	unsigned int file_mode:1;
  
  #ifdef ARCH_HAS_KIMAGE_ARCH
  	struct kimage_arch arch;
  #endif
- 
- 	/* Additional fields for file based kexec syscall */
- 	void *kernel_buf;
- 	unsigned long kernel_buf_len;
- 
- 	void *initrd_buf;
- 	unsigned long initrd_buf_len;
- 
- 	char *cmdline_buf;
- 	unsigned long cmdline_buf_len;
- 
- 	/* File operations provided by image loader */
- 	struct kexec_file_ops *fops;
- 
- 	/* Image loader handling the kernel can store a pointer here */
- 	void *image_loader_data;
- 
- 	/* Information for loading purgatory */
- 	struct purgatory_info purgatory_info;
  };
  
- /*
-  * Keeps track of buffer parameters as provided by caller for requesting
-  * memory placement of buffer.
-  */
- struct kexec_buf {
- 	struct kimage *image;
- 	char *buffer;
- 	unsigned long bufsz;
- 	unsigned long mem;
- 	unsigned long memsz;
- 	unsigned long buf_align;
- 	unsigned long buf_min;
- 	unsigned long buf_max;
- 	bool top_down;		/* allocate from top of memory hole */
- };
  
- typedef int (kexec_probe_t)(const char *kernel_buf, unsigned long kernel_size);
- typedef void *(kexec_load_t)(struct kimage *image, char *kernel_buf,
- 			     unsigned long kernel_len, char *initrd,
- 			     unsigned long initrd_len, char *cmdline,
- 			     unsigned long cmdline_len);
- typedef int (kexec_cleanup_t)(void *loader_data);
- typedef int (kexec_verify_sig_t)(const char *kernel_buf,
- 				 unsigned long kernel_len);
- 
- struct kexec_file_ops {
- 	kexec_probe_t *probe;
- 	kexec_load_t *load;
- 	kexec_cleanup_t *cleanup;
- 	kexec_verify_sig_t *verify_sig;
- };
  
  /* kexec interface functions */
  extern void machine_kexec(struct kimage *image);
--- 111,123 ----
***************
*** 222,242 ****
  					struct kexec_segment __user *segments,
  					unsigned long flags);
  extern int kernel_kexec(void);
! extern int kexec_add_buffer(struct kimage *image, char *buffer,
! 			    unsigned long bufsz, unsigned long memsz,
! 			    unsigned long buf_align, unsigned long buf_min,
! 			    unsigned long buf_max, bool top_down,
! 			    unsigned long *load_addr);
  extern struct page *kimage_alloc_control_pages(struct kimage *image,
  						unsigned int order);
! extern int kexec_load_purgatory(struct kimage *image, unsigned long min,
! 				unsigned long max, int top_down,
! 				unsigned long *load_addr);
! extern int kexec_purgatory_get_set_symbol(struct kimage *image,
! 					  const char *name, void *buf,
! 					  unsigned int size, bool get_value);
! extern void *kexec_purgatory_get_symbol_addr(struct kimage *image,
! 					     const char *name);
  extern void crash_kexec(struct pt_regs *);
  int kexec_should_crash(struct task_struct *);
  void crash_save_cpu(struct pt_regs *regs, int cpu);
--- 128,143 ----
  					struct kexec_segment __user *segments,
  					unsigned long flags);
  extern int kernel_kexec(void);
! #ifdef CONFIG_COMPAT
! extern asmlinkage long compat_sys_kexec_load(unsigned long entry,
! 				unsigned long nr_segments,
! 				struct compat_kexec_segment __user *segments,
! 				unsigned long flags);
! #endif
  extern struct page *kimage_alloc_control_pages(struct kimage *image,
  						unsigned int order);
! extern int kimage_add_preserved_region(struct kimage *image, unsigned long to,
! 				       unsigned long from, int length);
  extern void crash_kexec(struct pt_regs *);
  int kexec_should_crash(struct task_struct *);
  void crash_save_cpu(struct pt_regs *regs, int cpu);
***************
*** 272,278 ****
  
  extern struct kimage *kexec_image;
  extern struct kimage *kexec_crash_image;
- extern int kexec_load_disabled;
  
  #ifndef kexec_flush_icache_page
  #define kexec_flush_icache_page(page)
--- 173,178 ----
***************
*** 285,294 ****
  #define KEXEC_FLAGS    (KEXEC_ON_CRASH | KEXEC_PRESERVE_CONTEXT)
  #endif
  
- /* List of defined/legal kexec file flags */
- #define KEXEC_FILE_FLAGS	(KEXEC_FILE_UNLOAD | KEXEC_FILE_ON_CRASH | \
- 				 KEXEC_FILE_NO_INITRAMFS)
- 
  #define VMCOREINFO_BYTES           (4096)
  #define VMCOREINFO_NOTE_NAME       "VMCOREINFO"
  #define VMCOREINFO_NOTE_NAME_BYTES ALIGN(sizeof(VMCOREINFO_NOTE_NAME), 4)
--- 185,190 ----
***************
*** 318,342 ****
  size_t crash_get_memory_size(void);
  void crash_free_reserved_phys_range(unsigned long begin, unsigned long end);
  
! int __weak arch_kexec_kernel_image_probe(struct kimage *image, void *buf,
! 					 unsigned long buf_len);
! void * __weak arch_kexec_kernel_image_load(struct kimage *image);
! int __weak arch_kimage_file_post_load_cleanup(struct kimage *image);
! int __weak arch_kexec_kernel_verify_sig(struct kimage *image, void *buf,
! 					unsigned long buf_len);
! int __weak arch_kexec_apply_relocations_add(const Elf_Ehdr *ehdr,
! 					Elf_Shdr *sechdrs, unsigned int relsec);
! int __weak arch_kexec_apply_relocations(const Elf_Ehdr *ehdr, Elf_Shdr *sechdrs,
! 					unsigned int relsec);
! 
! #else /* !CONFIG_KEXEC_CORE */
  struct pt_regs;
  struct task_struct;
  static inline void crash_kexec(struct pt_regs *regs) { }
  static inline int kexec_should_crash(struct task_struct *p) { return 0; }
! #define kexec_in_progress false
! #endif /* CONFIG_KEXEC_CORE */
! 
! #endif /* !defined(__ASSEBMLY__) */
! 
  #endif /* LINUX_KEXEC_H */
--- 214,223 ----
  size_t crash_get_memory_size(void);
  void crash_free_reserved_phys_range(unsigned long begin, unsigned long end);
  
! #else /* !CONFIG_KEXEC */
  struct pt_regs;
  struct task_struct;
  static inline void crash_kexec(struct pt_regs *regs) { }
  static inline int kexec_should_crash(struct task_struct *p) { return 0; }
! #endif /* CONFIG_KEXEC */
  #endif /* LINUX_KEXEC_H */
diff -crB /home/rxtx/Desktop/linux-4.3.3/kernel/kexec.c ./kernel/kexec.c
*** /home/rxtx/Desktop/linux-4.3.3/kernel/kexec.c	2015-12-15 16:41:43.000000000 +1100
--- ./kernel/kexec.c	2015-12-19 19:28:27.264671401 +1100
***************
*** 1,5 ****
  /*
!  * kexec.c - kexec_load system call
   * Copyright (C) 2002-2004 Eric Biederman  <ebiederm@xmission.com>
   *
   * This source code is licensed under the GNU General Public License,
--- 1,5 ----
  /*
!  * kexec.c - kexec system call
   * Copyright (C) 2002-2004 Eric Biederman  <ebiederm@xmission.com>
   *
   * This source code is licensed under the GNU General Public License,
***************
*** 9,104 ****
  #include <linux/capability.h>
  #include <linux/mm.h>
  #include <linux/file.h>
  #include <linux/kexec.h>
  #include <linux/mutex.h>
  #include <linux/list.h>
  #include <linux/syscalls.h>
  #include <linux/vmalloc.h>
! #include <linux/slab.h>
  
! #include "kexec_internal.h"
  
! static int copy_user_segment_list(struct kimage *image,
! 				  unsigned long nr_segments,
! 				  struct kexec_segment __user *segments)
  {
- 	int ret;
  	size_t segment_bytes;
  
  	/* Read in the segments */
  	image->nr_segments = nr_segments;
  	segment_bytes = nr_segments * sizeof(*segments);
! 	ret = copy_from_user(image->segment, segments, segment_bytes);
! 	if (ret)
! 		ret = -EFAULT;
  
- 	return ret;
  }
  
! static int kimage_alloc_init(struct kimage **rimage, unsigned long entry,
! 			     unsigned long nr_segments,
! 			     struct kexec_segment __user *segments,
! 			     unsigned long flags)
  {
! 	int ret;
  	struct kimage *image;
- 	bool kexec_on_panic = flags & KEXEC_ON_CRASH;
  
! 	if (kexec_on_panic) {
! 		/* Verify we have a valid entry point */
! 		if ((entry < crashk_res.start) || (entry > crashk_res.end))
! 			return -EADDRNOTAVAIL;
  	}
  
  	/* Allocate and initialize a controlling structure */
! 	image = do_kimage_alloc_init();
! 	if (!image)
! 		return -ENOMEM;
  
! 	image->start = entry;
  
! 	ret = copy_user_segment_list(image, nr_segments, segments);
! 	if (ret)
! 		goto out_free_image;
! 
! 	ret = sanity_check_segment_list(image);
! 	if (ret)
! 		goto out_free_image;
! 
! 	 /* Enable the special crash kernel control page allocation policy. */
! 	if (kexec_on_panic) {
! 		image->control_page = crashk_res.start;
! 		image->type = KEXEC_TYPE_CRASH;
  	}
  
  	/*
! 	 * Find a location for the control code buffer, and add it
  	 * the vector of segments so that it's pages will also be
  	 * counted as destination pages.
  	 */
! 	ret = -ENOMEM;
  	image->control_code_page = kimage_alloc_control_pages(image,
  					   get_order(KEXEC_CONTROL_PAGE_SIZE));
  	if (!image->control_code_page) {
! 		pr_err("Could not allocate control_code_buffer\n");
! 		goto out_free_image;
  	}
  
! 	if (!kexec_on_panic) {
! 		image->swap_page = kimage_alloc_control_pages(image, 0);
! 		if (!image->swap_page) {
! 			pr_err("Could not allocate swap buffer\n");
! 			goto out_free_control_pages;
  		}
  	}
  
- 	*rimage = image;
  	return 0;
! out_free_control_pages:
  	kimage_free_page_list(&image->control_pages);
- out_free_image:
  	kfree(image);
! 	return ret;
  }
  
  /*
--- 9,947 ----
  #include <linux/capability.h>
  #include <linux/mm.h>
  #include <linux/file.h>
+ #include <linux/slab.h>
+ #include <linux/fs.h>
  #include <linux/kexec.h>
  #include <linux/mutex.h>
  #include <linux/list.h>
+ #include <linux/highmem.h>
  #include <linux/syscalls.h>
+ #include <linux/reboot.h>
+ #include <linux/ioport.h>
+ #include <linux/hardirq.h>
+ #include <linux/elf.h>
+ #include <linux/elfcore.h>
+ #include <linux/utsname.h>
+ #include <linux/numa.h>
+ #include <linux/suspend.h>
+ #include <linux/device.h>
+ #include <linux/freezer.h>
+ #include <linux/pm.h>
+ #include <linux/cpu.h>
+ #include <linux/console.h>
  #include <linux/vmalloc.h>
! #include <linux/swap.h>
! #include <linux/syscore_ops.h>
! 
! #include <asm/page.h>
! #include <asm/uaccess.h>
! #include <asm/io.h>
! #include <asm/sections.h>
! 
! /* Per cpu memory for storing cpu states in case of system crash. */
! note_buf_t __percpu *crash_notes;
! 
! /* vmcoreinfo stuff */
! static unsigned char vmcoreinfo_data[VMCOREINFO_BYTES];
! u32 vmcoreinfo_note[VMCOREINFO_NOTE_SIZE/4];
! size_t vmcoreinfo_size;
! size_t vmcoreinfo_max_size = sizeof(vmcoreinfo_data);
! 
! /* Flag to indicate we are going to kexec a new kernel */
! bool kexec_in_progress = false;
! 
! /* Location of the reserved area for the crash kernel */
! struct resource crashk_res = {
! 	.name  = "Crash kernel",
! 	.start = 0,
! 	.end   = 0,
! 	.flags = IORESOURCE_BUSY | IORESOURCE_MEM
! };
! struct resource crashk_low_res = {
! 	.name  = "Crash kernel",
! 	.start = 0,
! 	.end   = 0,
! 	.flags = IORESOURCE_BUSY | IORESOURCE_MEM
! };
! 
! int kexec_should_crash(struct task_struct *p)
! {
! 	if (in_interrupt() || !p->pid || is_global_init(p) || panic_on_oops)
! 		return 1;
! 	return 0;
! }
! 
! /*
!  * When kexec transitions to the new kernel there is a one-to-one
!  * mapping between physical and virtual addresses.  On processors
!  * where you can disable the MMU this is trivial, and easy.  For
!  * others it is still a simple predictable page table to setup.
!  *
!  * In that environment kexec copies the new kernel to its final
!  * resting place.  This means I can only support memory whose
!  * physical address can fit in an unsigned long.  In particular
!  * addresses where (pfn << PAGE_SHIFT) > ULONG_MAX cannot be handled.
!  * If the assembly stub has more restrictive requirements
!  * KEXEC_SOURCE_MEMORY_LIMIT and KEXEC_DEST_MEMORY_LIMIT can be
!  * defined more restrictively in <asm/kexec.h>.
!  *
!  * The code for the transition from the current kernel to the
!  * the new kernel is placed in the control_code_buffer, whose size
!  * is given by KEXEC_CONTROL_PAGE_SIZE.  In the best case only a single
!  * page of memory is necessary, but some architectures require more.
!  * Because this memory must be identity mapped in the transition from
!  * virtual to physical addresses it must live in the range
!  * 0 - TASK_SIZE, as only the user space mappings are arbitrarily
!  * modifiable.
!  *
!  * The assembly stub in the control code buffer is passed a linked list
!  * of descriptor pages detailing the source pages of the new kernel,
!  * and the destination addresses of those source pages.  As this data
!  * structure is not used in the context of the current OS, it must
!  * be self-contained.
!  *
!  * The code has been made to work with highmem pages and will use a
!  * destination page in its final resting place (if it happens
!  * to allocate it).  The end product of this is that most of the
!  * physical address space, and most of RAM can be used.
!  *
!  * Future directions include:
!  *  - allocating a page table with the control code buffer identity
!  *    mapped, to simplify machine_kexec and make kexec_on_panic more
!  *    reliable.
!  */
  
! /*
!  * KIMAGE_NO_DEST is an impossible destination address..., for
!  * allocating pages whose destination address we do not care about.
!  */
! #define KIMAGE_NO_DEST (-1UL)
  
! static int kimage_is_destination_range(struct kimage *image,
! 				       unsigned long start, unsigned long end);
! static struct page *kimage_alloc_page(struct kimage *image,
! 				       gfp_t gfp_mask,
! 				       unsigned long dest);
! 
! static int do_kimage_alloc(struct kimage **rimage, unsigned long entry,
! 	                    unsigned long nr_segments,
!                             struct kexec_segment __user *segments)
  {
  	size_t segment_bytes;
+ 	struct kimage *image;
+ 	unsigned long i;
+ 	int result;
+ 
+ 	/* Allocate a controlling structure */
+ 	result = -ENOMEM;
+ 	image = kzalloc(sizeof(*image), GFP_KERNEL);
+ 	if (!image)
+ 		goto out;
+ 
+ 	image->head = 0;
+ 	image->entry = &image->head;
+ 	image->last_entry = &image->head;
+ 	image->control_page = ~0; /* By default this does not apply */
+ 	image->start = entry;
+ 	image->type = KEXEC_TYPE_DEFAULT;
+ 
+ 	/* Initialize the list of control pages */
+ 	INIT_LIST_HEAD(&image->control_pages);
+ 
+ 	/* Initialize the list of destination pages */
+ 	INIT_LIST_HEAD(&image->dest_pages);
+ 
+ 	/* Initialize the list of unusable pages */
+ 	INIT_LIST_HEAD(&image->unuseable_pages);
  
  	/* Read in the segments */
  	image->nr_segments = nr_segments;
  	segment_bytes = nr_segments * sizeof(*segments);
! 	result = copy_from_user(image->segment, segments, segment_bytes);
! 	if (result) {
! 		result = -EFAULT;
! 		goto out;
! 	}
! 
! 	/*
! 	 * Verify we have good destination addresses.  The caller is
! 	 * responsible for making certain we don't attempt to load
! 	 * the new image into invalid or reserved areas of RAM.  This
! 	 * just verifies it is an address we can use.
! 	 *
! 	 * Since the kernel does everything in page size chunks ensure
! 	 * the destination addresses are page aligned.  Too many
! 	 * special cases crop of when we don't do this.  The most
! 	 * insidious is getting overlapping destination addresses
! 	 * simply because addresses are changed to page size
! 	 * granularity.
! 	 */
! 	result = -EADDRNOTAVAIL;
! 	for (i = 0; i < nr_segments; i++) {
! 		unsigned long mstart, mend;
! 
! 		mstart = image->segment[i].mem;
! 		mend   = mstart + image->segment[i].memsz;
! 		if ((mstart & ~PAGE_MASK) || (mend & ~PAGE_MASK))
! 			goto out;
! 		if (mend >= KEXEC_DESTINATION_MEMORY_LIMIT)
! 			goto out;
! 	}
! 
! 	/* Verify our destination addresses do not overlap.
! 	 * If we alloed overlapping destination addresses
! 	 * through very weird things can happen with no
! 	 * easy explanation as one segment stops on another.
! 	 */
! 	result = -EINVAL;
! 	for (i = 0; i < nr_segments; i++) {
! 		unsigned long mstart, mend;
! 		unsigned long j;
! 
! 		mstart = image->segment[i].mem;
! 		mend   = mstart + image->segment[i].memsz;
! 		for (j = 0; j < i; j++) {
! 			unsigned long pstart, pend;
! 			pstart = image->segment[j].mem;
! 			pend   = pstart + image->segment[j].memsz;
! 			/* Do the segments overlap ? */
! 			if ((mend > pstart) && (mstart < pend))
! 				goto out;
! 		}
! 	}
! 
! 	/* Ensure our buffer sizes are strictly less than
! 	 * our memory sizes.  This should always be the case,
! 	 * and it is easier to check up front than to be surprised
! 	 * later on.
! 	 */
! 	result = -EINVAL;
! 	for (i = 0; i < nr_segments; i++) {
! 		if (image->segment[i].bufsz > image->segment[i].memsz)
! 			goto out;
! 	}
! 
! 	result = 0;
! out:
! 	if (result == 0)
! 		*rimage = image;
! 	else
! 		kfree(image);
! 
! 	return result;
  
  }
  
! static void kimage_free_page_list(struct list_head *list);
! 
! static int kimage_normal_alloc(struct kimage **rimage, unsigned long entry,
! 				unsigned long nr_segments,
! 				struct kexec_segment __user *segments)
  {
! 	int result;
  	struct kimage *image;
  
! 	/* Allocate and initialize a controlling structure */
! 	image = NULL;
! 	result = do_kimage_alloc(&image, entry, nr_segments, segments);
! 	if (result)
! 		goto out;
! 
! 	/*
! 	 * Find a location for the control code buffer, and add it
! 	 * the vector of segments so that it's pages will also be
! 	 * counted as destination pages.
! 	 */
! 	result = -ENOMEM;
! 	image->control_code_page = kimage_alloc_control_pages(image,
! 					   get_order(KEXEC_CONTROL_PAGE_SIZE));
! 	if (!image->control_code_page) {
! 		printk(KERN_ERR "Could not allocate control_code_buffer\n");
! 		goto out_free;
! 	}
! 
! 	image->swap_page = kimage_alloc_control_pages(image, 0);
! 	if (!image->swap_page) {
! 		printk(KERN_ERR "Could not allocate swap buffer\n");
! 		goto out_free;
! 	}
! 
! 	*rimage = image;
! 	return 0;
! 
! out_free:
! 	kimage_free_page_list(&image->control_pages);
! 	kfree(image);
! out:
! 	return result;
! }
! 
! static int kimage_crash_alloc(struct kimage **rimage, unsigned long entry,
! 				unsigned long nr_segments,
! 				struct kexec_segment __user *segments)
! {
! 	int result;
! 	struct kimage *image;
! 	unsigned long i;
! 
! 	image = NULL;
! 	/* Verify we have a valid entry point */
! 	if ((entry < crashk_res.start) || (entry > crashk_res.end)) {
! 		result = -EADDRNOTAVAIL;
! 		goto out;
  	}
  
  	/* Allocate and initialize a controlling structure */
! 	result = do_kimage_alloc(&image, entry, nr_segments, segments);
! 	if (result)
! 		goto out;
  
! 	/* Enable the special crash kernel control page
! 	 * allocation policy.
! 	 */
! 	image->control_page = crashk_res.start;
! 	image->type = KEXEC_TYPE_CRASH;
  
! 	/*
! 	 * Verify we have good destination addresses.  Normally
! 	 * the caller is responsible for making certain we don't
! 	 * attempt to load the new image into invalid or reserved
! 	 * areas of RAM.  But crash kernels are preloaded into a
! 	 * reserved area of ram.  We must ensure the addresses
! 	 * are in the reserved area otherwise preloading the
! 	 * kernel could corrupt things.
! 	 */
! 	result = -EADDRNOTAVAIL;
! 	for (i = 0; i < nr_segments; i++) {
! 		unsigned long mstart, mend;
! 
! 		mstart = image->segment[i].mem;
! 		mend = mstart + image->segment[i].memsz - 1;
! 		/* Ensure we are within the crash kernel limits */
! 		if ((mstart < crashk_res.start) || (mend > crashk_res.end))
! 			goto out_free;
  	}
  
  	/*
! 	 * Find a location for the control code buffer, and add
  	 * the vector of segments so that it's pages will also be
  	 * counted as destination pages.
  	 */
! 	result = -ENOMEM;
  	image->control_code_page = kimage_alloc_control_pages(image,
  					   get_order(KEXEC_CONTROL_PAGE_SIZE));
  	if (!image->control_code_page) {
! 		printk(KERN_ERR "Could not allocate control_code_buffer\n");
! 		goto out_free;
  	}
  
! 	*rimage = image;
! 	return 0;
! 
! out_free:
! 	kfree(image);
! out:
! 	return result;
! }
! 
! static int kimage_is_destination_range(struct kimage *image,
! 					unsigned long start,
! 					unsigned long end)
! {
! 	unsigned long i;
! 
! 	for (i = 0; i < image->nr_segments; i++) {
! 		unsigned long mstart, mend;
! 
! 		mstart = image->segment[i].mem;
! 		mend = mstart + image->segment[i].memsz;
! 		if ((end > mstart) && (start < mend))
! 			return 1;
! 	}
! 
! 	return 0;
! }
! 
! static struct page *kimage_alloc_pages(gfp_t gfp_mask, unsigned int order)
! {
! 	struct page *pages;
! 
! 	pages = alloc_pages(gfp_mask, order);
! 	if (pages) {
! 		unsigned int count, i;
! 		pages->mapping = NULL;
! 		set_page_private(pages, order);
! 		count = 1 << order;
! 		for (i = 0; i < count; i++)
! 			SetPageReserved(pages + i);
! 	}
! 
! 	return pages;
! }
! 
! static void kimage_free_pages(struct page *page)
! {
! 	unsigned int order, count, i;
! 
! 	order = page_private(page);
! 	count = 1 << order;
! 	for (i = 0; i < count; i++)
! 		ClearPageReserved(page + i);
! 	__free_pages(page, order);
! }
! 
! static void kimage_free_page_list(struct list_head *list)
! {
! 	struct list_head *pos, *next;
! 
! 	list_for_each_safe(pos, next, list) {
! 		struct page *page;
! 
! 		page = list_entry(pos, struct page, lru);
! 		list_del(&page->lru);
! 		kimage_free_pages(page);
! 	}
! }
! 
! static struct page *kimage_alloc_normal_control_pages(struct kimage *image,
! 							unsigned int order)
! {
! 	/* Control pages are special, they are the intermediaries
! 	 * that are needed while we copy the rest of the pages
! 	 * to their final resting place.  As such they must
! 	 * not conflict with either the destination addresses
! 	 * or memory the kernel is already using.
! 	 *
! 	 * The only case where we really need more than one of
! 	 * these are for architectures where we cannot disable
! 	 * the MMU and must instead generate an identity mapped
! 	 * page table for all of the memory.
! 	 *
! 	 * At worst this runs in O(N) of the image size.
! 	 */
! 	struct list_head extra_pages;
! 	struct page *pages;
! 	unsigned int count;
! 
! 	count = 1 << order;
! 	INIT_LIST_HEAD(&extra_pages);
! 
! 	/* Loop while I can allocate a page and the page allocated
! 	 * is a destination page.
! 	 */
! 	do {
! 		unsigned long pfn, epfn, addr, eaddr;
! 
! 		pages = kimage_alloc_pages(GFP_KERNEL, order);
! 		if (!pages)
! 			break;
! 		pfn   = page_to_pfn(pages);
! 		epfn  = pfn + count;
! 		addr  = pfn << PAGE_SHIFT;
! 		eaddr = epfn << PAGE_SHIFT;
! 		if ((epfn >= (KEXEC_CONTROL_MEMORY_LIMIT >> PAGE_SHIFT)) ||
! 			      kimage_is_destination_range(image, addr, eaddr)) {
! 			list_add(&pages->lru, &extra_pages);
! 			pages = NULL;
  		}
+ 	} while (!pages);
+ 
+ 	if (pages) {
+ 		/* Remember the allocated page... */
+ 		list_add(&pages->lru, &image->control_pages);
+ 
+ 		/* Because the page is already in it's destination
+ 		 * location we will never allocate another page at
+ 		 * that address.  Therefore kimage_alloc_pages
+ 		 * will not return it (again) and we don't need
+ 		 * to give it an entry in image->segment[].
+ 		 */
  	}
+ 	/* Deal with the destination pages I have inadvertently allocated.
+ 	 *
+ 	 * Ideally I would convert multi-page allocations into single
+ 	 * page allocations, and add everything to image->dest_pages.
+ 	 *
+ 	 * For now it is simpler to just free the pages.
+ 	 */
+ 	kimage_free_page_list(&extra_pages);
+ 
+ 	return pages;
+ }
+ 
+ static struct page *kimage_alloc_crash_control_pages(struct kimage *image,
+ 						      unsigned int order)
+ {
+ 	/* Control pages are special, they are the intermediaries
+ 	 * that are needed while we copy the rest of the pages
+ 	 * to their final resting place.  As such they must
+ 	 * not conflict with either the destination addresses
+ 	 * or memory the kernel is already using.
+ 	 *
+ 	 * Control pages are also the only pags we must allocate
+ 	 * when loading a crash kernel.  All of the other pages
+ 	 * are specified by the segments and we just memcpy
+ 	 * into them directly.
+ 	 *
+ 	 * The only case where we really need more than one of
+ 	 * these are for architectures where we cannot disable
+ 	 * the MMU and must instead generate an identity mapped
+ 	 * page table for all of the memory.
+ 	 *
+ 	 * Given the low demand this implements a very simple
+ 	 * allocator that finds the first hole of the appropriate
+ 	 * size in the reserved memory region, and allocates all
+ 	 * of the memory up to and including the hole.
+ 	 */
+ 	unsigned long hole_start, hole_end, size;
+ 	struct page *pages;
+ 
+ 	pages = NULL;
+ 	size = (1 << order) << PAGE_SHIFT;
+ 	hole_start = (image->control_page + (size - 1)) & ~(size - 1);
+ 	hole_end   = hole_start + size - 1;
+ 	while (hole_end <= crashk_res.end) {
+ 		unsigned long i;
+ 
+ 		if (hole_end > KEXEC_CRASH_CONTROL_MEMORY_LIMIT)
+ 			break;
+ 		/* See if I overlap any of the segments */
+ 		for (i = 0; i < image->nr_segments; i++) {
+ 			unsigned long mstart, mend;
+ 
+ 			mstart = image->segment[i].mem;
+ 			mend   = mstart + image->segment[i].memsz - 1;
+ 			if ((hole_end >= mstart) && (hole_start <= mend)) {
+ 				/* Advance the hole to the end of the segment */
+ 				hole_start = (mend + (size - 1)) & ~(size - 1);
+ 				hole_end   = hole_start + size - 1;
+ 				break;
+ 			}
+ 		}
+ 		/* If I don't overlap any segments I have found my hole! */
+ 		if (i == image->nr_segments) {
+ 			pages = pfn_to_page(hole_start >> PAGE_SHIFT);
+ 			break;
+ 		}
+ 	}
+ 	if (pages)
+ 		image->control_page = hole_end;
+ 
+ 	return pages;
+ }
+ 
+ 
+ struct page *kimage_alloc_control_pages(struct kimage *image,
+ 					 unsigned int order)
+ {
+ 	struct page *pages = NULL;
+ 
+ 	switch (image->type) {
+ 	case KEXEC_TYPE_DEFAULT:
+ 		pages = kimage_alloc_normal_control_pages(image, order);
+ 		break;
+ 	case KEXEC_TYPE_CRASH:
+ 		pages = kimage_alloc_crash_control_pages(image, order);
+ 		break;
+ 	}
+ 
+ 	return pages;
+ }
+ 
+ static int kimage_add_entry(struct kimage *image, kimage_entry_t entry)
+ {
+ 	if (*image->entry != 0)
+ 		image->entry++;
+ 
+ 	if (image->entry == image->last_entry) {
+ 		kimage_entry_t *ind_page;
+ 		struct page *page;
+ 
+ 		page = kimage_alloc_page(image, GFP_KERNEL, KIMAGE_NO_DEST);
+ 		if (!page)
+ 			return -ENOMEM;
+ 
+ 		ind_page = page_address(page);
+ 		*image->entry = virt_to_phys(ind_page) | IND_INDIRECTION;
+ 		image->entry = ind_page;
+ 		image->last_entry = ind_page +
+ 				      ((PAGE_SIZE/sizeof(kimage_entry_t)) - 1);
+ 	}
+ 	*image->entry = entry;
+ 	image->entry++;
+ 	*image->entry = 0;
  
  	return 0;
! }
! 
! static int kimage_set_destination(struct kimage *image,
! 				   unsigned long destination)
! {
! 	int result;
! 
! 	destination &= PAGE_MASK;
! 	result = kimage_add_entry(image, destination | IND_DESTINATION);
! 	if (result == 0)
! 		image->destination = destination;
! 
! 	return result;
! }
! 
! 
! static inline int kimage_add_page_with_flags(struct kimage *image,
! 					     unsigned long page, int flags)
! {
! 	int result;
! 
! 	page &= PAGE_MASK;
! 	result = kimage_add_entry(image, page | (flags & ~PAGE_MASK));
! 	if (result == 0)
! 		image->destination += PAGE_SIZE;
! 
! 	return result;
! }
! 
! static int kimage_add_page(struct kimage *image, unsigned long page)
! {
! 	return kimage_add_page_with_flags(image, page, IND_SOURCE);
! }
! 
! static int kimage_add_page_noalloc(struct kimage *image, unsigned long page)
! {
! 	return kimage_add_page_with_flags(image, page, IND_SOURCE|IND_NOALLOC);
! }
! 
! 
! static void kimage_free_extra_pages(struct kimage *image)
! {
! 	/* Walk through and free any extra destination pages I may have */
! 	kimage_free_page_list(&image->dest_pages);
! 
! 	/* Walk through and free any unusable pages I have cached */
! 	kimage_free_page_list(&image->unuseable_pages);
! 
! }
! static void kimage_terminate(struct kimage *image)
! {
! 	if (*image->entry != 0)
! 		image->entry++;
! 
! 	*image->entry = IND_DONE;
! }
! 
! int kimage_add_preserved_region(struct kimage *image, unsigned long to,
! 				       unsigned long from, int length)
! {
! 	int result = 0;
! 
! 	if (length > 0) {
! 		result = kimage_set_destination(image, to);
! 		if (result < 0)
! 			goto out;
! 		while (length > 0) {
! 			result = kimage_add_page_noalloc(image, from);
! 			if (result < 0)
! 				goto out;
! 			from += PAGE_SIZE;
! 			length -= PAGE_SIZE;
! 		}
! 	}
! out:
! 	return result;
! }
! 
! #define for_each_kimage_entry(image, ptr, entry) \
! 	for (ptr = &image->head; (entry = *ptr) && !(entry & IND_DONE); \
! 		ptr = (entry & IND_INDIRECTION)? \
! 			phys_to_virt((entry & PAGE_MASK)): ptr +1)
! 
! static void kimage_free_entry(kimage_entry_t entry)
! {
! 	struct page *page;
! 
! 	page = pfn_to_page(entry >> PAGE_SHIFT);
! 	kimage_free_pages(page);
! }
! 
! static void kimage_free(struct kimage *image)
! {
! 	kimage_entry_t *ptr, entry;
! 	kimage_entry_t ind = 0;
! 
! 	if (!image)
! 		return;
! 
! 	kimage_free_extra_pages(image);
! 	for_each_kimage_entry(image, ptr, entry) {
! 		if (entry & IND_INDIRECTION) {
! 			/* Free the previous indirection page */
! 			if (ind & IND_INDIRECTION)
! 				kimage_free_entry(ind);
! 			/* Save this indirection page until we are
! 			 * done with it.
! 			 */
! 			ind = entry;
! 		} else if (entry & IND_SOURCE) {
! 			/* free only entries that we really allocated */
! 			if (!(entry & IND_NOALLOC))
! 				kimage_free_entry(entry);
! 		}
! 	}
! 	/* Free the final indirection page */
! 	if (ind & IND_INDIRECTION)
! 		kimage_free_entry(ind);
! 
! 	/* Handle any machine specific cleanup */
! 	machine_kexec_cleanup(image);
! 
! 	/* Free the kexec control pages... */
  	kimage_free_page_list(&image->control_pages);
  	kfree(image);
! }
! 
! static kimage_entry_t *kimage_dst_used(struct kimage *image,
! 					unsigned long page)
! {
! 	kimage_entry_t *ptr, entry;
! 	unsigned long destination = 0;
! 
! 	for_each_kimage_entry(image, ptr, entry) {
! 		if (entry & IND_DESTINATION)
! 			destination = entry & PAGE_MASK;
! 		else if (entry & IND_SOURCE) {
! 			if (page == destination)
! 				return ptr;
! 			destination += PAGE_SIZE;
! 		}
! 	}
! 
! 	return NULL;
! }
! 
! static struct page *kimage_alloc_page(struct kimage *image,
! 					gfp_t gfp_mask,
! 					unsigned long destination)
! {
! 	/*
! 	 * Here we implement safeguards to ensure that a source page
! 	 * is not copied to its destination page before the data on
! 	 * the destination page is no longer useful.
! 	 *
! 	 * To do this we maintain the invariant that a source page is
! 	 * either its own destination page, or it is not a
! 	 * destination page at all.
! 	 *
! 	 * That is slightly stronger than required, but the proof
! 	 * that no problems will not occur is trivial, and the
! 	 * implementation is simply to verify.
! 	 *
! 	 * When allocating all pages normally this algorithm will run
! 	 * in O(N) time, but in the worst case it will run in O(N^2)
! 	 * time.   If the runtime is a problem the data structures can
! 	 * be fixed.
! 	 */
! 	struct page *page;
! 	unsigned long addr;
! 
! 	/*
! 	 * Walk through the list of destination pages, and see if I
! 	 * have a match.
! 	 */
! 	list_for_each_entry(page, &image->dest_pages, lru) {
! 		addr = page_to_pfn(page) << PAGE_SHIFT;
! 		if (addr == destination) {
! 			list_del(&page->lru);
! 			return page;
! 		}
! 	}
! 	page = NULL;
! 	while (1) {
! 		kimage_entry_t *old;
! 
! 		/* Allocate a page, if we run out of memory give up */
! 		page = kimage_alloc_pages(gfp_mask, 0);
! 		if (!page)
! 			return NULL;
! 		/* If the page cannot be used file it away */
! 		if (page_to_pfn(page) >
! 				(KEXEC_SOURCE_MEMORY_LIMIT >> PAGE_SHIFT)) {
! 			list_add(&page->lru, &image->unuseable_pages);
! 			continue;
! 		}
! 		addr = page_to_pfn(page) << PAGE_SHIFT;
! 
! 		/* If it is the destination page we want use it */
! 		if (addr == destination)
! 			break;
! 
! 		/* If the page is not a destination page use it */
! 		if (!kimage_is_destination_range(image, addr,
! 						  addr + PAGE_SIZE))
! 			break;
! 
! 		/*
! 		 * I know that the page is someones destination page.
! 		 * See if there is already a source page for this
! 		 * destination page.  And if so swap the source pages.
! 		 */
! 		old = kimage_dst_used(image, addr);
! 		if (old) {
! 			/* If so move it */
! 			unsigned long old_addr;
! 			struct page *old_page;
! 
! 			old_addr = *old & PAGE_MASK;
! 			old_page = pfn_to_page(old_addr >> PAGE_SHIFT);
! 			copy_highpage(page, old_page);
! 			*old = addr | (*old & ~PAGE_MASK);
! 
! 			/* The old page I have found cannot be a
! 			 * destination page, so return it if it's
! 			 * gfp_flags honor the ones passed in.
! 			 */
! 			if (!(gfp_mask & __GFP_HIGHMEM) &&
! 			    PageHighMem(old_page)) {
! 				kimage_free_pages(old_page);
! 				continue;
! 			}
! 			addr = old_addr;
! 			page = old_page;
! 			break;
! 		}
! 		else {
! 			/* Place the page on the destination list I
! 			 * will use it later.
! 			 */
! 			list_add(&page->lru, &image->dest_pages);
! 		}
! 	}
! 
! 	return page;
! }
! 
! static int kimage_load_normal_segment(struct kimage *image,
! 					 struct kexec_segment *segment)
! {
! 	unsigned long maddr;
! 	size_t ubytes, mbytes;
! 	int result;
! 	unsigned char __user *buf;
! 
! 	result = 0;
! 	buf = segment->buf;
! 	ubytes = segment->bufsz;
! 	mbytes = segment->memsz;
! 	maddr = segment->mem;
! 
! 	result = kimage_set_destination(image, maddr);
! 	if (result < 0)
! 		goto out;
! 
! 	while (mbytes) {
! 		struct page *page;
! 		char *ptr;
! 		size_t uchunk, mchunk;
! 
! 		page = kimage_alloc_page(image, GFP_HIGHUSER, maddr);
! 		if (!page) {
! 			result  = -ENOMEM;
! 			goto out;
! 		}
! 		result = kimage_add_page(image, page_to_pfn(page)
! 								<< PAGE_SHIFT);
! 		if (result < 0)
! 			goto out;
! 
! 		ptr = kmap(page);
! 		/* Start with a clear page */
! 		clear_page(ptr);
! 		ptr += maddr & ~PAGE_MASK;
! 		mchunk = min_t(size_t, mbytes,
! 				PAGE_SIZE - (maddr & ~PAGE_MASK));
! 		uchunk = min(ubytes, mchunk);
! 
! 		result = copy_from_user(ptr, buf, uchunk);
! 		kunmap(page);
! 		if (result) {
! 			result = -EFAULT;
! 			goto out;
! 		}
! 		ubytes -= uchunk;
! 		maddr  += mchunk;
! 		buf    += mchunk;
! 		mbytes -= mchunk;
! 	}
! out:
! 	return result;
! }
! 
! static int kimage_load_crash_segment(struct kimage *image,
! 					struct kexec_segment *segment)
! {
! 	/* For crash dumps kernels we simply copy the data from
! 	 * user space to it's destination.
! 	 * We do things a page at a time for the sake of kmap.
! 	 */
! 	unsigned long maddr;
! 	size_t ubytes, mbytes;
! 	int result;
! 	unsigned char __user *buf;
! 
! 	result = 0;
! 	buf = segment->buf;
! 	ubytes = segment->bufsz;
! 	mbytes = segment->memsz;
! 	maddr = segment->mem;
! 	while (mbytes) {
! 		struct page *page;
! 		char *ptr;
! 		size_t uchunk, mchunk;
! 
! 		page = pfn_to_page(maddr >> PAGE_SHIFT);
! 		if (!page) {
! 			result  = -ENOMEM;
! 			goto out;
! 		}
! 		ptr = kmap(page);
! 		ptr += maddr & ~PAGE_MASK;
! 		mchunk = min_t(size_t, mbytes,
! 				PAGE_SIZE - (maddr & ~PAGE_MASK));
! 		uchunk = min(ubytes, mchunk);
! 		if (mchunk > uchunk) {
! 			/* Zero the trailing part of the page */
! 			memset(ptr + uchunk, 0, mchunk - uchunk);
! 		}
! 		result = copy_from_user(ptr, buf, uchunk);
! 		kexec_flush_icache_page(page);
! 		kunmap(page);
! 		if (result) {
! 			result = -EFAULT;
! 			goto out;
! 		}
! 		ubytes -= uchunk;
! 		maddr  += mchunk;
! 		buf    += mchunk;
! 		mbytes -= mchunk;
! 	}
! out:
! 	return result;
! }
! 
! static int kimage_load_segment(struct kimage *image,
! 				struct kexec_segment *segment)
! {
! 	int result = -ENOMEM;
! 
! 	switch (image->type) {
! 	case KEXEC_TYPE_DEFAULT:
! 		result = kimage_load_normal_segment(image, segment);
! 		break;
! 	case KEXEC_TYPE_CRASH:
! 		result = kimage_load_crash_segment(image, segment);
! 		break;
! 	}
! 
! 	return result;
  }
  
  /*
***************
*** 115,126 ****
   *   reinitialize them.
   *
   * - A machine specific part that includes the syscall number
!  *   and then copies the image to it's final destination.  And
   *   jumps into the image at entry.
   *
   * kexec does not sync, or unmount filesystems so if you need
   * that to happen you need to do that yourself.
   */
  
  SYSCALL_DEFINE4(kexec_load, unsigned long, entry, unsigned long, nr_segments,
  		struct kexec_segment __user *, segments, unsigned long, flags)
--- 958,973 ----
   *   reinitialize them.
   *
   * - A machine specific part that includes the syscall number
!  *   and the copies the image to it's final destination.  And
   *   jumps into the image at entry.
   *
   * kexec does not sync, or unmount filesystems so if you need
   * that to happen you need to do that yourself.
   */
+ struct kimage *kexec_image;
+ struct kimage *kexec_crash_image;
+ 
+ static DEFINE_MUTEX(kexec_mutex);
  
  SYSCALL_DEFINE4(kexec_load, unsigned long, entry, unsigned long, nr_segments,
  		struct kexec_segment __user *, segments, unsigned long, flags)
***************
*** 129,135 ****
  	int result;
  
  	/* We only trust the superuser with rebooting the system. */
! 	if (!capable(CAP_SYS_BOOT) || kexec_load_disabled)
  		return -EPERM;
  
  	/*
--- 976,982 ----
  	int result;
  
  	/* We only trust the superuser with rebooting the system. */
! 	if (!capable(CAP_SYS_BOOT))
  		return -EPERM;
  
  	/*
***************
*** 170,191 ****
  	if (nr_segments > 0) {
  		unsigned long i;
  
! 		if (flags & KEXEC_ON_CRASH) {
! 			/*
! 			 * Loading another kernel to switch to if this one
! 			 * crashes.  Free any current crash dump kernel before
  			 * we corrupt it.
  			 */
- 
  			kimage_free(xchg(&kexec_crash_image, NULL));
! 			result = kimage_alloc_init(&image, entry, nr_segments,
! 						   segments, flags);
  			crash_map_reserved_pages();
- 		} else {
- 			/* Loading another kernel to reboot into. */
- 
- 			result = kimage_alloc_init(&image, entry, nr_segments,
- 						   segments, flags);
  		}
  		if (result)
  			goto out;
--- 1017,1035 ----
  	if (nr_segments > 0) {
  		unsigned long i;
  
! 		/* Loading another kernel to reboot into */
! 		if ((flags & KEXEC_ON_CRASH) == 0)
! 			result = kimage_normal_alloc(&image, entry,
! 							nr_segments, segments);
! 		/* Loading another kernel to switch to if this one crashes */
! 		else if (flags & KEXEC_ON_CRASH) {
! 			/* Free any current crash dump kernel before
  			 * we corrupt it.
  			 */
  			kimage_free(xchg(&kexec_crash_image, NULL));
! 			result = kimage_crash_alloc(&image, entry,
! 						     nr_segments, segments);
  			crash_map_reserved_pages();
  		}
  		if (result)
  			goto out;
***************
*** 215,225 ****
  	return result;
  }
  
  #ifdef CONFIG_COMPAT
! COMPAT_SYSCALL_DEFINE4(kexec_load, compat_ulong_t, entry,
! 		       compat_ulong_t, nr_segments,
! 		       struct compat_kexec_segment __user *, segments,
! 		       compat_ulong_t, flags)
  {
  	struct compat_kexec_segment in;
  	struct kexec_segment out, __user *ksegments;
--- 1059,1081 ----
  	return result;
  }
  
+ /*
+  * Add and remove page tables for crashkernel memory
+  *
+  * Provide an empty default implementation here -- architecture
+  * code may override this
+  */
+ void __weak crash_map_reserved_pages(void)
+ {}
+ 
+ void __weak crash_unmap_reserved_pages(void)
+ {}
+ 
  #ifdef CONFIG_COMPAT
! asmlinkage long compat_sys_kexec_load(unsigned long entry,
! 				unsigned long nr_segments,
! 				struct compat_kexec_segment __user *segments,
! 				unsigned long flags)
  {
  	struct compat_kexec_segment in;
  	struct kexec_segment out, __user *ksegments;
***************
*** 235,241 ****
  		return -EINVAL;
  
  	ksegments = compat_alloc_user_space(nr_segments * sizeof(out));
! 	for (i = 0; i < nr_segments; i++) {
  		result = copy_from_user(&in, &segments[i], sizeof(in));
  		if (result)
  			return -EFAULT;
--- 1091,1097 ----
  		return -EINVAL;
  
  	ksegments = compat_alloc_user_space(nr_segments * sizeof(out));
! 	for (i=0; i < nr_segments; i++) {
  		result = copy_from_user(&in, &segments[i], sizeof(in));
  		if (result)
  			return -EFAULT;
***************
*** 253,255 ****
--- 1109,1746 ----
  	return sys_kexec_load(entry, nr_segments, ksegments, flags);
  }
  #endif
+ 
+ void crash_kexec(struct pt_regs *regs)
+ {
+ 	/* Take the kexec_mutex here to prevent sys_kexec_load
+ 	 * running on one cpu from replacing the crash kernel
+ 	 * we are using after a panic on a different cpu.
+ 	 *
+ 	 * If the crash kernel was not located in a fixed area
+ 	 * of memory the xchg(&kexec_crash_image) would be
+ 	 * sufficient.  But since I reuse the memory...
+ 	 */
+ 	if (mutex_trylock(&kexec_mutex)) {
+ 		if (kexec_crash_image) {
+ 			struct pt_regs fixed_regs;
+ 
+ 			crash_setup_regs(&fixed_regs, regs);
+ 			crash_save_vmcoreinfo();
+ 			machine_crash_shutdown(&fixed_regs);
+ 			machine_kexec(kexec_crash_image);
+ 		}
+ 		mutex_unlock(&kexec_mutex);
+ 	}
+ }
+ 
+ size_t crash_get_memory_size(void)
+ {
+ 	size_t size = 0;
+ 	mutex_lock(&kexec_mutex);
+ 	if (crashk_res.end != crashk_res.start)
+ 		size = resource_size(&crashk_res);
+ 	mutex_unlock(&kexec_mutex);
+ 	return size;
+ }
+ 
+ void __weak crash_free_reserved_phys_range(unsigned long begin,
+ 					   unsigned long end)
+ {
+ 	unsigned long addr;
+ 
+ 	for (addr = begin; addr < end; addr += PAGE_SIZE)
+ 		free_reserved_page(pfn_to_page(addr >> PAGE_SHIFT));
+ }
+ 
+ int crash_shrink_memory(unsigned long new_size)
+ {
+ 	int ret = 0;
+ 	unsigned long start, end;
+ 	unsigned long old_size;
+ 	struct resource *ram_res;
+ 
+ 	mutex_lock(&kexec_mutex);
+ 
+ 	if (kexec_crash_image) {
+ 		ret = -ENOENT;
+ 		goto unlock;
+ 	}
+ 	start = crashk_res.start;
+ 	end = crashk_res.end;
+ 	old_size = (end == 0) ? 0 : end - start + 1;
+ 	if (new_size >= old_size) {
+ 		ret = (new_size == old_size) ? 0 : -EINVAL;
+ 		goto unlock;
+ 	}
+ 
+ 	ram_res = kzalloc(sizeof(*ram_res), GFP_KERNEL);
+ 	if (!ram_res) {
+ 		ret = -ENOMEM;
+ 		goto unlock;
+ 	}
+ 
+ 	start = roundup(start, KEXEC_CRASH_MEM_ALIGN);
+ 	end = roundup(start + new_size, KEXEC_CRASH_MEM_ALIGN);
+ 
+ 	crash_map_reserved_pages();
+ 	crash_free_reserved_phys_range(end, crashk_res.end);
+ 
+ 	if ((start == end) && (crashk_res.parent != NULL))
+ 		release_resource(&crashk_res);
+ 
+ 	ram_res->start = end;
+ 	ram_res->end = crashk_res.end;
+ 	ram_res->flags = IORESOURCE_BUSY | IORESOURCE_MEM;
+ 	ram_res->name = "System RAM";
+ 
+ 	crashk_res.end = end - 1;
+ 
+ 	insert_resource(&iomem_resource, ram_res);
+ 	crash_unmap_reserved_pages();
+ 
+ unlock:
+ 	mutex_unlock(&kexec_mutex);
+ 	return ret;
+ }
+ 
+ static u32 *append_elf_note(u32 *buf, char *name, unsigned type, void *data,
+ 			    size_t data_len)
+ {
+ 	struct elf_note note;
+ 
+ 	note.n_namesz = strlen(name) + 1;
+ 	note.n_descsz = data_len;
+ 	note.n_type   = type;
+ 	memcpy(buf, &note, sizeof(note));
+ 	buf += (sizeof(note) + 3)/4;
+ 	memcpy(buf, name, note.n_namesz);
+ 	buf += (note.n_namesz + 3)/4;
+ 	memcpy(buf, data, note.n_descsz);
+ 	buf += (note.n_descsz + 3)/4;
+ 
+ 	return buf;
+ }
+ 
+ static void final_note(u32 *buf)
+ {
+ 	struct elf_note note;
+ 
+ 	note.n_namesz = 0;
+ 	note.n_descsz = 0;
+ 	note.n_type   = 0;
+ 	memcpy(buf, &note, sizeof(note));
+ }
+ 
+ void crash_save_cpu(struct pt_regs *regs, int cpu)
+ {
+ 	struct elf_prstatus prstatus;
+ 	u32 *buf;
+ 
+ 	if ((cpu < 0) || (cpu >= nr_cpu_ids))
+ 		return;
+ 
+ 	/* Using ELF notes here is opportunistic.
+ 	 * I need a well defined structure format
+ 	 * for the data I pass, and I need tags
+ 	 * on the data to indicate what information I have
+ 	 * squirrelled away.  ELF notes happen to provide
+ 	 * all of that, so there is no need to invent something new.
+ 	 */
+ 	buf = (u32*)per_cpu_ptr(crash_notes, cpu);
+ 	if (!buf)
+ 		return;
+ 	memset(&prstatus, 0, sizeof(prstatus));
+ 	prstatus.pr_pid = current->pid;
+ 	elf_core_copy_kernel_regs(&prstatus.pr_reg, regs);
+ 	buf = append_elf_note(buf, KEXEC_CORE_NOTE_NAME, NT_PRSTATUS,
+ 		      	      &prstatus, sizeof(prstatus));
+ 	final_note(buf);
+ }
+ 
+ static int __init crash_notes_memory_init(void)
+ {
+ 	/* Allocate memory for saving cpu registers. */
+ 	crash_notes = alloc_percpu(note_buf_t);
+ 	if (!crash_notes) {
+ 		printk("Kexec: Memory allocation for saving cpu register"
+ 		" states failed\n");
+ 		return -ENOMEM;
+ 	}
+ 	return 0;
+ }
+ module_init(crash_notes_memory_init)
+ 
+ 
+ /*
+  * parsing the "crashkernel" commandline
+  *
+  * this code is intended to be called from architecture specific code
+  */
+ 
+ 
+ /*
+  * This function parses command lines in the format
+  *
+  *   crashkernel=ramsize-range:size[,...][@offset]
+  *
+  * The function returns 0 on success and -EINVAL on failure.
+  */
+ static int __init parse_crashkernel_mem(char 			*cmdline,
+ 					unsigned long long	system_ram,
+ 					unsigned long long	*crash_size,
+ 					unsigned long long	*crash_base)
+ {
+ 	char *cur = cmdline, *tmp;
+ 
+ 	/* for each entry of the comma-separated list */
+ 	do {
+ 		unsigned long long start, end = ULLONG_MAX, size;
+ 
+ 		/* get the start of the range */
+ 		start = memparse(cur, &tmp);
+ 		if (cur == tmp) {
+ 			pr_warning("crashkernel: Memory value expected\n");
+ 			return -EINVAL;
+ 		}
+ 		cur = tmp;
+ 		if (*cur != '-') {
+ 			pr_warning("crashkernel: '-' expected\n");
+ 			return -EINVAL;
+ 		}
+ 		cur++;
+ 
+ 		/* if no ':' is here, than we read the end */
+ 		if (*cur != ':') {
+ 			end = memparse(cur, &tmp);
+ 			if (cur == tmp) {
+ 				pr_warning("crashkernel: Memory "
+ 						"value expected\n");
+ 				return -EINVAL;
+ 			}
+ 			cur = tmp;
+ 			if (end <= start) {
+ 				pr_warning("crashkernel: end <= start\n");
+ 				return -EINVAL;
+ 			}
+ 		}
+ 
+ 		if (*cur != ':') {
+ 			pr_warning("crashkernel: ':' expected\n");
+ 			return -EINVAL;
+ 		}
+ 		cur++;
+ 
+ 		size = memparse(cur, &tmp);
+ 		if (cur == tmp) {
+ 			pr_warning("Memory value expected\n");
+ 			return -EINVAL;
+ 		}
+ 		cur = tmp;
+ 		if (size >= system_ram) {
+ 			pr_warning("crashkernel: invalid size\n");
+ 			return -EINVAL;
+ 		}
+ 
+ 		/* match ? */
+ 		if (system_ram >= start && system_ram < end) {
+ 			*crash_size = size;
+ 			break;
+ 		}
+ 	} while (*cur++ == ',');
+ 
+ 	if (*crash_size > 0) {
+ 		while (*cur && *cur != ' ' && *cur != '@')
+ 			cur++;
+ 		if (*cur == '@') {
+ 			cur++;
+ 			*crash_base = memparse(cur, &tmp);
+ 			if (cur == tmp) {
+ 				pr_warning("Memory value expected "
+ 						"after '@'\n");
+ 				return -EINVAL;
+ 			}
+ 		}
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ /*
+  * That function parses "simple" (old) crashkernel command lines like
+  *
+  * 	crashkernel=size[@offset]
+  *
+  * It returns 0 on success and -EINVAL on failure.
+  */
+ static int __init parse_crashkernel_simple(char 		*cmdline,
+ 					   unsigned long long 	*crash_size,
+ 					   unsigned long long 	*crash_base)
+ {
+ 	char *cur = cmdline;
+ 
+ 	*crash_size = memparse(cmdline, &cur);
+ 	if (cmdline == cur) {
+ 		pr_warning("crashkernel: memory value expected\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	if (*cur == '@')
+ 		*crash_base = memparse(cur+1, &cur);
+ 	else if (*cur != ' ' && *cur != '\0') {
+ 		pr_warning("crashkernel: unrecognized char\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ #define SUFFIX_HIGH 0
+ #define SUFFIX_LOW  1
+ #define SUFFIX_NULL 2
+ static __initdata char *suffix_tbl[] = {
+ 	[SUFFIX_HIGH] = ",high",
+ 	[SUFFIX_LOW]  = ",low",
+ 	[SUFFIX_NULL] = NULL,
+ };
+ 
+ /*
+  * That function parses "suffix"  crashkernel command lines like
+  *
+  *	crashkernel=size,[high|low]
+  *
+  * It returns 0 on success and -EINVAL on failure.
+  */
+ static int __init parse_crashkernel_suffix(char *cmdline,
+ 					   unsigned long long	*crash_size,
+ 					   unsigned long long	*crash_base,
+ 					   const char *suffix)
+ {
+ 	char *cur = cmdline;
+ 
+ 	*crash_size = memparse(cmdline, &cur);
+ 	if (cmdline == cur) {
+ 		pr_warn("crashkernel: memory value expected\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	/* check with suffix */
+ 	if (strncmp(cur, suffix, strlen(suffix))) {
+ 		pr_warn("crashkernel: unrecognized char\n");
+ 		return -EINVAL;
+ 	}
+ 	cur += strlen(suffix);
+ 	if (*cur != ' ' && *cur != '\0') {
+ 		pr_warn("crashkernel: unrecognized char\n");
+ 		return -EINVAL;
+ 	}
+ 
+ 	return 0;
+ }
+ 
+ static __init char *get_last_crashkernel(char *cmdline,
+ 			     const char *name,
+ 			     const char *suffix)
+ {
+ 	char *p = cmdline, *ck_cmdline = NULL;
+ 
+ 	/* find crashkernel and use the last one if there are more */
+ 	p = strstr(p, name);
+ 	while (p) {
+ 		char *end_p = strchr(p, ' ');
+ 		char *q;
+ 
+ 		if (!end_p)
+ 			end_p = p + strlen(p);
+ 
+ 		if (!suffix) {
+ 			int i;
+ 
+ 			/* skip the one with any known suffix */
+ 			for (i = 0; suffix_tbl[i]; i++) {
+ 				q = end_p - strlen(suffix_tbl[i]);
+ 				if (!strncmp(q, suffix_tbl[i],
+ 					     strlen(suffix_tbl[i])))
+ 					goto next;
+ 			}
+ 			ck_cmdline = p;
+ 		} else {
+ 			q = end_p - strlen(suffix);
+ 			if (!strncmp(q, suffix, strlen(suffix)))
+ 				ck_cmdline = p;
+ 		}
+ next:
+ 		p = strstr(p+1, name);
+ 	}
+ 
+ 	if (!ck_cmdline)
+ 		return NULL;
+ 
+ 	return ck_cmdline;
+ }
+ 
+ static int __init __parse_crashkernel(char *cmdline,
+ 			     unsigned long long system_ram,
+ 			     unsigned long long *crash_size,
+ 			     unsigned long long *crash_base,
+ 			     const char *name,
+ 			     const char *suffix)
+ {
+ 	char	*first_colon, *first_space;
+ 	char	*ck_cmdline;
+ 
+ 	BUG_ON(!crash_size || !crash_base);
+ 	*crash_size = 0;
+ 	*crash_base = 0;
+ 
+ 	ck_cmdline = get_last_crashkernel(cmdline, name, suffix);
+ 
+ 	if (!ck_cmdline)
+ 		return -EINVAL;
+ 
+ 	ck_cmdline += strlen(name);
+ 
+ 	if (suffix)
+ 		return parse_crashkernel_suffix(ck_cmdline, crash_size,
+ 				crash_base, suffix);
+ 	/*
+ 	 * if the commandline contains a ':', then that's the extended
+ 	 * syntax -- if not, it must be the classic syntax
+ 	 */
+ 	first_colon = strchr(ck_cmdline, ':');
+ 	first_space = strchr(ck_cmdline, ' ');
+ 	if (first_colon && (!first_space || first_colon < first_space))
+ 		return parse_crashkernel_mem(ck_cmdline, system_ram,
+ 				crash_size, crash_base);
+ 
+ 	return parse_crashkernel_simple(ck_cmdline, crash_size, crash_base);
+ }
+ 
+ /*
+  * That function is the entry point for command line parsing and should be
+  * called from the arch-specific code.
+  */
+ int __init parse_crashkernel(char *cmdline,
+ 			     unsigned long long system_ram,
+ 			     unsigned long long *crash_size,
+ 			     unsigned long long *crash_base)
+ {
+ 	return __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,
+ 					"crashkernel=", NULL);
+ }
+ 
+ int __init parse_crashkernel_high(char *cmdline,
+ 			     unsigned long long system_ram,
+ 			     unsigned long long *crash_size,
+ 			     unsigned long long *crash_base)
+ {
+ 	return __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,
+ 				"crashkernel=", suffix_tbl[SUFFIX_HIGH]);
+ }
+ 
+ int __init parse_crashkernel_low(char *cmdline,
+ 			     unsigned long long system_ram,
+ 			     unsigned long long *crash_size,
+ 			     unsigned long long *crash_base)
+ {
+ 	return __parse_crashkernel(cmdline, system_ram, crash_size, crash_base,
+ 				"crashkernel=", suffix_tbl[SUFFIX_LOW]);
+ }
+ 
+ static void update_vmcoreinfo_note(void)
+ {
+ 	u32 *buf = vmcoreinfo_note;
+ 
+ 	if (!vmcoreinfo_size)
+ 		return;
+ 	buf = append_elf_note(buf, VMCOREINFO_NOTE_NAME, 0, vmcoreinfo_data,
+ 			      vmcoreinfo_size);
+ 	final_note(buf);
+ }
+ 
+ void crash_save_vmcoreinfo(void)
+ {
+ 	vmcoreinfo_append_str("CRASHTIME=%ld\n", get_seconds());
+ 	update_vmcoreinfo_note();
+ }
+ 
+ void vmcoreinfo_append_str(const char *fmt, ...)
+ {
+ 	va_list args;
+ 	char buf[0x50];
+ 	size_t r;
+ 
+ 	va_start(args, fmt);
+ 	r = vsnprintf(buf, sizeof(buf), fmt, args);
+ 	va_end(args);
+ 
+ 	r = min(r, vmcoreinfo_max_size - vmcoreinfo_size);
+ 
+ 	memcpy(&vmcoreinfo_data[vmcoreinfo_size], buf, r);
+ 
+ 	vmcoreinfo_size += r;
+ }
+ 
+ /*
+  * provide an empty default implementation here -- architecture
+  * code may override this
+  */
+ void __attribute__ ((weak)) arch_crash_save_vmcoreinfo(void)
+ {}
+ 
+ unsigned long __attribute__ ((weak)) paddr_vmcoreinfo_note(void)
+ {
+ 	return __pa((unsigned long)(char *)&vmcoreinfo_note);
+ }
+ 
+ static int __init crash_save_vmcoreinfo_init(void)
+ {
+ 	VMCOREINFO_OSRELEASE(init_uts_ns.name.release);
+ 	VMCOREINFO_PAGESIZE(PAGE_SIZE);
+ 
+ 	VMCOREINFO_SYMBOL(init_uts_ns);
+ 	VMCOREINFO_SYMBOL(node_online_map);
+ #ifdef CONFIG_MMU
+ 	VMCOREINFO_SYMBOL(swapper_pg_dir);
+ #endif
+ 	VMCOREINFO_SYMBOL(_stext);
+ 	VMCOREINFO_SYMBOL(vmap_area_list);
+ 
+ #ifndef CONFIG_NEED_MULTIPLE_NODES
+ 	VMCOREINFO_SYMBOL(mem_map);
+ 	VMCOREINFO_SYMBOL(contig_page_data);
+ #endif
+ #ifdef CONFIG_SPARSEMEM
+ 	VMCOREINFO_SYMBOL(mem_section);
+ 	VMCOREINFO_LENGTH(mem_section, NR_SECTION_ROOTS);
+ 	VMCOREINFO_STRUCT_SIZE(mem_section);
+ 	VMCOREINFO_OFFSET(mem_section, section_mem_map);
+ #endif
+ 	VMCOREINFO_STRUCT_SIZE(page);
+ 	VMCOREINFO_STRUCT_SIZE(pglist_data);
+ 	VMCOREINFO_STRUCT_SIZE(zone);
+ 	VMCOREINFO_STRUCT_SIZE(free_area);
+ 	VMCOREINFO_STRUCT_SIZE(list_head);
+ 	VMCOREINFO_SIZE(nodemask_t);
+ 	VMCOREINFO_OFFSET(page, flags);
+ 	VMCOREINFO_OFFSET(page, _count);
+ 	VMCOREINFO_OFFSET(page, mapping);
+ 	VMCOREINFO_OFFSET(page, lru);
+ 	VMCOREINFO_OFFSET(page, _mapcount);
+ 	VMCOREINFO_OFFSET(page, private);
+ 	VMCOREINFO_OFFSET(pglist_data, node_zones);
+ 	VMCOREINFO_OFFSET(pglist_data, nr_zones);
+ #ifdef CONFIG_FLAT_NODE_MEM_MAP
+ 	VMCOREINFO_OFFSET(pglist_data, node_mem_map);
+ #endif
+ 	VMCOREINFO_OFFSET(pglist_data, node_start_pfn);
+ 	VMCOREINFO_OFFSET(pglist_data, node_spanned_pages);
+ 	VMCOREINFO_OFFSET(pglist_data, node_id);
+ 	VMCOREINFO_OFFSET(zone, free_area);
+ 	VMCOREINFO_OFFSET(zone, vm_stat);
+ 	VMCOREINFO_OFFSET(zone, spanned_pages);
+ 	VMCOREINFO_OFFSET(free_area, free_list);
+ 	VMCOREINFO_OFFSET(list_head, next);
+ 	VMCOREINFO_OFFSET(list_head, prev);
+ 	VMCOREINFO_OFFSET(vmap_area, va_start);
+ 	VMCOREINFO_OFFSET(vmap_area, list);
+ 	VMCOREINFO_LENGTH(zone.free_area, MAX_ORDER);
+ 	log_buf_kexec_setup();
+ 	VMCOREINFO_LENGTH(free_area.free_list, MIGRATE_TYPES);
+ 	VMCOREINFO_NUMBER(NR_FREE_PAGES);
+ 	VMCOREINFO_NUMBER(PG_lru);
+ 	VMCOREINFO_NUMBER(PG_private);
+ 	VMCOREINFO_NUMBER(PG_swapcache);
+ 	VMCOREINFO_NUMBER(PG_slab);
+ #ifdef CONFIG_MEMORY_FAILURE
+ 	VMCOREINFO_NUMBER(PG_hwpoison);
+ #endif
+ 	VMCOREINFO_NUMBER(PAGE_BUDDY_MAPCOUNT_VALUE);
+ 
+ 	arch_crash_save_vmcoreinfo();
+ 	update_vmcoreinfo_note();
+ 
+ 	return 0;
+ }
+ 
+ module_init(crash_save_vmcoreinfo_init)
+ 
+ /*
+  * Move into place and start executing a preloaded standalone
+  * executable.  If nothing was preloaded return an error.
+  */
+ int kernel_kexec(void)
+ {
+ 	int error = 0;
+ 
+ 	if (!mutex_trylock(&kexec_mutex))
+ 		return -EBUSY;
+ 	if (!kexec_image) {
+ 		error = -EINVAL;
+ 		goto Unlock;
+ 	}
+ 
+ #ifdef CONFIG_KEXEC_JUMP
+ 	if (kexec_image->preserve_context) {
+ 		lock_system_sleep();
+ 		pm_prepare_console();
+ 		error = freeze_processes();
+ 		if (error) {
+ 			error = -EBUSY;
+ 			goto Restore_console;
+ 		}
+ 		suspend_console();
+ 		error = dpm_suspend_start(PMSG_FREEZE);
+ 		if (error)
+ 			goto Resume_console;
+ 		/* At this point, dpm_suspend_start() has been called,
+ 		 * but *not* dpm_suspend_end(). We *must* call
+ 		 * dpm_suspend_end() now.  Otherwise, drivers for
+ 		 * some devices (e.g. interrupt controllers) become
+ 		 * desynchronized with the actual state of the
+ 		 * hardware at resume time, and evil weirdness ensues.
+ 		 */
+ 		error = dpm_suspend_end(PMSG_FREEZE);
+ 		if (error)
+ 			goto Resume_devices;
+ 		error = disable_nonboot_cpus();
+ 		if (error)
+ 			goto Enable_cpus;
+ 		local_irq_disable();
+ 		error = syscore_suspend();
+ 		if (error)
+ 			goto Enable_irqs;
+ 	} else
+ #endif
+ 	{
+ 		kexec_in_progress = true;
+ 		kernel_restart_prepare(NULL);
+ 		migrate_to_reboot_cpu();
+ 		printk(KERN_EMERG "Starting new kernel\n");
+ 		machine_shutdown();
+ 	}
+ 
+ 	machine_kexec(kexec_image);
+ 
+ #ifdef CONFIG_KEXEC_JUMP
+ 	if (kexec_image->preserve_context) {
+ 		syscore_resume();
+  Enable_irqs:
+ 		local_irq_enable();
+  Enable_cpus:
+ 		enable_nonboot_cpus();
+ 		dpm_resume_start(PMSG_RESTORE);
+  Resume_devices:
+ 		dpm_resume_end(PMSG_RESTORE);
+  Resume_console:
+ 		resume_console();
+ 		thaw_processes();
+  Restore_console:
+ 		pm_restore_console();
+ 		unlock_system_sleep();
+ 	}
+ #endif
+ 
+  Unlock:
+ 	mutex_unlock(&kexec_mutex);
+ 	return error;
+ }
Only in ./: p8.patch
